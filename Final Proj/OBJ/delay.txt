; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o..\OBJ\delay.o --depend=..\OBJ\delay.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\OLED -I..\HARDWARE\ADC -I..\HARDWARE\TIMER -I..\HARDWARE\MOTOR -I..\BALANCE\CONTROL -I..\HARDWARE\ENCODER -I..\HARDWARE\IIC -I..\BALANCE\CONTROL -I..\BALANCE\DMP -I..\BALANCE\filter -I..\BALANCE\MPU6050 -I..\BALANCE\show -I..\BALANCE\controls -I..\HARDWARE\USART3 -I..\HARDWARE\EXTI -I..\HARDWARE\DataScope_DP -I"H:\KEIL MDK4\ARM\INC" -I"H:\KEIL MDK4\ARM\INC\STMicroelectronics" -DSTM32F10X_MD --omf_browse=..\OBJ\delay.crf ..\SYSTEM\delay\delay.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  delay_init PROC
;;;26     //SYSCLK:系统时钟
;;;27     void delay_init(u8 SYSCLK)
000000  f04f21e0          MOV      r1,#0xe000e000
;;;28     {
;;;29     #ifdef OS_CRITICAL_METHOD 	//如果OS_CRITICAL_METHOD定义了,说明使用ucosII了.
;;;30     	u32 reload;
;;;31     #endif
;;;32      	SysTick->CTRL&=~(1<<2);	//SYSTICK使用外部时钟源	 
000004  6909              LDR      r1,[r1,#0x10]
000006  f0210104          BIC      r1,r1,#4
00000a  f04f22e0          MOV      r2,#0xe000e000
00000e  6111              STR      r1,[r2,#0x10]
;;;33     	fac_us=SYSCLK/8;		//不论是否使用ucos,fac_us都需要使用
000010  17c2              ASRS     r2,r0,#31
000012  eb007252          ADD      r2,r0,r2,LSR #29
000016  10d2              ASRS     r2,r2,#3
000018  4b1f              LDR      r3,|L1.152|
00001a  701a              STRB     r2,[r3,#0]
;;;34     	    
;;;35     #ifdef OS_CRITICAL_METHOD 	//如果OS_CRITICAL_METHOD定义了,说明使用ucosII了.
;;;36     	reload=SYSCLK/8;		//每秒钟的计数次数 单位为K	   
;;;37     	reload*=1000000/OS_TICKS_PER_SEC;//根据OS_TICKS_PER_SEC设定溢出时间
;;;38     							//reload为24位寄存器,最大值:16777216,在72M下,约合1.86s左右	
;;;39     	fac_ms=1000/OS_TICKS_PER_SEC;//代表ucos可以延时的最少单位	   
;;;40     	SysTick->CTRL|=1<<1;   	//开启SYSTICK中断
;;;41     	SysTick->LOAD=reload; 	//每1/OS_TICKS_PER_SEC秒中断一次	
;;;42     	SysTick->CTRL|=1<<0;   	//开启SYSTICK    
;;;43     #else
;;;44     	fac_ms=(u16)fac_us*1000;//非ucos下,代表每个ms需要的systick时钟数   
00001c  4619              MOV      r1,r3
00001e  7809              LDRB     r1,[r1,#0]  ; fac_us
000020  f44f727a          MOV      r2,#0x3e8
000024  4351              MULS     r1,r2,r1
000026  4a1d              LDR      r2,|L1.156|
000028  8011              STRH     r1,[r2,#0]
;;;45     #endif
;;;46     }								    
00002a  4770              BX       lr
;;;47     
                          ENDP

                  delay_us PROC
;;;89     //nus为要延时的us数.		    								   
;;;90     void delay_us(u32 nus)
00002c  4601              MOV      r1,r0
;;;91     {		
;;;92     	u32 temp;	    	 
;;;93     	SysTick->LOAD=nus*fac_us; //时间加载	  		 
00002e  4a1a              LDR      r2,|L1.152|
000030  7812              LDRB     r2,[r2,#0]  ; fac_us
000032  434a              MULS     r2,r1,r2
000034  f04f23e0          MOV      r3,#0xe000e000
000038  615a              STR      r2,[r3,#0x14]
;;;94     	SysTick->VAL=0x00;        //清空计数器
00003a  2200              MOVS     r2,#0
00003c  619a              STR      r2,[r3,#0x18]
;;;95     	SysTick->CTRL=0x01 ;      //开始倒数 	 
00003e  2201              MOVS     r2,#1
000040  611a              STR      r2,[r3,#0x10]
;;;96     	do
000042  bf00              NOP      
                  |L1.68|
;;;97     	{
;;;98     		temp=SysTick->CTRL;
000044  f04f22e0          MOV      r2,#0xe000e000
000048  6910              LDR      r0,[r2,#0x10]
;;;99     	}
;;;100    	while((temp&0x01)&&!(temp&(1<<16)));//等待时间到达   
00004a  f0100f01          TST      r0,#1
00004e  d002              BEQ      |L1.86|
000050  f4103f80          TST      r0,#0x10000
000054  d0f6              BEQ      |L1.68|
                  |L1.86|
;;;101    	SysTick->CTRL=0x00;       //关闭计数器
000056  2200              MOVS     r2,#0
000058  f04f23e0          MOV      r3,#0xe000e000
00005c  611a              STR      r2,[r3,#0x10]
;;;102    	SysTick->VAL =0X00;       //清空计数器	 
00005e  619a              STR      r2,[r3,#0x18]
;;;103    }
000060  4770              BX       lr
;;;104    //延时nms
                          ENDP

                  delay_ms PROC
;;;109    //对72M条件下,nms<=1864 
;;;110    void delay_ms(u16 nms)
000062  4601              MOV      r1,r0
;;;111    {	 		  	  
;;;112    	u32 temp;		   
;;;113    	SysTick->LOAD=(u32)nms*fac_ms;//时间加载(SysTick->LOAD为24bit)
000064  4a0d              LDR      r2,|L1.156|
000066  8812              LDRH     r2,[r2,#0]  ; fac_ms
000068  434a              MULS     r2,r1,r2
00006a  f04f23e0          MOV      r3,#0xe000e000
00006e  615a              STR      r2,[r3,#0x14]
;;;114    	SysTick->VAL =0x00;           //清空计数器
000070  2200              MOVS     r2,#0
000072  619a              STR      r2,[r3,#0x18]
;;;115    	SysTick->CTRL=0x01 ;          //开始倒数  
000074  2201              MOVS     r2,#1
000076  611a              STR      r2,[r3,#0x10]
;;;116    	do
000078  bf00              NOP      
                  |L1.122|
;;;117    	{
;;;118    		temp=SysTick->CTRL;
00007a  f04f22e0          MOV      r2,#0xe000e000
00007e  6910              LDR      r0,[r2,#0x10]
;;;119    	}
;;;120    	while((temp&0x01)&&!(temp&(1<<16)));//等待时间到达   
000080  f0100f01          TST      r0,#1
000084  d002              BEQ      |L1.140|
000086  f4103f80          TST      r0,#0x10000
00008a  d0f6              BEQ      |L1.122|
                  |L1.140|
;;;121    	SysTick->CTRL=0x00;       //关闭计数器
00008c  2200              MOVS     r2,#0
00008e  f04f23e0          MOV      r3,#0xe000e000
000092  611a              STR      r2,[r3,#0x10]
;;;122    	SysTick->VAL =0X00;       //清空计数器	  	    
000094  619a              STR      r2,[r3,#0x18]
;;;123    } 
000096  4770              BX       lr
;;;124    #endif
                          ENDP

                  |L1.152|
                          DCD      fac_us
                  |L1.156|
                          DCD      fac_ms

                          AREA ||.data||, DATA, ALIGN=1

                  fac_us
000000  0000              DCB      0x00,0x00
                  fac_ms
000002  0000              DCW      0x0000
