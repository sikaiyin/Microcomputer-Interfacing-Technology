; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o..\OBJ\inv_mpu.o --depend=..\OBJ\inv_mpu.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\OLED -I..\HARDWARE\ADC -I..\HARDWARE\TIMER -I..\HARDWARE\MOTOR -I..\BALANCE\CONTROL -I..\HARDWARE\ENCODER -I..\HARDWARE\IIC -I..\BALANCE\CONTROL -I..\BALANCE\DMP -I..\BALANCE\filter -I..\BALANCE\MPU6050 -I..\BALANCE\show -I..\BALANCE\controls -I..\HARDWARE\USART3 -I..\HARDWARE\EXTI -I..\HARDWARE\DataScope_DP -I"H:\KEIL MDK4\ARM\INC" -I"H:\KEIL MDK4\ARM\INC\STMicroelectronics" -DSTM32F10X_MD --omf_browse=..\OBJ\inv_mpu.crf ..\BALANCE\DMP\inv_mpu.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  set_int_enable PROC
;;;682     */
;;;683    static int set_int_enable(unsigned char enable)
000000  b538              PUSH     {r3-r5,lr}
;;;684    {
000002  4604              MOV      r4,r0
;;;685        unsigned char tmp;
;;;686    
;;;687        if (st.chip_cfg.dmp_on) {
000004  48fb              LDR      r0,|L1.1012|
000006  f8900024          LDRB     r0,[r0,#0x24]
00000a  b1c0              CBZ      r0,|L1.62|
;;;688            if (enable)
00000c  b114              CBZ      r4,|L1.20|
;;;689                tmp = BIT_DMP_INT_EN;
00000e  2002              MOVS     r0,#2
000010  9000              STR      r0,[sp,#0]
000012  e001              B        |L1.24|
                  |L1.20|
;;;690            else
;;;691                tmp = 0x00;
000014  2000              MOVS     r0,#0
000016  9000              STR      r0,[sp,#0]
                  |L1.24|
;;;692            if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
000018  4af6              LDR      r2,|L1.1012|
00001a  6812              LDR      r2,[r2,#0]  ; st
00001c  7bd1              LDRB     r1,[r2,#0xf]
00001e  4af5              LDR      r2,|L1.1012|
000020  6852              LDR      r2,[r2,#4]  ; st
000022  7810              LDRB     r0,[r2,#0]
000024  466b              MOV      r3,sp
000026  2201              MOVS     r2,#1
000028  f7fffffe          BL       i2cWrite
00002c  b110              CBZ      r0,|L1.52|
;;;693                return -1;
00002e  f04f30ff          MOV      r0,#0xffffffff
                  |L1.50|
;;;694            st.chip_cfg.int_enable = tmp;
;;;695        } else {
;;;696            if (!st.chip_cfg.sensors)
;;;697                return -1;
;;;698            if (enable && st.chip_cfg.int_enable)
;;;699                return 0;
;;;700            if (enable)
;;;701                tmp = BIT_DATA_RDY_EN;
;;;702            else
;;;703                tmp = 0x00;
;;;704            if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
;;;705                return -1;
;;;706            st.chip_cfg.int_enable = tmp;
;;;707        }
;;;708        return 0;
;;;709    }
000032  bd38              POP      {r3-r5,pc}
                  |L1.52|
000034  f89d1000          LDRB     r1,[sp,#0]            ;694
000038  48ee              LDR      r0,|L1.1012|
00003a  7441              STRB     r1,[r0,#0x11]         ;694
00003c  e023              B        |L1.134|
                  |L1.62|
00003e  48ed              LDR      r0,|L1.1012|
000040  7a80              LDRB     r0,[r0,#0xa]          ;696
000042  b910              CBNZ     r0,|L1.74|
000044  f04f30ff          MOV      r0,#0xffffffff        ;697
000048  e7f3              B        |L1.50|
                  |L1.74|
00004a  b124              CBZ      r4,|L1.86|
00004c  48e9              LDR      r0,|L1.1012|
00004e  7c40              LDRB     r0,[r0,#0x11]         ;698
000050  b108              CBZ      r0,|L1.86|
000052  2000              MOVS     r0,#0                 ;699
000054  e7ed              B        |L1.50|
                  |L1.86|
000056  b114              CBZ      r4,|L1.94|
000058  2001              MOVS     r0,#1                 ;701
00005a  9000              STR      r0,[sp,#0]            ;701
00005c  e001              B        |L1.98|
                  |L1.94|
00005e  2000              MOVS     r0,#0                 ;703
000060  9000              STR      r0,[sp,#0]            ;703
                  |L1.98|
000062  4ae4              LDR      r2,|L1.1012|
000064  6812              LDR      r2,[r2,#0]            ;704  ; st
000066  7bd1              LDRB     r1,[r2,#0xf]          ;704
000068  4ae2              LDR      r2,|L1.1012|
00006a  6852              LDR      r2,[r2,#4]            ;704  ; st
00006c  7810              LDRB     r0,[r2,#0]            ;704
00006e  466b              MOV      r3,sp                 ;704
000070  2201              MOVS     r2,#1                 ;704
000072  f7fffffe          BL       i2cWrite
000076  b110              CBZ      r0,|L1.126|
000078  f04f30ff          MOV      r0,#0xffffffff        ;705
00007c  e7d9              B        |L1.50|
                  |L1.126|
00007e  f89d1000          LDRB     r1,[sp,#0]            ;706
000082  48dc              LDR      r0,|L1.1012|
000084  7441              STRB     r1,[r0,#0x11]         ;706
                  |L1.134|
000086  2000              MOVS     r0,#0                 ;708
000088  e7d3              B        |L1.50|
;;;710    
                          ENDP

                  mpu_reg_dump PROC
;;;715     */
;;;716    int mpu_reg_dump(void)
00008a  b538              PUSH     {r3-r5,lr}
;;;717    {
;;;718        unsigned char ii;
;;;719        unsigned char data;
;;;720    
;;;721        for (ii = 0; ii < st.hw->num_reg; ii++) {
00008c  2400              MOVS     r4,#0
00008e  e019              B        |L1.196|
                  |L1.144|
;;;722            if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
000090  48d8              LDR      r0,|L1.1012|
000092  6800              LDR      r0,[r0,#0]  ; st
000094  7ac0              LDRB     r0,[r0,#0xb]
000096  42a0              CMP      r0,r4
000098  d004              BEQ      |L1.164|
00009a  48d6              LDR      r0,|L1.1012|
00009c  6800              LDR      r0,[r0,#0]  ; st
00009e  7d40              LDRB     r0,[r0,#0x15]
0000a0  42a0              CMP      r0,r4
0000a2  d100              BNE      |L1.166|
                  |L1.164|
;;;723                continue;
0000a4  e00c              B        |L1.192|
                  |L1.166|
;;;724            if (i2c_read(st.hw->addr, ii, 1, &data))
0000a6  49d3              LDR      r1,|L1.1012|
0000a8  6849              LDR      r1,[r1,#4]  ; st
0000aa  7808              LDRB     r0,[r1,#0]
0000ac  466b              MOV      r3,sp
0000ae  2201              MOVS     r2,#1
0000b0  4621              MOV      r1,r4
0000b2  f7fffffe          BL       i2cRead
0000b6  b110              CBZ      r0,|L1.190|
;;;725                return -1;
0000b8  f04f30ff          MOV      r0,#0xffffffff
                  |L1.188|
;;;726            //log_i("%#5x: %#5x\r\n", ii, data);
;;;727        }
;;;728        return 0;
;;;729    }
0000bc  bd38              POP      {r3-r5,pc}
                  |L1.190|
0000be  bf00              NOP                            ;723
                  |L1.192|
0000c0  1c60              ADDS     r0,r4,#1              ;721
0000c2  b2c4              UXTB     r4,r0                 ;721
                  |L1.196|
0000c4  48cb              LDR      r0,|L1.1012|
0000c6  6840              LDR      r0,[r0,#4]            ;721  ; st
0000c8  7900              LDRB     r0,[r0,#4]            ;721
0000ca  42a0              CMP      r0,r4                 ;721
0000cc  dce0              BGT      |L1.144|
0000ce  2000              MOVS     r0,#0                 ;728
0000d0  e7f4              B        |L1.188|
;;;730    
                          ENDP

                  mpu_read_reg PROC
;;;737     */
;;;738    int mpu_read_reg(unsigned char reg, unsigned char *data)
0000d2  b570              PUSH     {r4-r6,lr}
;;;739    {
0000d4  4604              MOV      r4,r0
0000d6  460d              MOV      r5,r1
;;;740        if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
0000d8  48c6              LDR      r0,|L1.1012|
0000da  6800              LDR      r0,[r0,#0]  ; st
0000dc  7ac0              LDRB     r0,[r0,#0xb]
0000de  42a0              CMP      r0,r4
0000e0  d004              BEQ      |L1.236|
0000e2  48c4              LDR      r0,|L1.1012|
0000e4  6800              LDR      r0,[r0,#0]  ; st
0000e6  7d40              LDRB     r0,[r0,#0x15]
0000e8  42a0              CMP      r0,r4
0000ea  d102              BNE      |L1.242|
                  |L1.236|
;;;741            return -1;
0000ec  f04f30ff          MOV      r0,#0xffffffff
                  |L1.240|
;;;742        if (reg >= st.hw->num_reg)
;;;743            return -1;
;;;744        return i2c_read(st.hw->addr, reg, 1, data);
;;;745    }
0000f0  bd70              POP      {r4-r6,pc}
                  |L1.242|
0000f2  48c0              LDR      r0,|L1.1012|
0000f4  6840              LDR      r0,[r0,#4]            ;742  ; st
0000f6  7900              LDRB     r0,[r0,#4]            ;742
0000f8  42a0              CMP      r0,r4                 ;742
0000fa  dc02              BGT      |L1.258|
0000fc  f04f30ff          MOV      r0,#0xffffffff        ;743
000100  e7f6              B        |L1.240|
                  |L1.258|
000102  49bc              LDR      r1,|L1.1012|
000104  6849              LDR      r1,[r1,#4]            ;744  ; st
000106  7808              LDRB     r0,[r1,#0]            ;744
000108  462b              MOV      r3,r5                 ;744
00010a  2201              MOVS     r2,#1                 ;744
00010c  4621              MOV      r1,r4                 ;744
00010e  f7fffffe          BL       i2cRead
000112  e7ed              B        |L1.240|
;;;746    
                          ENDP

                  mpu_set_int_latched PROC
;;;1880    */
;;;1881   int mpu_set_int_latched(unsigned char enable)
000114  b538              PUSH     {r3-r5,lr}
;;;1882   {
000116  4604              MOV      r4,r0
;;;1883       unsigned char tmp;
;;;1884       if (st.chip_cfg.latched_int == enable)
000118  48b6              LDR      r0,|L1.1012|
00011a  f8900023          LDRB     r0,[r0,#0x23]
00011e  42a0              CMP      r0,r4
000120  d101              BNE      |L1.294|
;;;1885           return 0;
000122  2000              MOVS     r0,#0
                  |L1.292|
;;;1886   
;;;1887       if (enable)
;;;1888           tmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;
;;;1889       else
;;;1890           tmp = 0;
;;;1891       if (st.chip_cfg.bypass_mode)
;;;1892           tmp |= BIT_BYPASS_EN;
;;;1893       if (st.chip_cfg.active_low_int)
;;;1894           tmp |= BIT_ACTL;
;;;1895       if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
;;;1896           return -1;
;;;1897       st.chip_cfg.latched_int = enable;
;;;1898       return 0;
;;;1899   }
000124  bd38              POP      {r3-r5,pc}
                  |L1.294|
000126  b114              CBZ      r4,|L1.302|
000128  2030              MOVS     r0,#0x30              ;1888
00012a  9000              STR      r0,[sp,#0]            ;1888
00012c  e001              B        |L1.306|
                  |L1.302|
00012e  2000              MOVS     r0,#0                 ;1890
000130  9000              STR      r0,[sp,#0]            ;1890
                  |L1.306|
000132  48b0              LDR      r0,|L1.1012|
000134  7c80              LDRB     r0,[r0,#0x12]         ;1891
000136  b120              CBZ      r0,|L1.322|
000138  f89d0000          LDRB     r0,[sp,#0]            ;1892
00013c  f0400002          ORR      r0,r0,#2              ;1892
000140  9000              STR      r0,[sp,#0]            ;1892
                  |L1.322|
000142  48ac              LDR      r0,|L1.1012|
000144  f8900022          LDRB     r0,[r0,#0x22]         ;1893
000148  b120              CBZ      r0,|L1.340|
00014a  f89d0000          LDRB     r0,[sp,#0]            ;1894
00014e  f0400080          ORR      r0,r0,#0x80           ;1894
000152  9000              STR      r0,[sp,#0]            ;1894
                  |L1.340|
000154  4aa7              LDR      r2,|L1.1012|
000156  6812              LDR      r2,[r2,#0]            ;1895  ; st
000158  7d11              LDRB     r1,[r2,#0x14]         ;1895
00015a  4aa6              LDR      r2,|L1.1012|
00015c  6852              LDR      r2,[r2,#4]            ;1895  ; st
00015e  7810              LDRB     r0,[r2,#0]            ;1895
000160  466b              MOV      r3,sp                 ;1895
000162  2201              MOVS     r2,#1                 ;1895
000164  f7fffffe          BL       i2cWrite
000168  b110              CBZ      r0,|L1.368|
00016a  f04f30ff          MOV      r0,#0xffffffff        ;1896
00016e  e7d9              B        |L1.292|
                  |L1.368|
000170  48a0              LDR      r0,|L1.1012|
000172  f8804023          STRB     r4,[r0,#0x23]         ;1897
000176  2000              MOVS     r0,#0                 ;1898
000178  e7d4              B        |L1.292|
;;;1900   
                          ENDP

                  mpu_set_sensors PROC
;;;1593    */
;;;1594   int mpu_set_sensors(unsigned char sensors)
00017a  b538              PUSH     {r3-r5,lr}
;;;1595   {
00017c  4604              MOV      r4,r0
;;;1596       unsigned char data;
;;;1597   #ifdef AK89xx_SECONDARY
;;;1598       unsigned char user_ctrl;
;;;1599   #endif
;;;1600   
;;;1601       if (sensors & INV_XYZ_GYRO)
00017e  f0140f70          TST      r4,#0x70
000182  d002              BEQ      |L1.394|
;;;1602           data = INV_CLK_PLL;
000184  2001              MOVS     r0,#1
000186  9000              STR      r0,[sp,#0]
000188  e005              B        |L1.406|
                  |L1.394|
;;;1603       else if (sensors)
00018a  b114              CBZ      r4,|L1.402|
;;;1604           data = 0;
00018c  2000              MOVS     r0,#0
00018e  9000              STR      r0,[sp,#0]
000190  e001              B        |L1.406|
                  |L1.402|
;;;1605       else
;;;1606           data = BIT_SLEEP;
000192  2040              MOVS     r0,#0x40
000194  9000              STR      r0,[sp,#0]
                  |L1.406|
;;;1607       if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
000196  4a97              LDR      r2,|L1.1012|
000198  6812              LDR      r2,[r2,#0]  ; st
00019a  7c91              LDRB     r1,[r2,#0x12]
00019c  4a95              LDR      r2,|L1.1012|
00019e  6852              LDR      r2,[r2,#4]  ; st
0001a0  7810              LDRB     r0,[r2,#0]
0001a2  466b              MOV      r3,sp
0001a4  2201              MOVS     r2,#1
0001a6  f7fffffe          BL       i2cWrite
0001aa  b120              CBZ      r0,|L1.438|
;;;1608           st.chip_cfg.sensors = 0;
0001ac  2100              MOVS     r1,#0
0001ae  4891              LDR      r0,|L1.1012|
0001b0  7281              STRB     r1,[r0,#0xa]
;;;1609           return -1;
0001b2  1e48              SUBS     r0,r1,#1
                  |L1.436|
;;;1610       }
;;;1611       st.chip_cfg.clk_src = data & ~BIT_SLEEP;
;;;1612   
;;;1613       data = 0;
;;;1614       if (!(sensors & INV_X_GYRO))
;;;1615           data |= BIT_STBY_XG;
;;;1616       if (!(sensors & INV_Y_GYRO))
;;;1617           data |= BIT_STBY_YG;
;;;1618       if (!(sensors & INV_Z_GYRO))
;;;1619           data |= BIT_STBY_ZG;
;;;1620       if (!(sensors & INV_XYZ_ACCEL))
;;;1621           data |= BIT_STBY_XYZA;
;;;1622       if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
;;;1623           st.chip_cfg.sensors = 0;
;;;1624           return -1;
;;;1625       }
;;;1626   
;;;1627       if (sensors && (sensors != INV_XYZ_ACCEL))
;;;1628           /* Latched interrupts only used in LP accel mode. */
;;;1629           mpu_set_int_latched(0);
;;;1630   
;;;1631   #ifdef AK89xx_SECONDARY
;;;1632   #ifdef AK89xx_BYPASS
;;;1633       if (sensors & INV_XYZ_COMPASS)
;;;1634           mpu_set_bypass(1);
;;;1635       else
;;;1636           mpu_set_bypass(0);
;;;1637   #else
;;;1638       if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
;;;1639           return -1;
;;;1640       /* Handle AKM power management. */
;;;1641       if (sensors & INV_XYZ_COMPASS) {
;;;1642           data = AKM_SINGLE_MEASUREMENT;
;;;1643           user_ctrl |= BIT_AUX_IF_EN;
;;;1644       } else {
;;;1645           data = AKM_POWER_DOWN;
;;;1646           user_ctrl &= ~BIT_AUX_IF_EN;
;;;1647       }
;;;1648       if (st.chip_cfg.dmp_on)
;;;1649           user_ctrl |= BIT_DMP_EN;
;;;1650       else
;;;1651           user_ctrl &= ~BIT_DMP_EN;
;;;1652       if (i2c_write(st.hw->addr, st.reg->s1_do, 1, &data))
;;;1653           return -1;
;;;1654       /* Enable/disable I2C master mode. */
;;;1655       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
;;;1656           return -1;
;;;1657   #endif
;;;1658   #endif
;;;1659   
;;;1660       st.chip_cfg.sensors = sensors;
;;;1661       st.chip_cfg.lp_accel_mode = 0;
;;;1662       delay_ms(50);
;;;1663       return 0;
;;;1664   }
0001b4  bd38              POP      {r3-r5,pc}
                  |L1.438|
0001b6  f89d0000          LDRB     r0,[sp,#0]            ;1611
0001ba  f0200040          BIC      r0,r0,#0x40           ;1611
0001be  498d              LDR      r1,|L1.1012|
0001c0  7308              STRB     r0,[r1,#0xc]          ;1611
0001c2  2000              MOVS     r0,#0                 ;1613
0001c4  9000              STR      r0,[sp,#0]            ;1613
0001c6  f0140f40          TST      r4,#0x40              ;1614
0001ca  d104              BNE      |L1.470|
0001cc  f89d0000          LDRB     r0,[sp,#0]            ;1615
0001d0  f0400004          ORR      r0,r0,#4              ;1615
0001d4  9000              STR      r0,[sp,#0]            ;1615
                  |L1.470|
0001d6  f0140f20          TST      r4,#0x20              ;1616
0001da  d104              BNE      |L1.486|
0001dc  f89d0000          LDRB     r0,[sp,#0]            ;1617
0001e0  f0400002          ORR      r0,r0,#2              ;1617
0001e4  9000              STR      r0,[sp,#0]            ;1617
                  |L1.486|
0001e6  f0140f10          TST      r4,#0x10              ;1618
0001ea  d104              BNE      |L1.502|
0001ec  f89d0000          LDRB     r0,[sp,#0]            ;1619
0001f0  f0400001          ORR      r0,r0,#1              ;1619
0001f4  9000              STR      r0,[sp,#0]            ;1619
                  |L1.502|
0001f6  f0140f08          TST      r4,#8                 ;1620
0001fa  d104              BNE      |L1.518|
0001fc  f89d0000          LDRB     r0,[sp,#0]            ;1621
000200  f0400038          ORR      r0,r0,#0x38           ;1621
000204  9000              STR      r0,[sp,#0]            ;1621
                  |L1.518|
000206  4a7b              LDR      r2,|L1.1012|
000208  6812              LDR      r2,[r2,#0]            ;1622  ; st
00020a  7cd1              LDRB     r1,[r2,#0x13]         ;1622
00020c  4a79              LDR      r2,|L1.1012|
00020e  6852              LDR      r2,[r2,#4]            ;1622  ; st
000210  7810              LDRB     r0,[r2,#0]            ;1622
000212  466b              MOV      r3,sp                 ;1622
000214  2201              MOVS     r2,#1                 ;1622
000216  f7fffffe          BL       i2cWrite
00021a  b120              CBZ      r0,|L1.550|
00021c  2100              MOVS     r1,#0                 ;1623
00021e  4875              LDR      r0,|L1.1012|
000220  7281              STRB     r1,[r0,#0xa]          ;1623
000222  1e48              SUBS     r0,r1,#1              ;1624
000224  e7c6              B        |L1.436|
                  |L1.550|
000226  b124              CBZ      r4,|L1.562|
000228  2c08              CMP      r4,#8                 ;1627
00022a  d002              BEQ      |L1.562|
00022c  2000              MOVS     r0,#0                 ;1629
00022e  f7fffffe          BL       mpu_set_int_latched
                  |L1.562|
000232  4870              LDR      r0,|L1.1012|
000234  7284              STRB     r4,[r0,#0xa]          ;1660
000236  2100              MOVS     r1,#0                 ;1661
000238  7501              STRB     r1,[r0,#0x14]         ;1661
00023a  2032              MOVS     r0,#0x32              ;1662
00023c  f7fffffe          BL       delay_ms
000240  2000              MOVS     r0,#0                 ;1663
000242  e7b7              B        |L1.436|
;;;1665   
                          ENDP

                  mpu_set_bypass PROC
;;;1818    */
;;;1819   int mpu_set_bypass(unsigned char bypass_on)
000244  b538              PUSH     {r3-r5,lr}
;;;1820   {
000246  4604              MOV      r4,r0
;;;1821       unsigned char tmp;
;;;1822   
;;;1823       if (st.chip_cfg.bypass_mode == bypass_on)
000248  486a              LDR      r0,|L1.1012|
00024a  7c80              LDRB     r0,[r0,#0x12]
00024c  42a0              CMP      r0,r4
00024e  d101              BNE      |L1.596|
;;;1824           return 0;
000250  2000              MOVS     r0,#0
                  |L1.594|
;;;1825   
;;;1826       if (bypass_on) {
;;;1827           if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
;;;1828               return -1;
;;;1829           tmp &= ~BIT_AUX_IF_EN;
;;;1830           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
;;;1831               return -1;
;;;1832           delay_ms(3);
;;;1833           tmp = BIT_BYPASS_EN;
;;;1834           if (st.chip_cfg.active_low_int)
;;;1835               tmp |= BIT_ACTL;
;;;1836           if (st.chip_cfg.latched_int)
;;;1837               tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
;;;1838           if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
;;;1839               return -1;
;;;1840       } else {
;;;1841           /* Enable I2C master mode if compass is being used. */
;;;1842           if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
;;;1843               return -1;
;;;1844           if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
;;;1845               tmp |= BIT_AUX_IF_EN;
;;;1846           else
;;;1847               tmp &= ~BIT_AUX_IF_EN;
;;;1848           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
;;;1849               return -1;
;;;1850           delay_ms(3);
;;;1851           if (st.chip_cfg.active_low_int)
;;;1852               tmp = BIT_ACTL;
;;;1853           else
;;;1854               tmp = 0;
;;;1855           if (st.chip_cfg.latched_int)
;;;1856               tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
;;;1857           if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
;;;1858               return -1;
;;;1859       }
;;;1860       st.chip_cfg.bypass_mode = bypass_on;
;;;1861       return 0;
;;;1862   }
000252  bd38              POP      {r3-r5,pc}
                  |L1.596|
000254  b3f4              CBZ      r4,|L1.724|
000256  4a67              LDR      r2,|L1.1012|
000258  6812              LDR      r2,[r2,#0]            ;1827  ; st
00025a  7911              LDRB     r1,[r2,#4]            ;1827
00025c  4a65              LDR      r2,|L1.1012|
00025e  6852              LDR      r2,[r2,#4]            ;1827  ; st
000260  7810              LDRB     r0,[r2,#0]            ;1827
000262  466b              MOV      r3,sp                 ;1827
000264  2201              MOVS     r2,#1                 ;1827
000266  f7fffffe          BL       i2cRead
00026a  b110              CBZ      r0,|L1.626|
00026c  f04f30ff          MOV      r0,#0xffffffff        ;1828
000270  e7ef              B        |L1.594|
                  |L1.626|
000272  f89d0000          LDRB     r0,[sp,#0]            ;1829
000276  f0200020          BIC      r0,r0,#0x20           ;1829
00027a  9000              STR      r0,[sp,#0]            ;1829
00027c  4a5d              LDR      r2,|L1.1012|
00027e  6812              LDR      r2,[r2,#0]            ;1830  ; st
000280  7911              LDRB     r1,[r2,#4]            ;1830
000282  4a5c              LDR      r2,|L1.1012|
000284  6852              LDR      r2,[r2,#4]            ;1830  ; st
000286  7810              LDRB     r0,[r2,#0]            ;1830
000288  466b              MOV      r3,sp                 ;1830
00028a  2201              MOVS     r2,#1                 ;1830
00028c  f7fffffe          BL       i2cWrite
000290  b110              CBZ      r0,|L1.664|
000292  f04f30ff          MOV      r0,#0xffffffff        ;1831
000296  e7dc              B        |L1.594|
                  |L1.664|
000298  2003              MOVS     r0,#3                 ;1832
00029a  f7fffffe          BL       delay_ms
00029e  2002              MOVS     r0,#2                 ;1833
0002a0  9000              STR      r0,[sp,#0]            ;1833
0002a2  4854              LDR      r0,|L1.1012|
0002a4  f8900022          LDRB     r0,[r0,#0x22]         ;1834
0002a8  b120              CBZ      r0,|L1.692|
0002aa  f89d0000          LDRB     r0,[sp,#0]            ;1835
0002ae  f0400080          ORR      r0,r0,#0x80           ;1835
0002b2  9000              STR      r0,[sp,#0]            ;1835
                  |L1.692|
0002b4  484f              LDR      r0,|L1.1012|
0002b6  f8900023          LDRB     r0,[r0,#0x23]         ;1836
0002ba  b120              CBZ      r0,|L1.710|
0002bc  f89d0000          LDRB     r0,[sp,#0]            ;1837
0002c0  f0400030          ORR      r0,r0,#0x30           ;1837
0002c4  9000              STR      r0,[sp,#0]            ;1837
                  |L1.710|
0002c6  4a4b              LDR      r2,|L1.1012|
0002c8  6812              LDR      r2,[r2,#0]            ;1838  ; st
0002ca  7d11              LDRB     r1,[r2,#0x14]         ;1838
0002cc  4a49              LDR      r2,|L1.1012|
0002ce  6852              LDR      r2,[r2,#4]            ;1838  ; st
0002d0  7810              LDRB     r0,[r2,#0]            ;1838
0002d2  e000              B        |L1.726|
                  |L1.724|
0002d4  e007              B        |L1.742|
                  |L1.726|
0002d6  466b              MOV      r3,sp                 ;1838
0002d8  2201              MOVS     r2,#1                 ;1838
0002da  f7fffffe          BL       i2cWrite
0002de  b3c0              CBZ      r0,|L1.850|
0002e0  f04f30ff          MOV      r0,#0xffffffff        ;1839
0002e4  e7b5              B        |L1.594|
                  |L1.742|
0002e6  4a43              LDR      r2,|L1.1012|
0002e8  6812              LDR      r2,[r2,#0]            ;1842  ; st
0002ea  7911              LDRB     r1,[r2,#4]            ;1842
0002ec  4a41              LDR      r2,|L1.1012|
0002ee  6852              LDR      r2,[r2,#4]            ;1842  ; st
0002f0  7810              LDRB     r0,[r2,#0]            ;1842
0002f2  466b              MOV      r3,sp                 ;1842
0002f4  2201              MOVS     r2,#1                 ;1842
0002f6  f7fffffe          BL       i2cRead
0002fa  b110              CBZ      r0,|L1.770|
0002fc  f04f30ff          MOV      r0,#0xffffffff        ;1843
000300  e7a7              B        |L1.594|
                  |L1.770|
000302  483c              LDR      r0,|L1.1012|
000304  7a80              LDRB     r0,[r0,#0xa]          ;1844
000306  f0100f01          TST      r0,#1                 ;1844
00030a  d005              BEQ      |L1.792|
00030c  f89d0000          LDRB     r0,[sp,#0]            ;1845
000310  f0400020          ORR      r0,r0,#0x20           ;1845
000314  9000              STR      r0,[sp,#0]            ;1845
000316  e004              B        |L1.802|
                  |L1.792|
000318  f89d0000          LDRB     r0,[sp,#0]            ;1847
00031c  f0200020          BIC      r0,r0,#0x20           ;1847
000320  9000              STR      r0,[sp,#0]            ;1847
                  |L1.802|
000322  4a34              LDR      r2,|L1.1012|
000324  6812              LDR      r2,[r2,#0]            ;1848  ; st
000326  7911              LDRB     r1,[r2,#4]            ;1848
000328  4a32              LDR      r2,|L1.1012|
00032a  6852              LDR      r2,[r2,#4]            ;1848  ; st
00032c  7810              LDRB     r0,[r2,#0]            ;1848
00032e  466b              MOV      r3,sp                 ;1848
000330  2201              MOVS     r2,#1                 ;1848
000332  f7fffffe          BL       i2cWrite
000336  b110              CBZ      r0,|L1.830|
000338  f04f30ff          MOV      r0,#0xffffffff        ;1849
00033c  e789              B        |L1.594|
                  |L1.830|
00033e  2003              MOVS     r0,#3                 ;1850
000340  f7fffffe          BL       delay_ms
000344  482b              LDR      r0,|L1.1012|
000346  f8900022          LDRB     r0,[r0,#0x22]         ;1851
00034a  b118              CBZ      r0,|L1.852|
00034c  2080              MOVS     r0,#0x80              ;1852
00034e  9000              STR      r0,[sp,#0]            ;1852
000350  e002              B        |L1.856|
                  |L1.850|
000352  e018              B        |L1.902|
                  |L1.852|
000354  2000              MOVS     r0,#0                 ;1854
000356  9000              STR      r0,[sp,#0]            ;1854
                  |L1.856|
000358  4826              LDR      r0,|L1.1012|
00035a  f8900023          LDRB     r0,[r0,#0x23]         ;1855
00035e  b120              CBZ      r0,|L1.874|
000360  f89d0000          LDRB     r0,[sp,#0]            ;1856
000364  f0400030          ORR      r0,r0,#0x30           ;1856
000368  9000              STR      r0,[sp,#0]            ;1856
                  |L1.874|
00036a  4a22              LDR      r2,|L1.1012|
00036c  6812              LDR      r2,[r2,#0]            ;1857  ; st
00036e  7d11              LDRB     r1,[r2,#0x14]         ;1857
000370  4a20              LDR      r2,|L1.1012|
000372  6852              LDR      r2,[r2,#4]            ;1857  ; st
000374  7810              LDRB     r0,[r2,#0]            ;1857
000376  466b              MOV      r3,sp                 ;1857
000378  2201              MOVS     r2,#1                 ;1857
00037a  f7fffffe          BL       i2cWrite
00037e  b110              CBZ      r0,|L1.902|
000380  f04f30ff          MOV      r0,#0xffffffff        ;1858
000384  e765              B        |L1.594|
                  |L1.902|
000386  481b              LDR      r0,|L1.1012|
000388  7484              STRB     r4,[r0,#0x12]         ;1860
00038a  2000              MOVS     r0,#0                 ;1861
00038c  e761              B        |L1.594|
;;;1863   
                          ENDP

                  mpu_reset_fifo PROC
;;;1093    */
;;;1094   int mpu_reset_fifo(void)
00038e  b508              PUSH     {r3,lr}
;;;1095   {
;;;1096       unsigned char data;
;;;1097   
;;;1098       if (!(st.chip_cfg.sensors))
000390  4818              LDR      r0,|L1.1012|
000392  7a80              LDRB     r0,[r0,#0xa]
000394  b910              CBNZ     r0,|L1.924|
;;;1099           return -1;
000396  f04f30ff          MOV      r0,#0xffffffff
                  |L1.922|
;;;1100   
;;;1101       data = 0;
;;;1102       if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
;;;1103           return -1;
;;;1104       if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
;;;1105           return -1;
;;;1106       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
;;;1107           return -1;
;;;1108   
;;;1109       if (st.chip_cfg.dmp_on) {
;;;1110           data = BIT_FIFO_RST | BIT_DMP_RST;
;;;1111           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
;;;1112               return -1;
;;;1113          
;;;1114           data = BIT_DMP_EN | BIT_FIFO_EN;
;;;1115           if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
;;;1116               data |= BIT_AUX_IF_EN;
;;;1117           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
;;;1118               return -1;
;;;1119           if (st.chip_cfg.int_enable)
;;;1120               data = BIT_DMP_INT_EN;
;;;1121           else
;;;1122               data = 0;
;;;1123           if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
;;;1124               return -1;
;;;1125           data = 0;
;;;1126           if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
;;;1127               return -1;
;;;1128       } else {
;;;1129           data = BIT_FIFO_RST;
;;;1130           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
;;;1131               return -1;
;;;1132           if (st.chip_cfg.bypass_mode || !(st.chip_cfg.sensors & INV_XYZ_COMPASS))
;;;1133               data = BIT_FIFO_EN;
;;;1134           else
;;;1135               data = BIT_FIFO_EN | BIT_AUX_IF_EN;
;;;1136           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
;;;1137               return -1;
;;;1138       
;;;1139           if (st.chip_cfg.int_enable)
;;;1140               data = BIT_DATA_RDY_EN;
;;;1141           else
;;;1142               data = 0;
;;;1143           if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
;;;1144               return -1;
;;;1145           if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &st.chip_cfg.fifo_enable))
;;;1146               return -1;
;;;1147       }
;;;1148       return 0;
;;;1149   }
00039a  bd08              POP      {r3,pc}
                  |L1.924|
00039c  2000              MOVS     r0,#0                 ;1101
00039e  9000              STR      r0,[sp,#0]            ;1101
0003a0  4a14              LDR      r2,|L1.1012|
0003a2  6812              LDR      r2,[r2,#0]            ;1102  ; st
0003a4  7bd1              LDRB     r1,[r2,#0xf]          ;1102
0003a6  4a13              LDR      r2,|L1.1012|
0003a8  6852              LDR      r2,[r2,#4]            ;1102  ; st
0003aa  7810              LDRB     r0,[r2,#0]            ;1102
0003ac  466b              MOV      r3,sp                 ;1102
0003ae  2201              MOVS     r2,#1                 ;1102
0003b0  f7fffffe          BL       i2cWrite
0003b4  b110              CBZ      r0,|L1.956|
0003b6  f04f30ff          MOV      r0,#0xffffffff        ;1103
0003ba  e7ee              B        |L1.922|
                  |L1.956|
0003bc  4a0d              LDR      r2,|L1.1012|
0003be  6812              LDR      r2,[r2,#0]            ;1104  ; st
0003c0  7951              LDRB     r1,[r2,#5]            ;1104
0003c2  4a0c              LDR      r2,|L1.1012|
0003c4  6852              LDR      r2,[r2,#4]            ;1104  ; st
0003c6  7810              LDRB     r0,[r2,#0]            ;1104
0003c8  466b              MOV      r3,sp                 ;1104
0003ca  2201              MOVS     r2,#1                 ;1104
0003cc  f7fffffe          BL       i2cWrite
0003d0  b110              CBZ      r0,|L1.984|
0003d2  f04f30ff          MOV      r0,#0xffffffff        ;1105
0003d6  e7e0              B        |L1.922|
                  |L1.984|
0003d8  4a06              LDR      r2,|L1.1012|
0003da  6812              LDR      r2,[r2,#0]            ;1106  ; st
0003dc  7911              LDRB     r1,[r2,#4]            ;1106
0003de  4a05              LDR      r2,|L1.1012|
0003e0  6852              LDR      r2,[r2,#4]            ;1106  ; st
0003e2  7810              LDRB     r0,[r2,#0]            ;1106
0003e4  466b              MOV      r3,sp                 ;1106
0003e6  2201              MOVS     r2,#1                 ;1106
0003e8  f7fffffe          BL       i2cWrite
0003ec  b120              CBZ      r0,|L1.1016|
0003ee  f04f30ff          MOV      r0,#0xffffffff        ;1107
0003f2  e7d2              B        |L1.922|
                  |L1.1012|
                          DCD      ||st||
                  |L1.1016|
0003f8  48f8              LDR      r0,|L1.2012|
0003fa  f8900024          LDRB     r0,[r0,#0x24]         ;1109
0003fe  b378              CBZ      r0,|L1.1120|
000400  200c              MOVS     r0,#0xc               ;1110
000402  9000              STR      r0,[sp,#0]            ;1110
000404  4af5              LDR      r2,|L1.2012|
000406  6812              LDR      r2,[r2,#0]            ;1111  ; st
000408  7911              LDRB     r1,[r2,#4]            ;1111
00040a  4af4              LDR      r2,|L1.2012|
00040c  6852              LDR      r2,[r2,#4]            ;1111  ; st
00040e  7810              LDRB     r0,[r2,#0]            ;1111
000410  466b              MOV      r3,sp                 ;1111
000412  2201              MOVS     r2,#1                 ;1111
000414  f7fffffe          BL       i2cWrite
000418  b110              CBZ      r0,|L1.1056|
00041a  f04f30ff          MOV      r0,#0xffffffff        ;1112
00041e  e7bc              B        |L1.922|
                  |L1.1056|
000420  20c0              MOVS     r0,#0xc0              ;1114
000422  9000              STR      r0,[sp,#0]            ;1114
000424  48ed              LDR      r0,|L1.2012|
000426  7a80              LDRB     r0,[r0,#0xa]          ;1115
000428  f0100f01          TST      r0,#1                 ;1115
00042c  d004              BEQ      |L1.1080|
00042e  f89d0000          LDRB     r0,[sp,#0]            ;1116
000432  f0400020          ORR      r0,r0,#0x20           ;1116
000436  9000              STR      r0,[sp,#0]            ;1116
                  |L1.1080|
000438  4ae8              LDR      r2,|L1.2012|
00043a  6812              LDR      r2,[r2,#0]            ;1117  ; st
00043c  7911              LDRB     r1,[r2,#4]            ;1117
00043e  4ae7              LDR      r2,|L1.2012|
000440  6852              LDR      r2,[r2,#4]            ;1117  ; st
000442  7810              LDRB     r0,[r2,#0]            ;1117
000444  466b              MOV      r3,sp                 ;1117
000446  2201              MOVS     r2,#1                 ;1117
000448  f7fffffe          BL       i2cWrite
00044c  b110              CBZ      r0,|L1.1108|
00044e  f04f30ff          MOV      r0,#0xffffffff        ;1118
000452  e7a2              B        |L1.922|
                  |L1.1108|
000454  48e1              LDR      r0,|L1.2012|
000456  7c40              LDRB     r0,[r0,#0x11]         ;1119
000458  b118              CBZ      r0,|L1.1122|
00045a  2002              MOVS     r0,#2                 ;1120
00045c  9000              STR      r0,[sp,#0]            ;1120
00045e  e002              B        |L1.1126|
                  |L1.1120|
000460  e01f              B        |L1.1186|
                  |L1.1122|
000462  2000              MOVS     r0,#0                 ;1122
000464  9000              STR      r0,[sp,#0]            ;1122
                  |L1.1126|
000466  4add              LDR      r2,|L1.2012|
000468  6812              LDR      r2,[r2,#0]            ;1123  ; st
00046a  7bd1              LDRB     r1,[r2,#0xf]          ;1123
00046c  4adb              LDR      r2,|L1.2012|
00046e  6852              LDR      r2,[r2,#4]            ;1123  ; st
000470  7810              LDRB     r0,[r2,#0]            ;1123
000472  466b              MOV      r3,sp                 ;1123
000474  2201              MOVS     r2,#1                 ;1123
000476  f7fffffe          BL       i2cWrite
00047a  b110              CBZ      r0,|L1.1154|
00047c  f04f30ff          MOV      r0,#0xffffffff        ;1124
000480  e78b              B        |L1.922|
                  |L1.1154|
000482  2000              MOVS     r0,#0                 ;1125
000484  9000              STR      r0,[sp,#0]            ;1125
000486  4ad5              LDR      r2,|L1.2012|
000488  6812              LDR      r2,[r2,#0]            ;1126  ; st
00048a  7951              LDRB     r1,[r2,#5]            ;1126
00048c  4ad3              LDR      r2,|L1.2012|
00048e  6852              LDR      r2,[r2,#4]            ;1126  ; st
000490  7810              LDRB     r0,[r2,#0]            ;1126
000492  466b              MOV      r3,sp                 ;1126
000494  2201              MOVS     r2,#1                 ;1126
000496  f7fffffe          BL       i2cWrite
00049a  b398              CBZ      r0,|L1.1284|
00049c  f04f30ff          MOV      r0,#0xffffffff        ;1127
0004a0  e77b              B        |L1.922|
                  |L1.1186|
0004a2  2004              MOVS     r0,#4                 ;1129
0004a4  9000              STR      r0,[sp,#0]            ;1129
0004a6  4acd              LDR      r2,|L1.2012|
0004a8  6812              LDR      r2,[r2,#0]            ;1130  ; st
0004aa  7911              LDRB     r1,[r2,#4]            ;1130
0004ac  4acb              LDR      r2,|L1.2012|
0004ae  6852              LDR      r2,[r2,#4]            ;1130  ; st
0004b0  7810              LDRB     r0,[r2,#0]            ;1130
0004b2  466b              MOV      r3,sp                 ;1130
0004b4  2201              MOVS     r2,#1                 ;1130
0004b6  f7fffffe          BL       i2cWrite
0004ba  b110              CBZ      r0,|L1.1218|
0004bc  f04f30ff          MOV      r0,#0xffffffff        ;1131
0004c0  e76b              B        |L1.922|
                  |L1.1218|
0004c2  48c6              LDR      r0,|L1.2012|
0004c4  7c80              LDRB     r0,[r0,#0x12]         ;1132
0004c6  b920              CBNZ     r0,|L1.1234|
0004c8  48c4              LDR      r0,|L1.2012|
0004ca  7a80              LDRB     r0,[r0,#0xa]          ;1132
0004cc  f0100f01          TST      r0,#1                 ;1132
0004d0  d102              BNE      |L1.1240|
                  |L1.1234|
0004d2  2040              MOVS     r0,#0x40              ;1133
0004d4  9000              STR      r0,[sp,#0]            ;1133
0004d6  e001              B        |L1.1244|
                  |L1.1240|
0004d8  2060              MOVS     r0,#0x60              ;1135
0004da  9000              STR      r0,[sp,#0]            ;1135
                  |L1.1244|
0004dc  4abf              LDR      r2,|L1.2012|
0004de  6812              LDR      r2,[r2,#0]            ;1136  ; st
0004e0  7911              LDRB     r1,[r2,#4]            ;1136
0004e2  4abe              LDR      r2,|L1.2012|
0004e4  6852              LDR      r2,[r2,#4]            ;1136  ; st
0004e6  7810              LDRB     r0,[r2,#0]            ;1136
0004e8  466b              MOV      r3,sp                 ;1136
0004ea  2201              MOVS     r2,#1                 ;1136
0004ec  f7fffffe          BL       i2cWrite
0004f0  b110              CBZ      r0,|L1.1272|
0004f2  f04f30ff          MOV      r0,#0xffffffff        ;1137
0004f6  e750              B        |L1.922|
                  |L1.1272|
0004f8  48b8              LDR      r0,|L1.2012|
0004fa  7c40              LDRB     r0,[r0,#0x11]         ;1139
0004fc  b118              CBZ      r0,|L1.1286|
0004fe  2001              MOVS     r0,#1                 ;1140
000500  9000              STR      r0,[sp,#0]            ;1140
000502  e002              B        |L1.1290|
                  |L1.1284|
000504  e01e              B        |L1.1348|
                  |L1.1286|
000506  2000              MOVS     r0,#0                 ;1142
000508  9000              STR      r0,[sp,#0]            ;1142
                  |L1.1290|
00050a  4ab4              LDR      r2,|L1.2012|
00050c  6812              LDR      r2,[r2,#0]            ;1143  ; st
00050e  7bd1              LDRB     r1,[r2,#0xf]          ;1143
000510  4ab2              LDR      r2,|L1.2012|
000512  6852              LDR      r2,[r2,#4]            ;1143  ; st
000514  7810              LDRB     r0,[r2,#0]            ;1143
000516  466b              MOV      r3,sp                 ;1143
000518  2201              MOVS     r2,#1                 ;1143
00051a  f7fffffe          BL       i2cWrite
00051e  b110              CBZ      r0,|L1.1318|
000520  f04f30ff          MOV      r0,#0xffffffff        ;1144
000524  e739              B        |L1.922|
                  |L1.1318|
000526  4aad              LDR      r2,|L1.2012|
000528  6812              LDR      r2,[r2,#0]            ;1145  ; st
00052a  7951              LDRB     r1,[r2,#5]            ;1145
00052c  4aab              LDR      r2,|L1.2012|
00052e  6852              LDR      r2,[r2,#4]            ;1145  ; st
000530  7810              LDRB     r0,[r2,#0]            ;1145
000532  4baa              LDR      r3,|L1.2012|
000534  3310              ADDS     r3,r3,#0x10           ;1145
000536  2201              MOVS     r2,#1                 ;1145
000538  f7fffffe          BL       i2cWrite
00053c  b110              CBZ      r0,|L1.1348|
00053e  f04f30ff          MOV      r0,#0xffffffff        ;1146
000542  e72a              B        |L1.922|
                  |L1.1348|
000544  2000              MOVS     r0,#0                 ;1148
000546  e728              B        |L1.922|
;;;1150   
                          ENDP

                  mpu_configure_fifo PROC
;;;1532    */
;;;1533   int mpu_configure_fifo(unsigned char sensors)
000548  b570              PUSH     {r4-r6,lr}
;;;1534   {
00054a  4604              MOV      r4,r0
;;;1535       unsigned char prev;
;;;1536       int result = 0;
00054c  2600              MOVS     r6,#0
;;;1537   
;;;1538       /* Compass data isn't going into the FIFO. Stop trying. */
;;;1539       sensors &= ~INV_XYZ_COMPASS;
00054e  f0240401          BIC      r4,r4,#1
;;;1540   
;;;1541       if (st.chip_cfg.dmp_on)
000552  48a2              LDR      r0,|L1.2012|
000554  f8900024          LDRB     r0,[r0,#0x24]
000558  b108              CBZ      r0,|L1.1374|
;;;1542           return 0;
00055a  2000              MOVS     r0,#0
                  |L1.1372|
;;;1543       else {
;;;1544           if (!(st.chip_cfg.sensors))
;;;1545               return -1;
;;;1546           prev = st.chip_cfg.fifo_enable;
;;;1547           st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
;;;1548           if (st.chip_cfg.fifo_enable != sensors)
;;;1549               /* You're not getting what you asked for. Some sensors are
;;;1550                * asleep.
;;;1551                */
;;;1552               result = -1;
;;;1553           else
;;;1554               result = 0;
;;;1555           if (sensors || st.chip_cfg.lp_accel_mode)
;;;1556               set_int_enable(1);
;;;1557           else
;;;1558               set_int_enable(0);
;;;1559           if (sensors) {
;;;1560               if (mpu_reset_fifo()) {
;;;1561                   st.chip_cfg.fifo_enable = prev;
;;;1562                   return -1;
;;;1563               }
;;;1564           }
;;;1565       }
;;;1566   
;;;1567       return result;
;;;1568   }
00055c  bd70              POP      {r4-r6,pc}
                  |L1.1374|
00055e  489f              LDR      r0,|L1.2012|
000560  7a80              LDRB     r0,[r0,#0xa]          ;1544
000562  b910              CBNZ     r0,|L1.1386|
000564  f04f30ff          MOV      r0,#0xffffffff        ;1545
000568  e7f8              B        |L1.1372|
                  |L1.1386|
00056a  489c              LDR      r0,|L1.2012|
00056c  7c05              LDRB     r5,[r0,#0x10]         ;1546
00056e  7a80              LDRB     r0,[r0,#0xa]          ;1547
000570  4020              ANDS     r0,r0,r4              ;1547
000572  499a              LDR      r1,|L1.2012|
000574  7408              STRB     r0,[r1,#0x10]         ;1547
000576  4608              MOV      r0,r1                 ;1548
000578  7c00              LDRB     r0,[r0,#0x10]         ;1548
00057a  42a0              CMP      r0,r4                 ;1548
00057c  d002              BEQ      |L1.1412|
00057e  f04f36ff          MOV      r6,#0xffffffff        ;1552
000582  e000              B        |L1.1414|
                  |L1.1412|
000584  2600              MOVS     r6,#0                 ;1554
                  |L1.1414|
000586  b914              CBNZ     r4,|L1.1422|
000588  4894              LDR      r0,|L1.2012|
00058a  7d00              LDRB     r0,[r0,#0x14]         ;1555
00058c  b118              CBZ      r0,|L1.1430|
                  |L1.1422|
00058e  2001              MOVS     r0,#1                 ;1556
000590  f7fffffe          BL       set_int_enable
000594  e002              B        |L1.1436|
                  |L1.1430|
000596  2000              MOVS     r0,#0                 ;1558
000598  f7fffffe          BL       set_int_enable
                  |L1.1436|
00059c  b13c              CBZ      r4,|L1.1454|
00059e  f7fffffe          BL       mpu_reset_fifo
0005a2  b120              CBZ      r0,|L1.1454|
0005a4  488d              LDR      r0,|L1.2012|
0005a6  7405              STRB     r5,[r0,#0x10]         ;1561
0005a8  f04f30ff          MOV      r0,#0xffffffff        ;1562
0005ac  e7d6              B        |L1.1372|
                  |L1.1454|
0005ae  4630              MOV      r0,r6                 ;1567
0005b0  e7d4              B        |L1.1372|
;;;1569   
                          ENDP

                  mpu_set_lpf PROC
;;;1320    */
;;;1321   int mpu_set_lpf(unsigned short lpf)
0005b2  b538              PUSH     {r3-r5,lr}
;;;1322   {
0005b4  4604              MOV      r4,r0
;;;1323       unsigned char data;
;;;1324   
;;;1325       if (!(st.chip_cfg.sensors))
0005b6  4889              LDR      r0,|L1.2012|
0005b8  7a80              LDRB     r0,[r0,#0xa]
0005ba  b910              CBNZ     r0,|L1.1474|
;;;1326           return -1;
0005bc  f04f30ff          MOV      r0,#0xffffffff
                  |L1.1472|
;;;1327   
;;;1328       if (lpf >= 188)
;;;1329           data = INV_FILTER_188HZ;
;;;1330       else if (lpf >= 98)
;;;1331           data = INV_FILTER_98HZ;
;;;1332       else if (lpf >= 42)
;;;1333           data = INV_FILTER_42HZ;
;;;1334       else if (lpf >= 20)
;;;1335           data = INV_FILTER_20HZ;
;;;1336       else if (lpf >= 10)
;;;1337           data = INV_FILTER_10HZ;
;;;1338       else
;;;1339           data = INV_FILTER_5HZ;
;;;1340   
;;;1341       if (st.chip_cfg.lpf == data)
;;;1342           return 0;
;;;1343       if (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))
;;;1344           return -1;
;;;1345       st.chip_cfg.lpf = data;
;;;1346       return 0;
;;;1347   }
0005c0  bd38              POP      {r3-r5,pc}
                  |L1.1474|
0005c2  2cbc              CMP      r4,#0xbc              ;1328
0005c4  db02              BLT      |L1.1484|
0005c6  2001              MOVS     r0,#1                 ;1329
0005c8  9000              STR      r0,[sp,#0]            ;1329
0005ca  e015              B        |L1.1528|
                  |L1.1484|
0005cc  2c62              CMP      r4,#0x62              ;1330
0005ce  db02              BLT      |L1.1494|
0005d0  2002              MOVS     r0,#2                 ;1331
0005d2  9000              STR      r0,[sp,#0]            ;1331
0005d4  e010              B        |L1.1528|
                  |L1.1494|
0005d6  2c2a              CMP      r4,#0x2a              ;1332
0005d8  db02              BLT      |L1.1504|
0005da  2003              MOVS     r0,#3                 ;1333
0005dc  9000              STR      r0,[sp,#0]            ;1333
0005de  e00b              B        |L1.1528|
                  |L1.1504|
0005e0  2c14              CMP      r4,#0x14              ;1334
0005e2  db02              BLT      |L1.1514|
0005e4  2004              MOVS     r0,#4                 ;1335
0005e6  9000              STR      r0,[sp,#0]            ;1335
0005e8  e006              B        |L1.1528|
                  |L1.1514|
0005ea  2c0a              CMP      r4,#0xa               ;1336
0005ec  db02              BLT      |L1.1524|
0005ee  2005              MOVS     r0,#5                 ;1337
0005f0  9000              STR      r0,[sp,#0]            ;1337
0005f2  e001              B        |L1.1528|
                  |L1.1524|
0005f4  2006              MOVS     r0,#6                 ;1339
0005f6  9000              STR      r0,[sp,#0]            ;1339
                  |L1.1528|
0005f8  4878              LDR      r0,|L1.2012|
0005fa  7ac0              LDRB     r0,[r0,#0xb]          ;1341
0005fc  f89d1000          LDRB     r1,[sp,#0]            ;1341
000600  4288              CMP      r0,r1                 ;1341
000602  d101              BNE      |L1.1544|
000604  2000              MOVS     r0,#0                 ;1342
000606  e7db              B        |L1.1472|
                  |L1.1544|
000608  4a74              LDR      r2,|L1.2012|
00060a  6812              LDR      r2,[r2,#0]            ;1343  ; st
00060c  7891              LDRB     r1,[r2,#2]            ;1343
00060e  4a73              LDR      r2,|L1.2012|
000610  6852              LDR      r2,[r2,#4]            ;1343  ; st
000612  7810              LDRB     r0,[r2,#0]            ;1343
000614  466b              MOV      r3,sp                 ;1343
000616  2201              MOVS     r2,#1                 ;1343
000618  f7fffffe          BL       i2cWrite
00061c  b110              CBZ      r0,|L1.1572|
00061e  f04f30ff          MOV      r0,#0xffffffff        ;1344
000622  e7cd              B        |L1.1472|
                  |L1.1572|
000624  f89d1000          LDRB     r1,[sp,#0]            ;1345
000628  486c              LDR      r0,|L1.2012|
00062a  72c1              STRB     r1,[r0,#0xb]          ;1345
00062c  2000              MOVS     r0,#0                 ;1346
00062e  e7c7              B        |L1.1472|
;;;1348   
                          ENDP

                  mpu_lp_accel_mode PROC
;;;889     */
;;;890    int mpu_lp_accel_mode(unsigned char rate)
000630  b538              PUSH     {r3-r5,lr}
;;;891    {
000632  4604              MOV      r4,r0
;;;892        unsigned char tmp[2];
;;;893    
;;;894        if (rate > 40)
000634  2c28              CMP      r4,#0x28
000636  dd02              BLE      |L1.1598|
;;;895            return -1;
000638  f04f30ff          MOV      r0,#0xffffffff
                  |L1.1596|
;;;896    
;;;897        if (!rate) {
;;;898            mpu_set_int_latched(0);
;;;899            tmp[0] = 0;
;;;900            tmp[1] = BIT_STBY_XYZG;
;;;901            if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
;;;902                return -1;
;;;903            st.chip_cfg.lp_accel_mode = 0;
;;;904            return 0;
;;;905        }
;;;906        /* For LP accel, we automatically configure the hardware to produce latched
;;;907         * interrupts. In LP accel mode, the hardware cycles into sleep mode before
;;;908         * it gets a chance to deassert the interrupt pin; therefore, we shift this
;;;909         * responsibility over to the MCU.
;;;910         *
;;;911         * Any register read will clear the interrupt.
;;;912         */
;;;913        mpu_set_int_latched(1);
;;;914    #if defined MPU6050
;;;915        tmp[0] = BIT_LPA_CYCLE;
;;;916        if (rate == 1) {
;;;917            tmp[1] = INV_LPA_1_25HZ;
;;;918            mpu_set_lpf(5);
;;;919        } else if (rate <= 5) {
;;;920            tmp[1] = INV_LPA_5HZ;
;;;921            mpu_set_lpf(5);
;;;922        } else if (rate <= 20) {
;;;923            tmp[1] = INV_LPA_20HZ;
;;;924            mpu_set_lpf(10);
;;;925        } else {
;;;926            tmp[1] = INV_LPA_40HZ;
;;;927            mpu_set_lpf(20);
;;;928        }
;;;929        tmp[1] = (tmp[1] << 6) | BIT_STBY_XYZG;
;;;930        if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
;;;931            return -1;
;;;932    #elif defined MPU6500
;;;933        /* Set wake frequency. */
;;;934        if (rate == 1)
;;;935            tmp[0] = INV_LPA_1_25HZ;
;;;936        else if (rate == 2)
;;;937            tmp[0] = INV_LPA_2_5HZ;
;;;938        else if (rate <= 5)
;;;939            tmp[0] = INV_LPA_5HZ;
;;;940        else if (rate <= 10)
;;;941            tmp[0] = INV_LPA_10HZ;
;;;942        else if (rate <= 20)
;;;943            tmp[0] = INV_LPA_20HZ;
;;;944        else if (rate <= 40)
;;;945            tmp[0] = INV_LPA_40HZ;
;;;946        else if (rate <= 80)
;;;947            tmp[0] = INV_LPA_80HZ;
;;;948        else if (rate <= 160)
;;;949            tmp[0] = INV_LPA_160HZ;
;;;950        else if (rate <= 320)
;;;951            tmp[0] = INV_LPA_320HZ;
;;;952        else
;;;953            tmp[0] = INV_LPA_640HZ;
;;;954        if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, tmp))
;;;955            return -1;
;;;956        tmp[0] = BIT_LPA_CYCLE;
;;;957        if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, tmp))
;;;958            return -1;
;;;959    #endif
;;;960        st.chip_cfg.sensors = INV_XYZ_ACCEL;
;;;961        st.chip_cfg.clk_src = 0;
;;;962        st.chip_cfg.lp_accel_mode = 1;
;;;963        mpu_configure_fifo(0);
;;;964    
;;;965        return 0;
;;;966    }
00063c  bd38              POP      {r3-r5,pc}
                  |L1.1598|
00063e  b9dc              CBNZ     r4,|L1.1656|
000640  2000              MOVS     r0,#0                 ;898
000642  f7fffffe          BL       mpu_set_int_latched
000646  2000              MOVS     r0,#0                 ;899
000648  f88d0000          STRB     r0,[sp,#0]            ;899
00064c  2007              MOVS     r0,#7                 ;900
00064e  f88d0001          STRB     r0,[sp,#1]            ;900
000652  4a62              LDR      r2,|L1.2012|
000654  6812              LDR      r2,[r2,#0]            ;901  ; st
000656  7c91              LDRB     r1,[r2,#0x12]         ;901
000658  4a60              LDR      r2,|L1.2012|
00065a  6852              LDR      r2,[r2,#4]            ;901  ; st
00065c  7810              LDRB     r0,[r2,#0]            ;901
00065e  466b              MOV      r3,sp                 ;901
000660  2202              MOVS     r2,#2                 ;901
000662  f7fffffe          BL       i2cWrite
000666  b110              CBZ      r0,|L1.1646|
000668  f04f30ff          MOV      r0,#0xffffffff        ;902
00066c  e7e6              B        |L1.1596|
                  |L1.1646|
00066e  2100              MOVS     r1,#0                 ;903
000670  485a              LDR      r0,|L1.2012|
000672  7501              STRB     r1,[r0,#0x14]         ;903
000674  2000              MOVS     r0,#0                 ;904
000676  e7e1              B        |L1.1596|
                  |L1.1656|
000678  2001              MOVS     r0,#1                 ;913
00067a  f7fffffe          BL       mpu_set_int_latched
00067e  2020              MOVS     r0,#0x20              ;915
000680  f88d0000          STRB     r0,[sp,#0]            ;915
000684  2c01              CMP      r4,#1                 ;916
000686  d106              BNE      |L1.1686|
000688  2000              MOVS     r0,#0                 ;917
00068a  f88d0001          STRB     r0,[sp,#1]            ;917
00068e  2005              MOVS     r0,#5                 ;918
000690  f7fffffe          BL       mpu_set_lpf
000694  e017              B        |L1.1734|
                  |L1.1686|
000696  2c05              CMP      r4,#5                 ;919
000698  dc06              BGT      |L1.1704|
00069a  2001              MOVS     r0,#1                 ;920
00069c  f88d0001          STRB     r0,[sp,#1]            ;920
0006a0  2005              MOVS     r0,#5                 ;921
0006a2  f7fffffe          BL       mpu_set_lpf
0006a6  e00e              B        |L1.1734|
                  |L1.1704|
0006a8  2c14              CMP      r4,#0x14              ;922
0006aa  dc06              BGT      |L1.1722|
0006ac  2002              MOVS     r0,#2                 ;923
0006ae  f88d0001          STRB     r0,[sp,#1]            ;923
0006b2  200a              MOVS     r0,#0xa               ;924
0006b4  f7fffffe          BL       mpu_set_lpf
0006b8  e005              B        |L1.1734|
                  |L1.1722|
0006ba  2003              MOVS     r0,#3                 ;926
0006bc  f88d0001          STRB     r0,[sp,#1]            ;926
0006c0  2014              MOVS     r0,#0x14              ;927
0006c2  f7fffffe          BL       mpu_set_lpf
                  |L1.1734|
0006c6  f89d0001          LDRB     r0,[sp,#1]            ;929
0006ca  2107              MOVS     r1,#7                 ;929
0006cc  eb011080          ADD      r0,r1,r0,LSL #6       ;929
0006d0  b2c0              UXTB     r0,r0                 ;929
0006d2  f88d0001          STRB     r0,[sp,#1]            ;929
0006d6  4a41              LDR      r2,|L1.2012|
0006d8  6812              LDR      r2,[r2,#0]            ;930  ; st
0006da  7c91              LDRB     r1,[r2,#0x12]         ;930
0006dc  4a3f              LDR      r2,|L1.2012|
0006de  6852              LDR      r2,[r2,#4]            ;930  ; st
0006e0  7810              LDRB     r0,[r2,#0]            ;930
0006e2  466b              MOV      r3,sp                 ;930
0006e4  2202              MOVS     r2,#2                 ;930
0006e6  f7fffffe          BL       i2cWrite
0006ea  b110              CBZ      r0,|L1.1778|
0006ec  f04f30ff          MOV      r0,#0xffffffff        ;931
0006f0  e7a4              B        |L1.1596|
                  |L1.1778|
0006f2  2108              MOVS     r1,#8                 ;960
0006f4  4839              LDR      r0,|L1.2012|
0006f6  7281              STRB     r1,[r0,#0xa]          ;960
0006f8  2100              MOVS     r1,#0                 ;961
0006fa  7301              STRB     r1,[r0,#0xc]          ;961
0006fc  2101              MOVS     r1,#1                 ;962
0006fe  7501              STRB     r1,[r0,#0x14]         ;962
000700  2000              MOVS     r0,#0                 ;963
000702  f7fffffe          BL       mpu_configure_fifo
000706  2000              MOVS     r0,#0                 ;965
000708  e798              B        |L1.1596|
;;;967    
                          ENDP

                  mpu_set_sample_rate PROC
;;;1368    */
;;;1369   int mpu_set_sample_rate(unsigned short rate)
00070a  b538              PUSH     {r3-r5,lr}
;;;1370   {
00070c  4604              MOV      r4,r0
;;;1371       unsigned char data;
;;;1372   
;;;1373       if (!(st.chip_cfg.sensors))
00070e  4833              LDR      r0,|L1.2012|
000710  7a80              LDRB     r0,[r0,#0xa]
000712  b910              CBNZ     r0,|L1.1818|
;;;1374           return -1;
000714  f04f30ff          MOV      r0,#0xffffffff
                  |L1.1816|
;;;1375   
;;;1376       if (st.chip_cfg.dmp_on)
;;;1377           return -1;
;;;1378       else {
;;;1379           if (st.chip_cfg.lp_accel_mode) {
;;;1380               if (rate && (rate <= 40)) {
;;;1381                   /* Just stay in low-power accel mode. */
;;;1382                   mpu_lp_accel_mode(rate);
;;;1383                   return 0;
;;;1384               }
;;;1385               /* Requested rate exceeds the allowed frequencies in LP accel mode,
;;;1386                * switch back to full-power mode.
;;;1387                */
;;;1388               mpu_lp_accel_mode(0);
;;;1389           }
;;;1390           if (rate < 4)
;;;1391               rate = 4;
;;;1392           else if (rate > 1000)
;;;1393               rate = 1000;
;;;1394   
;;;1395           data = 1000 / rate - 1;
;;;1396           if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
;;;1397               return -1;
;;;1398   
;;;1399           st.chip_cfg.sample_rate = 1000 / (1 + data);
;;;1400   
;;;1401   #ifdef AK89xx_SECONDARY
;;;1402           mpu_set_compass_sample_rate(min(st.chip_cfg.compass_sample_rate, MAX_COMPASS_SAMPLE_RATE));
;;;1403   #endif
;;;1404   
;;;1405           /* Automatically set LPF to 1/2 sampling rate. */
;;;1406           mpu_set_lpf(st.chip_cfg.sample_rate >> 1);
;;;1407           return 0;
;;;1408       }
;;;1409   }
000718  bd38              POP      {r3-r5,pc}
                  |L1.1818|
00071a  4830              LDR      r0,|L1.2012|
00071c  f8900024          LDRB     r0,[r0,#0x24]         ;1376
000720  b110              CBZ      r0,|L1.1832|
000722  f04f30ff          MOV      r0,#0xffffffff        ;1377
000726  e7f7              B        |L1.1816|
                  |L1.1832|
000728  482c              LDR      r0,|L1.2012|
00072a  7d00              LDRB     r0,[r0,#0x14]         ;1379
00072c  b150              CBZ      r0,|L1.1860|
00072e  b134              CBZ      r4,|L1.1854|
000730  2c28              CMP      r4,#0x28              ;1380
000732  dc04              BGT      |L1.1854|
000734  b2e0              UXTB     r0,r4                 ;1382
000736  f7fffffe          BL       mpu_lp_accel_mode
00073a  2000              MOVS     r0,#0                 ;1383
00073c  e7ec              B        |L1.1816|
                  |L1.1854|
00073e  2000              MOVS     r0,#0                 ;1388
000740  f7fffffe          BL       mpu_lp_accel_mode
                  |L1.1860|
000744  2c04              CMP      r4,#4                 ;1390
000746  da01              BGE      |L1.1868|
000748  2404              MOVS     r4,#4                 ;1391
00074a  e004              B        |L1.1878|
                  |L1.1868|
00074c  f5b47f7a          CMP      r4,#0x3e8             ;1392
000750  dd01              BLE      |L1.1878|
000752  f44f747a          MOV      r4,#0x3e8             ;1393
                  |L1.1878|
000756  f44f707a          MOV      r0,#0x3e8             ;1395
00075a  fb90f0f4          SDIV     r0,r0,r4              ;1395
00075e  1e40              SUBS     r0,r0,#1              ;1395
000760  b2c0              UXTB     r0,r0                 ;1395
000762  9000              STR      r0,[sp,#0]            ;1395
000764  4a1d              LDR      r2,|L1.2012|
000766  6812              LDR      r2,[r2,#0]            ;1396  ; st
000768  7851              LDRB     r1,[r2,#1]            ;1396
00076a  4a1c              LDR      r2,|L1.2012|
00076c  6852              LDR      r2,[r2,#4]            ;1396  ; st
00076e  7810              LDRB     r0,[r2,#0]            ;1396
000770  466b              MOV      r3,sp                 ;1396
000772  2201              MOVS     r2,#1                 ;1396
000774  f7fffffe          BL       i2cWrite
000778  b110              CBZ      r0,|L1.1920|
00077a  f04f30ff          MOV      r0,#0xffffffff        ;1397
00077e  e7cb              B        |L1.1816|
                  |L1.1920|
000780  f89d0000          LDRB     r0,[sp,#0]            ;1399
000784  1c40              ADDS     r0,r0,#1              ;1399
000786  f44f717a          MOV      r1,#0x3e8             ;1399
00078a  fb91f0f0          SDIV     r0,r1,r0              ;1399
00078e  b281              UXTH     r1,r0                 ;1399
000790  4812              LDR      r0,|L1.2012|
000792  81c1              STRH     r1,[r0,#0xe]          ;1399
000794  4601              MOV      r1,r0                 ;1406
000796  89c9              LDRH     r1,[r1,#0xe]          ;1406
000798  1048              ASRS     r0,r1,#1              ;1406
00079a  f7fffffe          BL       mpu_set_lpf
00079e  2000              MOVS     r0,#0                 ;1407
0007a0  e7ba              B        |L1.1816|
;;;1410   
                          ENDP

                  mpu_set_accel_fsr PROC
;;;1247    */
;;;1248   int mpu_set_accel_fsr(unsigned char fsr)
0007a2  b538              PUSH     {r3-r5,lr}
;;;1249   {
0007a4  4604              MOV      r4,r0
;;;1250       unsigned char data;
;;;1251   
;;;1252       if (!(st.chip_cfg.sensors))
0007a6  480d              LDR      r0,|L1.2012|
0007a8  7a80              LDRB     r0,[r0,#0xa]
0007aa  b910              CBNZ     r0,|L1.1970|
;;;1253           return -1;
0007ac  f04f30ff          MOV      r0,#0xffffffff
                  |L1.1968|
;;;1254   
;;;1255       switch (fsr) {
;;;1256       case 2:
;;;1257           data = INV_FSR_2G << 3;
;;;1258           break;
;;;1259       case 4:
;;;1260           data = INV_FSR_4G << 3;
;;;1261           break;
;;;1262       case 8:
;;;1263           data = INV_FSR_8G << 3;
;;;1264           break;
;;;1265       case 16:
;;;1266           data = INV_FSR_16G << 3;
;;;1267           break;
;;;1268       default:
;;;1269           return -1;
;;;1270       }
;;;1271   
;;;1272       if (st.chip_cfg.accel_fsr == (data >> 3))
;;;1273           return 0;
;;;1274       if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))
;;;1275           return -1;
;;;1276       st.chip_cfg.accel_fsr = data >> 3;
;;;1277       return 0;
;;;1278   }
0007b0  bd38              POP      {r3-r5,pc}
                  |L1.1970|
0007b2  2c02              CMP      r4,#2                 ;1255
0007b4  d006              BEQ      |L1.1988|
0007b6  2c04              CMP      r4,#4                 ;1255
0007b8  d007              BEQ      |L1.1994|
0007ba  2c08              CMP      r4,#8                 ;1255
0007bc  d008              BEQ      |L1.2000|
0007be  2c10              CMP      r4,#0x10              ;1255
0007c0  d10e              BNE      |L1.2016|
0007c2  e008              B        |L1.2006|
                  |L1.1988|
0007c4  2000              MOVS     r0,#0                 ;1257
0007c6  9000              STR      r0,[sp,#0]            ;1257
0007c8  e00d              B        |L1.2022|
                  |L1.1994|
0007ca  2008              MOVS     r0,#8                 ;1260
0007cc  9000              STR      r0,[sp,#0]            ;1260
0007ce  e00a              B        |L1.2022|
                  |L1.2000|
0007d0  2010              MOVS     r0,#0x10              ;1263
0007d2  9000              STR      r0,[sp,#0]            ;1263
0007d4  e007              B        |L1.2022|
                  |L1.2006|
0007d6  2018              MOVS     r0,#0x18              ;1266
0007d8  9000              STR      r0,[sp,#0]            ;1266
0007da  e004              B        |L1.2022|
                  |L1.2012|
                          DCD      ||st||
                  |L1.2016|
0007e0  f04f30ff          MOV      r0,#0xffffffff        ;1269
0007e4  e7e4              B        |L1.1968|
                  |L1.2022|
0007e6  bf00              NOP                            ;1258
0007e8  48fa              LDR      r0,|L1.3028|
0007ea  7a40              LDRB     r0,[r0,#9]            ;1272
0007ec  f89d1000          LDRB     r1,[sp,#0]            ;1272
0007f0  ebb00fe1          CMP      r0,r1,ASR #3          ;1272
0007f4  d101              BNE      |L1.2042|
0007f6  2000              MOVS     r0,#0                 ;1273
0007f8  e7da              B        |L1.1968|
                  |L1.2042|
0007fa  4af6              LDR      r2,|L1.3028|
0007fc  6812              LDR      r2,[r2,#0]            ;1274  ; st
0007fe  79d1              LDRB     r1,[r2,#7]            ;1274
000800  4af4              LDR      r2,|L1.3028|
000802  6852              LDR      r2,[r2,#4]            ;1274  ; st
000804  7810              LDRB     r0,[r2,#0]            ;1274
000806  466b              MOV      r3,sp                 ;1274
000808  2201              MOVS     r2,#1                 ;1274
00080a  f7fffffe          BL       i2cWrite
00080e  b110              CBZ      r0,|L1.2070|
000810  f04f30ff          MOV      r0,#0xffffffff        ;1275
000814  e7cc              B        |L1.1968|
                  |L1.2070|
000816  f89d0000          LDRB     r0,[sp,#0]            ;1276
00081a  10c0              ASRS     r0,r0,#3              ;1276
00081c  49ed              LDR      r1,|L1.3028|
00081e  7248              STRB     r0,[r1,#9]            ;1276
000820  2000              MOVS     r0,#0                 ;1277
000822  e7c5              B        |L1.1968|
;;;1279   
                          ENDP

                  mpu_set_gyro_fsr PROC
;;;1182    */
;;;1183   int mpu_set_gyro_fsr(unsigned short fsr)
000824  b538              PUSH     {r3-r5,lr}
;;;1184   {
000826  4604              MOV      r4,r0
;;;1185       unsigned char data;
;;;1186   
;;;1187       if (!(st.chip_cfg.sensors))
000828  48ea              LDR      r0,|L1.3028|
00082a  7a80              LDRB     r0,[r0,#0xa]
00082c  b910              CBNZ     r0,|L1.2100|
;;;1188           return -1;
00082e  f04f30ff          MOV      r0,#0xffffffff
                  |L1.2098|
;;;1189   
;;;1190       switch (fsr) {
;;;1191       case 250:
;;;1192           data = INV_FSR_250DPS << 3;
;;;1193           break;
;;;1194       case 500:
;;;1195           data = INV_FSR_500DPS << 3;
;;;1196           break;
;;;1197       case 1000:
;;;1198           data = INV_FSR_1000DPS << 3;
;;;1199           break;
;;;1200       case 2000:
;;;1201           data = INV_FSR_2000DPS << 3;
;;;1202           break;
;;;1203       default:
;;;1204           return -1;
;;;1205       }
;;;1206   
;;;1207       if (st.chip_cfg.gyro_fsr == (data >> 3))
;;;1208           return 0;
;;;1209       if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
;;;1210           return -1;
;;;1211       st.chip_cfg.gyro_fsr = data >> 3;
;;;1212       return 0;
;;;1213   }
000832  bd38              POP      {r3-r5,pc}
                  |L1.2100|
000834  2cfa              CMP      r4,#0xfa              ;1190
000836  d009              BEQ      |L1.2124|
000838  f5b47ffa          CMP      r4,#0x1f4             ;1190
00083c  d009              BEQ      |L1.2130|
00083e  f5b47f7a          CMP      r4,#0x3e8             ;1190
000842  d009              BEQ      |L1.2136|
000844  f5b46ffa          CMP      r4,#0x7d0             ;1190
000848  d10c              BNE      |L1.2148|
00084a  e008              B        |L1.2142|
                  |L1.2124|
00084c  2000              MOVS     r0,#0                 ;1192
00084e  9000              STR      r0,[sp,#0]            ;1192
000850  e00b              B        |L1.2154|
                  |L1.2130|
000852  2008              MOVS     r0,#8                 ;1195
000854  9000              STR      r0,[sp,#0]            ;1195
000856  e008              B        |L1.2154|
                  |L1.2136|
000858  2010              MOVS     r0,#0x10              ;1198
00085a  9000              STR      r0,[sp,#0]            ;1198
00085c  e005              B        |L1.2154|
                  |L1.2142|
00085e  2018              MOVS     r0,#0x18              ;1201
000860  9000              STR      r0,[sp,#0]            ;1201
000862  e002              B        |L1.2154|
                  |L1.2148|
000864  f04f30ff          MOV      r0,#0xffffffff        ;1204
000868  e7e3              B        |L1.2098|
                  |L1.2154|
00086a  bf00              NOP                            ;1193
00086c  48d9              LDR      r0,|L1.3028|
00086e  7a00              LDRB     r0,[r0,#8]            ;1207  ; st
000870  f89d1000          LDRB     r1,[sp,#0]            ;1207
000874  ebb00fe1          CMP      r0,r1,ASR #3          ;1207
000878  d101              BNE      |L1.2174|
00087a  2000              MOVS     r0,#0                 ;1208
00087c  e7d9              B        |L1.2098|
                  |L1.2174|
00087e  4ad5              LDR      r2,|L1.3028|
000880  6812              LDR      r2,[r2,#0]            ;1209  ; st
000882  7991              LDRB     r1,[r2,#6]            ;1209
000884  4ad3              LDR      r2,|L1.3028|
000886  6852              LDR      r2,[r2,#4]            ;1209  ; st
000888  7810              LDRB     r0,[r2,#0]            ;1209
00088a  466b              MOV      r3,sp                 ;1209
00088c  2201              MOVS     r2,#1                 ;1209
00088e  f7fffffe          BL       i2cWrite
000892  b110              CBZ      r0,|L1.2202|
000894  f04f30ff          MOV      r0,#0xffffffff        ;1210
000898  e7cb              B        |L1.2098|
                  |L1.2202|
00089a  f89d0000          LDRB     r0,[sp,#0]            ;1211
00089e  10c0              ASRS     r0,r0,#3              ;1211
0008a0  49cc              LDR      r1,|L1.3028|
0008a2  7208              STRB     r0,[r1,#8]            ;1211
0008a4  2000              MOVS     r0,#0                 ;1212
0008a6  e7c4              B        |L1.2098|
;;;1214   
                          ENDP

                  mpu_init PROC
;;;759     */
;;;760    int mpu_init(void)
0008a8  b51c              PUSH     {r2-r4,lr}
;;;761    {
;;;762        unsigned char data[6], rev;
;;;763    
;;;764        /* Reset device. */
;;;765        data[0] = 0x80;//BIT_RESET;
0008aa  2080              MOVS     r0,#0x80
0008ac  f88d0000          STRB     r0,[sp,#0]
;;;766        if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &(data[0])))
0008b0  4ac8              LDR      r2,|L1.3028|
0008b2  6812              LDR      r2,[r2,#0]  ; st
0008b4  7c91              LDRB     r1,[r2,#0x12]
0008b6  4ac7              LDR      r2,|L1.3028|
0008b8  6852              LDR      r2,[r2,#4]  ; st
0008ba  7810              LDRB     r0,[r2,#0]
0008bc  466b              MOV      r3,sp
0008be  2201              MOVS     r2,#1
0008c0  f7fffffe          BL       i2cWrite
0008c4  b110              CBZ      r0,|L1.2252|
;;;767            return -1;
0008c6  f04f30ff          MOV      r0,#0xffffffff
                  |L1.2250|
;;;768        delay_ms(100);
;;;769    
;;;770        /* Wake up chip. */
;;;771        data[0] = 0x00;
;;;772        if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &(data[0])))
;;;773            return -1;
;;;774    
;;;775    #if defined MPU6050
;;;776        /* Check product revision. */
;;;777        if (i2c_read(st.hw->addr, st.reg->accel_offs, 6, data))
;;;778            return -1;
;;;779        rev = ((data[5] & 0x01) << 2) | ((data[3] & 0x01) << 1) |
;;;780            (data[1] & 0x01);
;;;781    
;;;782        if (rev) {
;;;783            /* Congrats, these parts are better. */
;;;784            if (rev == 1)
;;;785                st.chip_cfg.accel_half = 1;
;;;786            else if (rev == 2)
;;;787                st.chip_cfg.accel_half = 0;
;;;788            else {
;;;789                log_e("Unsupported software product rev %d.\n",rev);
;;;790                return -1;
;;;791            }
;;;792        } else {
;;;793            if (i2c_read(st.hw->addr, st.reg->prod_id, 1, &(data[0])))
;;;794                return -1;
;;;795            rev = data[0] & 0x0F;
;;;796            if (!rev) {
;;;797                log_e("Product ID read as 0 indicates device is either incompatible or an MPU3050.\r\n");
;;;798                return -1;
;;;799            } else if (rev == 4) {
;;;800                log_i("Half sensitivity part found.\r\n");
;;;801                st.chip_cfg.accel_half = 1;
;;;802            } else
;;;803                st.chip_cfg.accel_half = 0;
;;;804        }
;;;805    #elif defined MPU6500
;;;806    #define MPU6500_MEM_REV_ADDR    (0x17)
;;;807        if (mpu_read_mem(MPU6500_MEM_REV_ADDR, 1, &rev))
;;;808            return -1;
;;;809        if (rev == 0x1)
;;;810            st.chip_cfg.accel_half = 0;
;;;811        else {
;;;812            log_e("Unsupported software product rev %d.\r\n", rev);
;;;813            return -1;
;;;814        }
;;;815    
;;;816        /* MPU6500 shares 4kB of memory between the DMP and the FIFO. Since the
;;;817         * first 3kB are needed by the DMP, we'll use the last 1kB for the FIFO.
;;;818         */
;;;819        data[0] = BIT_FIFO_SIZE_1024 | 0x8;
;;;820        if (i2c_write(st.hw->addr, st.reg->accel_cfg2, 1, data))
;;;821            return -1;
;;;822    #endif
;;;823    
;;;824        /* Set to invalid values to ensure no I2C writes are skipped. */
;;;825        st.chip_cfg.sensors = 0xFF;
;;;826        st.chip_cfg.gyro_fsr = 0xFF;
;;;827        st.chip_cfg.accel_fsr = 0xFF;
;;;828        st.chip_cfg.lpf = 0xFF;
;;;829        st.chip_cfg.sample_rate = 0xFFFF;
;;;830        st.chip_cfg.fifo_enable = 0xFF;
;;;831        st.chip_cfg.bypass_mode = 0xFF;
;;;832    #ifdef AK89xx_SECONDARY
;;;833        st.chip_cfg.compass_sample_rate = 0xFFFF;
;;;834    #endif
;;;835        /* mpu_set_sensors always preserves this setting. */
;;;836        st.chip_cfg.clk_src = INV_CLK_PLL;
;;;837        /* Handled in next call to mpu_set_bypass. */
;;;838        st.chip_cfg.active_low_int = 1;
;;;839        st.chip_cfg.latched_int = 0;
;;;840        st.chip_cfg.int_motion_only = 0;
;;;841        st.chip_cfg.lp_accel_mode = 0;
;;;842        memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
;;;843        st.chip_cfg.dmp_on = 0;
;;;844        st.chip_cfg.dmp_loaded = 0;
;;;845        st.chip_cfg.dmp_sample_rate = 0;
;;;846    
;;;847        if (mpu_set_gyro_fsr(2000))
;;;848            return -1;
;;;849        if (mpu_set_accel_fsr(2))
;;;850            return -1;
;;;851        if (mpu_set_lpf(42))
;;;852            return -1;
;;;853        if (mpu_set_sample_rate(50))
;;;854            return -1;
;;;855        if (mpu_configure_fifo(0))
;;;856            return -1;
;;;857    
;;;858        /*if (int_param)
;;;859            reg_int_cb(int_param);*/
;;;860    
;;;861    #ifdef AK89xx_SECONDARY
;;;862        setup_compass();
;;;863        if (mpu_set_compass_sample_rate(10))
;;;864            return -1;
;;;865    #else
;;;866        /* Already disabled by setup_compass. */
;;;867        if (mpu_set_bypass(0))
;;;868            return -1;
;;;869    #endif
;;;870    
;;;871        mpu_set_sensors(0);
;;;872        return 0;
;;;873    }
0008ca  bd1c              POP      {r2-r4,pc}
                  |L1.2252|
0008cc  2064              MOVS     r0,#0x64              ;768
0008ce  f7fffffe          BL       delay_ms
0008d2  2000              MOVS     r0,#0                 ;771
0008d4  f88d0000          STRB     r0,[sp,#0]            ;771
0008d8  4abe              LDR      r2,|L1.3028|
0008da  6812              LDR      r2,[r2,#0]            ;772  ; st
0008dc  7c91              LDRB     r1,[r2,#0x12]         ;772
0008de  4abd              LDR      r2,|L1.3028|
0008e0  6852              LDR      r2,[r2,#4]            ;772  ; st
0008e2  7810              LDRB     r0,[r2,#0]            ;772
0008e4  466b              MOV      r3,sp                 ;772
0008e6  2201              MOVS     r2,#1                 ;772
0008e8  f7fffffe          BL       i2cWrite
0008ec  b110              CBZ      r0,|L1.2292|
0008ee  f04f30ff          MOV      r0,#0xffffffff        ;773
0008f2  e7ea              B        |L1.2250|
                  |L1.2292|
0008f4  4ab7              LDR      r2,|L1.3028|
0008f6  6812              LDR      r2,[r2,#0]            ;777  ; st
0008f8  7d91              LDRB     r1,[r2,#0x16]         ;777
0008fa  4ab6              LDR      r2,|L1.3028|
0008fc  6852              LDR      r2,[r2,#4]            ;777  ; st
0008fe  7810              LDRB     r0,[r2,#0]            ;777
000900  466b              MOV      r3,sp                 ;777
000902  2206              MOVS     r2,#6                 ;777
000904  f7fffffe          BL       i2cRead
000908  b110              CBZ      r0,|L1.2320|
00090a  f04f30ff          MOV      r0,#0xffffffff        ;778
00090e  e7dc              B        |L1.2250|
                  |L1.2320|
000910  f89d0005          LDRB     r0,[sp,#5]            ;779
000914  07c0              LSLS     r0,r0,#31             ;779
000916  0f40              LSRS     r0,r0,#29             ;779
000918  f89d1003          LDRB     r1,[sp,#3]            ;779
00091c  f0010101          AND      r1,r1,#1              ;779
000920  ea400041          ORR      r0,r0,r1,LSL #1       ;779
000924  f89d1001          LDRB     r1,[sp,#1]            ;779
000928  f0010101          AND      r1,r1,#1              ;779
00092c  ea400401          ORR      r4,r0,r1              ;779
000930  b194              CBZ      r4,|L1.2392|
000932  2c01              CMP      r4,#1                 ;784
000934  d103              BNE      |L1.2366|
000936  2101              MOVS     r1,#1                 ;785
000938  48a6              LDR      r0,|L1.3028|
00093a  74c1              STRB     r1,[r0,#0x13]         ;785
00093c  e031              B        |L1.2466|
                  |L1.2366|
00093e  2c02              CMP      r4,#2                 ;786
000940  d103              BNE      |L1.2378|
000942  2100              MOVS     r1,#0                 ;787
000944  48a3              LDR      r0,|L1.3028|
000946  74c1              STRB     r1,[r0,#0x13]         ;787
000948  e02b              B        |L1.2466|
                  |L1.2378|
00094a  4621              MOV      r1,r4                 ;789
00094c  a0a2              ADR      r0,|L1.3032|
00094e  f7fffffe          BL       __2printf
000952  f04f30ff          MOV      r0,#0xffffffff        ;790
000956  e7b8              B        |L1.2250|
                  |L1.2392|
000958  4a9e              LDR      r2,|L1.3028|
00095a  6812              LDR      r2,[r2,#0]            ;793  ; st
00095c  78d1              LDRB     r1,[r2,#3]            ;793
00095e  4a9d              LDR      r2,|L1.3028|
000960  6852              LDR      r2,[r2,#4]            ;793  ; st
000962  7810              LDRB     r0,[r2,#0]            ;793
000964  466b              MOV      r3,sp                 ;793
000966  2201              MOVS     r2,#1                 ;793
000968  f7fffffe          BL       i2cRead
00096c  b110              CBZ      r0,|L1.2420|
00096e  f04f30ff          MOV      r0,#0xffffffff        ;794
000972  e7aa              B        |L1.2250|
                  |L1.2420|
000974  f89d0000          LDRB     r0,[sp,#0]            ;795
000978  f000040f          AND      r4,r0,#0xf            ;795
00097c  b92c              CBNZ     r4,|L1.2442|
00097e  48a0              LDR      r0,|L1.3072|
000980  f7fffffe          BL       __2printf
000984  f04f30ff          MOV      r0,#0xffffffff        ;798
000988  e79f              B        |L1.2250|
                  |L1.2442|
00098a  2c04              CMP      r4,#4                 ;799
00098c  d106              BNE      |L1.2460|
00098e  a09d              ADR      r0,|L1.3076|
000990  f7fffffe          BL       __2printf
000994  2101              MOVS     r1,#1                 ;801
000996  488f              LDR      r0,|L1.3028|
000998  74c1              STRB     r1,[r0,#0x13]         ;801
00099a  e002              B        |L1.2466|
                  |L1.2460|
00099c  2100              MOVS     r1,#0                 ;803
00099e  488d              LDR      r0,|L1.3028|
0009a0  74c1              STRB     r1,[r0,#0x13]         ;803
                  |L1.2466|
0009a2  21ff              MOVS     r1,#0xff              ;825
0009a4  488b              LDR      r0,|L1.3028|
0009a6  7281              STRB     r1,[r0,#0xa]          ;825
0009a8  20ff              MOVS     r0,#0xff              ;826
0009aa  498a              LDR      r1,|L1.3028|
0009ac  7208              STRB     r0,[r1,#8]            ;826
0009ae  21ff              MOVS     r1,#0xff              ;827
0009b0  4888              LDR      r0,|L1.3028|
0009b2  7241              STRB     r1,[r0,#9]            ;827
0009b4  72c1              STRB     r1,[r0,#0xb]          ;828
0009b6  f64f71ff          MOV      r1,#0xffff            ;829
0009ba  81c1              STRH     r1,[r0,#0xe]          ;829
0009bc  21ff              MOVS     r1,#0xff              ;830
0009be  7401              STRB     r1,[r0,#0x10]         ;830
0009c0  7481              STRB     r1,[r0,#0x12]         ;831
0009c2  2101              MOVS     r1,#1                 ;836
0009c4  7301              STRB     r1,[r0,#0xc]          ;836
0009c6  f8801022          STRB     r1,[r0,#0x22]         ;838
0009ca  2100              MOVS     r1,#0                 ;839
0009cc  f8801023          STRB     r1,[r0,#0x23]         ;839
0009d0  7541              STRB     r1,[r0,#0x15]         ;840
0009d2  7501              STRB     r1,[r0,#0x14]         ;841
0009d4  3008              ADDS     r0,r0,#8              ;842
0009d6  f8c0100e          STR      r1,[r0,#0xe]          ;842
0009da  f8c01012          STR      r1,[r0,#0x12]         ;842
0009de  f8c01016          STR      r1,[r0,#0x16]         ;842
0009e2  3808              SUBS     r0,r0,#8              ;843
0009e4  f8801024          STRB     r1,[r0,#0x24]         ;843
0009e8  f8801025          STRB     r1,[r0,#0x25]         ;844
0009ec  84c1              STRH     r1,[r0,#0x26]         ;845
0009ee  f44f60fa          MOV      r0,#0x7d0             ;847
0009f2  f7fffffe          BL       mpu_set_gyro_fsr
0009f6  b110              CBZ      r0,|L1.2558|
0009f8  f04f30ff          MOV      r0,#0xffffffff        ;848
0009fc  e765              B        |L1.2250|
                  |L1.2558|
0009fe  2002              MOVS     r0,#2                 ;849
000a00  f7fffffe          BL       mpu_set_accel_fsr
000a04  b110              CBZ      r0,|L1.2572|
000a06  f04f30ff          MOV      r0,#0xffffffff        ;850
000a0a  e75e              B        |L1.2250|
                  |L1.2572|
000a0c  202a              MOVS     r0,#0x2a              ;851
000a0e  f7fffffe          BL       mpu_set_lpf
000a12  b110              CBZ      r0,|L1.2586|
000a14  f04f30ff          MOV      r0,#0xffffffff        ;852
000a18  e757              B        |L1.2250|
                  |L1.2586|
000a1a  2032              MOVS     r0,#0x32              ;853
000a1c  f7fffffe          BL       mpu_set_sample_rate
000a20  b110              CBZ      r0,|L1.2600|
000a22  f04f30ff          MOV      r0,#0xffffffff        ;854
000a26  e750              B        |L1.2250|
                  |L1.2600|
000a28  2000              MOVS     r0,#0                 ;855
000a2a  f7fffffe          BL       mpu_configure_fifo
000a2e  b110              CBZ      r0,|L1.2614|
000a30  f04f30ff          MOV      r0,#0xffffffff        ;856
000a34  e749              B        |L1.2250|
                  |L1.2614|
000a36  2000              MOVS     r0,#0                 ;867
000a38  f7fffffe          BL       mpu_set_bypass
000a3c  b110              CBZ      r0,|L1.2628|
000a3e  f04f30ff          MOV      r0,#0xffffffff        ;868
000a42  e742              B        |L1.2250|
                  |L1.2628|
000a44  2000              MOVS     r0,#0                 ;871
000a46  f7fffffe          BL       mpu_set_sensors
000a4a  2000              MOVS     r0,#0                 ;872
000a4c  e73d              B        |L1.2250|
;;;874    
                          ENDP

                  myget_ms PROC
;;;2850   }
;;;2851   void myget_ms(unsigned long *time)
000a4e  4770              BX       lr
;;;2852   {
;;;2853   
;;;2854   }
;;;2855   /**
                          ENDP

                  mpu_get_gyro_reg PROC
;;;973     */
;;;974    int mpu_get_gyro_reg(short *data, unsigned long *timestamp)
000a50  b57c              PUSH     {r2-r6,lr}
;;;975    {
000a52  4604              MOV      r4,r0
000a54  460d              MOV      r5,r1
;;;976        unsigned char tmp[6];
;;;977    
;;;978        if (!(st.chip_cfg.sensors & INV_XYZ_GYRO))
000a56  485f              LDR      r0,|L1.3028|
000a58  7a80              LDRB     r0,[r0,#0xa]
000a5a  f0100f70          TST      r0,#0x70
000a5e  d102              BNE      |L1.2662|
;;;979            return -1;
000a60  f04f30ff          MOV      r0,#0xffffffff
                  |L1.2660|
;;;980    
;;;981        if (i2c_read(st.hw->addr, st.reg->raw_gyro, 6, tmp))
;;;982            return -1;
;;;983        data[0] = (tmp[0] << 8) | tmp[1];
;;;984        data[1] = (tmp[2] << 8) | tmp[3];
;;;985        data[2] = (tmp[4] << 8) | tmp[5];
;;;986        if (timestamp)
;;;987            get_ms(timestamp);
;;;988        return 0;
;;;989    }
000a64  bd7c              POP      {r2-r6,pc}
                  |L1.2662|
000a66  4a5b              LDR      r2,|L1.3028|
000a68  6812              LDR      r2,[r2,#0]            ;981  ; st
000a6a  7b11              LDRB     r1,[r2,#0xc]          ;981
000a6c  4a59              LDR      r2,|L1.3028|
000a6e  6852              LDR      r2,[r2,#4]            ;981  ; st
000a70  7810              LDRB     r0,[r2,#0]            ;981
000a72  466b              MOV      r3,sp                 ;981
000a74  2206              MOVS     r2,#6                 ;981
000a76  f7fffffe          BL       i2cRead
000a7a  b110              CBZ      r0,|L1.2690|
000a7c  f04f30ff          MOV      r0,#0xffffffff        ;982
000a80  e7f0              B        |L1.2660|
                  |L1.2690|
000a82  f89d0001          LDRB     r0,[sp,#1]            ;983
000a86  f89d1000          LDRB     r1,[sp,#0]            ;983
000a8a  ea402001          ORR      r0,r0,r1,LSL #8       ;983
000a8e  b200              SXTH     r0,r0                 ;983
000a90  8020              STRH     r0,[r4,#0]            ;983
000a92  f89d0003          LDRB     r0,[sp,#3]            ;984
000a96  f89d1002          LDRB     r1,[sp,#2]            ;984
000a9a  ea402001          ORR      r0,r0,r1,LSL #8       ;984
000a9e  b200              SXTH     r0,r0                 ;984
000aa0  8060              STRH     r0,[r4,#2]            ;984
000aa2  f89d0005          LDRB     r0,[sp,#5]            ;985
000aa6  f89d1004          LDRB     r1,[sp,#4]            ;985
000aaa  ea402001          ORR      r0,r0,r1,LSL #8       ;985
000aae  b200              SXTH     r0,r0                 ;985
000ab0  80a0              STRH     r0,[r4,#4]            ;985
000ab2  b115              CBZ      r5,|L1.2746|
000ab4  4628              MOV      r0,r5                 ;987
000ab6  f7fffffe          BL       myget_ms
                  |L1.2746|
000aba  2000              MOVS     r0,#0                 ;988
000abc  e7d2              B        |L1.2660|
;;;990    
                          ENDP

                  mpu_get_accel_reg PROC
;;;996     */
;;;997    int mpu_get_accel_reg(short *data, unsigned long *timestamp)
000abe  b57c              PUSH     {r2-r6,lr}
;;;998    {
000ac0  4604              MOV      r4,r0
000ac2  460d              MOV      r5,r1
;;;999        unsigned char tmp[6];
;;;1000   
;;;1001       if (!(st.chip_cfg.sensors & INV_XYZ_ACCEL))
000ac4  4843              LDR      r0,|L1.3028|
000ac6  7a80              LDRB     r0,[r0,#0xa]
000ac8  f0100f08          TST      r0,#8
000acc  d102              BNE      |L1.2772|
;;;1002           return -1;
000ace  f04f30ff          MOV      r0,#0xffffffff
                  |L1.2770|
;;;1003   
;;;1004       if (i2c_read(st.hw->addr, st.reg->raw_accel, 6, tmp))
;;;1005           return -1;
;;;1006       data[0] = (tmp[0] << 8) | tmp[1];
;;;1007       data[1] = (tmp[2] << 8) | tmp[3];
;;;1008       data[2] = (tmp[4] << 8) | tmp[5];
;;;1009       if (timestamp)
;;;1010           get_ms(timestamp);
;;;1011       return 0;
;;;1012   }
000ad2  bd7c              POP      {r2-r6,pc}
                  |L1.2772|
000ad4  4a3f              LDR      r2,|L1.3028|
000ad6  6812              LDR      r2,[r2,#0]            ;1004  ; st
000ad8  7b51              LDRB     r1,[r2,#0xd]          ;1004
000ada  4a3e              LDR      r2,|L1.3028|
000adc  6852              LDR      r2,[r2,#4]            ;1004  ; st
000ade  7810              LDRB     r0,[r2,#0]            ;1004
000ae0  466b              MOV      r3,sp                 ;1004
000ae2  2206              MOVS     r2,#6                 ;1004
000ae4  f7fffffe          BL       i2cRead
000ae8  b110              CBZ      r0,|L1.2800|
000aea  f04f30ff          MOV      r0,#0xffffffff        ;1005
000aee  e7f0              B        |L1.2770|
                  |L1.2800|
000af0  f89d0001          LDRB     r0,[sp,#1]            ;1006
000af4  f89d1000          LDRB     r1,[sp,#0]            ;1006
000af8  ea402001          ORR      r0,r0,r1,LSL #8       ;1006
000afc  b200              SXTH     r0,r0                 ;1006
000afe  8020              STRH     r0,[r4,#0]            ;1006
000b00  f89d0003          LDRB     r0,[sp,#3]            ;1007
000b04  f89d1002          LDRB     r1,[sp,#2]            ;1007
000b08  ea402001          ORR      r0,r0,r1,LSL #8       ;1007
000b0c  b200              SXTH     r0,r0                 ;1007
000b0e  8060              STRH     r0,[r4,#2]            ;1007
000b10  f89d0005          LDRB     r0,[sp,#5]            ;1008
000b14  f89d1004          LDRB     r1,[sp,#4]            ;1008
000b18  ea402001          ORR      r0,r0,r1,LSL #8       ;1008
000b1c  b200              SXTH     r0,r0                 ;1008
000b1e  80a0              STRH     r0,[r4,#4]            ;1008
000b20  b115              CBZ      r5,|L1.2856|
000b22  4628              MOV      r0,r5                 ;1010
000b24  f7fffffe          BL       myget_ms
                  |L1.2856|
000b28  2000              MOVS     r0,#0                 ;1011
000b2a  e7d2              B        |L1.2770|
;;;1013   
                          ENDP

                  mpu_get_temperature PROC
;;;1019    */
;;;1020   int mpu_get_temperature(long *data, unsigned long *timestamp)
000b2c  e92d4ffe          PUSH     {r1-r11,lr}
;;;1021   {
000b30  4605              MOV      r5,r0
000b32  460c              MOV      r4,r1
;;;1022       unsigned char tmp[2];
;;;1023       short raw;
;;;1024   
;;;1025       if (!(st.chip_cfg.sensors))
000b34  4827              LDR      r0,|L1.3028|
000b36  7a80              LDRB     r0,[r0,#0xa]
000b38  b918              CBNZ     r0,|L1.2882|
;;;1026           return -1;
000b3a  f04f30ff          MOV      r0,#0xffffffff
                  |L1.2878|
;;;1027   
;;;1028       if (i2c_read(st.hw->addr, st.reg->temp, 2, tmp))
;;;1029           return -1;
;;;1030       raw = (tmp[0] << 8) | tmp[1];
;;;1031       if (timestamp)
;;;1032           get_ms(timestamp);
;;;1033   
;;;1034       data[0] = (long)((35 + ((raw - (float)st.hw->temp_offset) / st.hw->temp_sens)) * 65536L);
;;;1035       return 0;
;;;1036   }
000b3e  e8bd8ffe          POP      {r1-r11,pc}
                  |L1.2882|
000b42  4a24              LDR      r2,|L1.3028|
000b44  6812              LDR      r2,[r2,#0]            ;1028  ; st
000b46  7b91              LDRB     r1,[r2,#0xe]          ;1028
000b48  4a22              LDR      r2,|L1.3028|
000b4a  6852              LDR      r2,[r2,#4]            ;1028  ; st
000b4c  7810              LDRB     r0,[r2,#0]            ;1028
000b4e  ab02              ADD      r3,sp,#8              ;1028
000b50  2202              MOVS     r2,#2                 ;1028
000b52  f7fffffe          BL       i2cRead
000b56  b110              CBZ      r0,|L1.2910|
000b58  f04f30ff          MOV      r0,#0xffffffff        ;1029
000b5c  e7ef              B        |L1.2878|
                  |L1.2910|
000b5e  f89d0009          LDRB     r0,[sp,#9]            ;1030
000b62  f89d1008          LDRB     r1,[sp,#8]            ;1030
000b66  ea402001          ORR      r0,r0,r1,LSL #8       ;1030
000b6a  b206              SXTH     r6,r0                 ;1030
000b6c  b114              CBZ      r4,|L1.2932|
000b6e  4620              MOV      r0,r4                 ;1032
000b70  f7fffffe          BL       myget_ms
                  |L1.2932|
000b74  4917              LDR      r1,|L1.3028|
000b76  6849              LDR      r1,[r1,#4]            ;1034  ; st
000b78  88c8              LDRH     r0,[r1,#6]            ;1034
000b7a  f7fffffe          BL       __aeabi_ui2f
000b7e  4915              LDR      r1,|L1.3028|
000b80  9001              STR      r0,[sp,#4]            ;1034
000b82  6849              LDR      r1,[r1,#4]            ;1034  ; st
000b84  f9b10008          LDRSH    r0,[r1,#8]            ;1034
000b88  f7fffffe          BL       __aeabi_i2f
000b8c  4683              MOV      r11,r0                ;1034
000b8e  4630              MOV      r0,r6                 ;1034
000b90  f7fffffe          BL       __aeabi_i2f
000b94  4659              MOV      r1,r11                ;1034
000b96  9000              STR      r0,[sp,#0]            ;1034
000b98  f7fffffe          BL       __aeabi_fsub
000b9c  4682              MOV      r10,r0                ;1034
000b9e  9901              LDR      r1,[sp,#4]            ;1034
000ba0  f7fffffe          BL       __aeabi_fdiv
000ba4  4681              MOV      r9,r0                 ;1034
000ba6  491f              LDR      r1,|L1.3108|
000ba8  f7fffffe          BL       __aeabi_fadd
000bac  4680              MOV      r8,r0                 ;1034
000bae  f04f418f          MOV      r1,#0x47800000        ;1034
000bb2  f7fffffe          BL       __aeabi_fmul
000bb6  4607              MOV      r7,r0                 ;1034
000bb8  f7fffffe          BL       __aeabi_f2iz
000bbc  6028              STR      r0,[r5,#0]            ;1034
000bbe  2000              MOVS     r0,#0                 ;1035
000bc0  e7bd              B        |L1.2878|
;;;1037   
                          ENDP

                  mpu_set_accel_bias PROC
;;;1044    */
;;;1045   int mpu_set_accel_bias(const long *accel_bias)
000bc2  b510              PUSH     {r4,lr}
;;;1046   {
000bc4  b088              SUB      sp,sp,#0x20
000bc6  4604              MOV      r4,r0
;;;1047       unsigned char data[6];
;;;1048       short accel_hw[3];
;;;1049       short got_accel[3];
;;;1050       short fg[3];
;;;1051   
;;;1052       if (!accel_bias)
000bc8  b91c              CBNZ     r4,|L1.3026|
;;;1053           return -1;
000bca  f04f30ff          MOV      r0,#0xffffffff
;;;1054       if (!accel_bias[0] && !accel_bias[1] && !accel_bias[2])
;;;1055           return 0;
;;;1056   
;;;1057       if (i2c_read(st.hw->addr, 3, 3, data))
;;;1058           return -1;
;;;1059       fg[0] = ((data[0] >> 4) + 8) & 0xf;
;;;1060       fg[1] = ((data[1] >> 4) + 8) & 0xf;
;;;1061       fg[2] = ((data[2] >> 4) + 8) & 0xf;
;;;1062   
;;;1063       accel_hw[0] = (short)(accel_bias[0] * 2 / (64 + fg[0]));
;;;1064       accel_hw[1] = (short)(accel_bias[1] * 2 / (64 + fg[1]));
;;;1065       accel_hw[2] = (short)(accel_bias[2] * 2 / (64 + fg[2]));
;;;1066   
;;;1067       if (i2c_read(st.hw->addr, 0x06, 6, data))
;;;1068           return -1;
;;;1069   
;;;1070       got_accel[0] = ((short)data[0] << 8) | data[1];
;;;1071       got_accel[1] = ((short)data[2] << 8) | data[3];
;;;1072       got_accel[2] = ((short)data[4] << 8) | data[5];
;;;1073   
;;;1074       accel_hw[0] += got_accel[0];
;;;1075       accel_hw[1] += got_accel[1];
;;;1076       accel_hw[2] += got_accel[2];
;;;1077   
;;;1078       data[0] = (accel_hw[0] >> 8) & 0xff;
;;;1079       data[1] = (accel_hw[0]) & 0xff;
;;;1080       data[2] = (accel_hw[1] >> 8) & 0xff;
;;;1081       data[3] = (accel_hw[1]) & 0xff;
;;;1082       data[4] = (accel_hw[2] >> 8) & 0xff;
;;;1083       data[5] = (accel_hw[2]) & 0xff;
;;;1084   
;;;1085       if (i2c_write(st.hw->addr, 0x06, 6, data))
;;;1086           return -1;
;;;1087       return 0;
;;;1088   }
000bce  b008              ADD      sp,sp,#0x20
000bd0  bd10              POP      {r4,pc}
                  |L1.3026|
000bd2  e029              B        |L1.3112|
                  |L1.3028|
                          DCD      ||st||
                  |L1.3032|
000bd8  556e7375          DCB      "Unsupported software product rev %d.\n",0
000bdc  70706f72
000be0  74656420
000be4  736f6674
000be8  77617265
000bec  2070726f
000bf0  64756374
000bf4  20726576
000bf8  2025642e
000bfc  0a00    
000bfe  00                DCB      0
000bff  00                DCB      0
                  |L1.3072|
                          DCD      ||.constdata||+0x50
                  |L1.3076|
000c04  48616c66          DCB      "Half sensitivity part found.\r\n",0
000c08  2073656e
000c0c  73697469
000c10  76697479
000c14  20706172
000c18  7420666f
000c1c  756e642e
000c20  0d0a00  
000c23  00                DCB      0
                  |L1.3108|
                          DCD      0x420c0000
                  |L1.3112|
000c28  6820              LDR      r0,[r4,#0]            ;1054
000c2a  b930              CBNZ     r0,|L1.3130|
000c2c  6860              LDR      r0,[r4,#4]            ;1054
000c2e  b920              CBNZ     r0,|L1.3130|
000c30  68a0              LDR      r0,[r4,#8]            ;1054
000c32  b910              CBNZ     r0,|L1.3130|
000c34  2000              MOVS     r0,#0                 ;1055
                  |L1.3126|
000c36  b008              ADD      sp,sp,#0x20
000c38  bd10              POP      {r4,pc}
                  |L1.3130|
000c3a  49fa              LDR      r1,|L1.4132|
000c3c  6849              LDR      r1,[r1,#4]            ;1057  ; st
000c3e  7808              LDRB     r0,[r1,#0]            ;1057
000c40  ab06              ADD      r3,sp,#0x18           ;1057
000c42  2203              MOVS     r2,#3                 ;1057
000c44  4611              MOV      r1,r2                 ;1057
000c46  f7fffffe          BL       i2cRead
000c4a  b110              CBZ      r0,|L1.3154|
000c4c  f04f30ff          MOV      r0,#0xffffffff        ;1058
000c50  e7f1              B        |L1.3126|
                  |L1.3154|
000c52  f89d0018          LDRB     r0,[sp,#0x18]         ;1059
000c56  2108              MOVS     r1,#8                 ;1059
000c58  eb011020          ADD      r0,r1,r0,ASR #4       ;1059
000c5c  f000000f          AND      r0,r0,#0xf            ;1059
000c60  f8ad0000          STRH     r0,[sp,#0]            ;1059
000c64  f89d0019          LDRB     r0,[sp,#0x19]         ;1060
000c68  eb011020          ADD      r0,r1,r0,ASR #4       ;1060
000c6c  f000000f          AND      r0,r0,#0xf            ;1060
000c70  f8ad0002          STRH     r0,[sp,#2]            ;1060
000c74  f89d001a          LDRB     r0,[sp,#0x1a]         ;1061
000c78  eb011020          ADD      r0,r1,r0,ASR #4       ;1061
000c7c  f000000f          AND      r0,r0,#0xf            ;1061
000c80  f8ad0004          STRH     r0,[sp,#4]            ;1061
000c84  6820              LDR      r0,[r4,#0]            ;1063
000c86  0041              LSLS     r1,r0,#1              ;1063
000c88  f9bd0000          LDRSH    r0,[sp,#0]            ;1063
000c8c  3040              ADDS     r0,r0,#0x40           ;1063
000c8e  fb91f0f0          SDIV     r0,r1,r0              ;1063
000c92  b200              SXTH     r0,r0                 ;1063
000c94  f8ad0010          STRH     r0,[sp,#0x10]         ;1063
000c98  6860              LDR      r0,[r4,#4]            ;1064
000c9a  0041              LSLS     r1,r0,#1              ;1064
000c9c  f9bd0002          LDRSH    r0,[sp,#2]            ;1064
000ca0  3040              ADDS     r0,r0,#0x40           ;1064
000ca2  fb91f0f0          SDIV     r0,r1,r0              ;1064
000ca6  b200              SXTH     r0,r0                 ;1064
000ca8  f8ad0012          STRH     r0,[sp,#0x12]         ;1064
000cac  68a0              LDR      r0,[r4,#8]            ;1065
000cae  0041              LSLS     r1,r0,#1              ;1065
000cb0  f9bd0004          LDRSH    r0,[sp,#4]            ;1065
000cb4  3040              ADDS     r0,r0,#0x40           ;1065
000cb6  fb91f0f0          SDIV     r0,r1,r0              ;1065
000cba  b200              SXTH     r0,r0                 ;1065
000cbc  f8ad0014          STRH     r0,[sp,#0x14]         ;1065
000cc0  49d8              LDR      r1,|L1.4132|
000cc2  6849              LDR      r1,[r1,#4]            ;1067  ; st
000cc4  7808              LDRB     r0,[r1,#0]            ;1067
000cc6  ab06              ADD      r3,sp,#0x18           ;1067
000cc8  2206              MOVS     r2,#6                 ;1067
000cca  4611              MOV      r1,r2                 ;1067
000ccc  f7fffffe          BL       i2cRead
000cd0  b110              CBZ      r0,|L1.3288|
000cd2  f04f30ff          MOV      r0,#0xffffffff        ;1068
000cd6  e7ae              B        |L1.3126|
                  |L1.3288|
000cd8  f89d0019          LDRB     r0,[sp,#0x19]         ;1070
000cdc  f89d1018          LDRB     r1,[sp,#0x18]         ;1070
000ce0  ea402001          ORR      r0,r0,r1,LSL #8       ;1070
000ce4  b200              SXTH     r0,r0                 ;1070
000ce6  f8ad0008          STRH     r0,[sp,#8]            ;1070
000cea  f89d001b          LDRB     r0,[sp,#0x1b]         ;1071
000cee  f89d101a          LDRB     r1,[sp,#0x1a]         ;1071
000cf2  ea402001          ORR      r0,r0,r1,LSL #8       ;1071
000cf6  b200              SXTH     r0,r0                 ;1071
000cf8  f8ad000a          STRH     r0,[sp,#0xa]          ;1071
000cfc  f89d001d          LDRB     r0,[sp,#0x1d]         ;1072
000d00  f89d101c          LDRB     r1,[sp,#0x1c]         ;1072
000d04  ea402001          ORR      r0,r0,r1,LSL #8       ;1072
000d08  b200              SXTH     r0,r0                 ;1072
000d0a  f8ad000c          STRH     r0,[sp,#0xc]          ;1072
000d0e  f8bd0010          LDRH     r0,[sp,#0x10]         ;1074
000d12  f8bd1008          LDRH     r1,[sp,#8]            ;1074
000d16  4408              ADD      r0,r0,r1              ;1074
000d18  b200              SXTH     r0,r0                 ;1074
000d1a  f8ad0010          STRH     r0,[sp,#0x10]         ;1074
000d1e  f8bd0012          LDRH     r0,[sp,#0x12]         ;1075
000d22  f8bd100a          LDRH     r1,[sp,#0xa]          ;1075
000d26  4408              ADD      r0,r0,r1              ;1075
000d28  b200              SXTH     r0,r0                 ;1075
000d2a  f8ad0012          STRH     r0,[sp,#0x12]         ;1075
000d2e  f8bd0014          LDRH     r0,[sp,#0x14]         ;1076
000d32  f8bd100c          LDRH     r1,[sp,#0xc]          ;1076
000d36  4408              ADD      r0,r0,r1              ;1076
000d38  b200              SXTH     r0,r0                 ;1076
000d3a  f8ad0014          STRH     r0,[sp,#0x14]         ;1076
000d3e  f8bd0010          LDRH     r0,[sp,#0x10]         ;1078
000d42  0a00              LSRS     r0,r0,#8              ;1078
000d44  f88d0018          STRB     r0,[sp,#0x18]         ;1078
000d48  f8bd0010          LDRH     r0,[sp,#0x10]         ;1079
000d4c  b2c0              UXTB     r0,r0                 ;1079
000d4e  f88d0019          STRB     r0,[sp,#0x19]         ;1079
000d52  f8bd0012          LDRH     r0,[sp,#0x12]         ;1080
000d56  0a00              LSRS     r0,r0,#8              ;1080
000d58  f88d001a          STRB     r0,[sp,#0x1a]         ;1080
000d5c  f8bd0012          LDRH     r0,[sp,#0x12]         ;1081
000d60  b2c0              UXTB     r0,r0                 ;1081
000d62  f88d001b          STRB     r0,[sp,#0x1b]         ;1081
000d66  f8bd0014          LDRH     r0,[sp,#0x14]         ;1082
000d6a  0a00              LSRS     r0,r0,#8              ;1082
000d6c  f88d001c          STRB     r0,[sp,#0x1c]         ;1082
000d70  f8bd0014          LDRH     r0,[sp,#0x14]         ;1083
000d74  b2c0              UXTB     r0,r0                 ;1083
000d76  f88d001d          STRB     r0,[sp,#0x1d]         ;1083
000d7a  49aa              LDR      r1,|L1.4132|
000d7c  6849              LDR      r1,[r1,#4]            ;1085  ; st
000d7e  7808              LDRB     r0,[r1,#0]            ;1085
000d80  ab06              ADD      r3,sp,#0x18           ;1085
000d82  2206              MOVS     r2,#6                 ;1085
000d84  4611              MOV      r1,r2                 ;1085
000d86  f7fffffe          BL       i2cWrite
000d8a  b110              CBZ      r0,|L1.3474|
000d8c  f04f30ff          MOV      r0,#0xffffffff        ;1086
000d90  e751              B        |L1.3126|
                  |L1.3474|
000d92  2000              MOVS     r0,#0                 ;1087
000d94  e74f              B        |L1.3126|
;;;1089   
                          ENDP

                  mpu_get_gyro_fsr PROC
;;;1155    */
;;;1156   int mpu_get_gyro_fsr(unsigned short *fsr)
000d96  4601              MOV      r1,r0
;;;1157   {
;;;1158       switch (st.chip_cfg.gyro_fsr) {
000d98  48a2              LDR      r0,|L1.4132|
000d9a  7a00              LDRB     r0,[r0,#8]  ; st
000d9c  b130              CBZ      r0,|L1.3500|
000d9e  2801              CMP      r0,#1
000da0  d007              BEQ      |L1.3506|
000da2  2802              CMP      r0,#2
000da4  d009              BEQ      |L1.3514|
000da6  2803              CMP      r0,#3
000da8  d10f              BNE      |L1.3530|
000daa  e00a              B        |L1.3522|
                  |L1.3500|
;;;1159       case INV_FSR_250DPS:
;;;1160           fsr[0] = 250;
000dac  20fa              MOVS     r0,#0xfa
000dae  8008              STRH     r0,[r1,#0]
;;;1161           break;
000db0  e00e              B        |L1.3536|
                  |L1.3506|
;;;1162       case INV_FSR_500DPS:
;;;1163           fsr[0] = 500;
000db2  f44f70fa          MOV      r0,#0x1f4
000db6  8008              STRH     r0,[r1,#0]
;;;1164           break;
000db8  e00a              B        |L1.3536|
                  |L1.3514|
;;;1165       case INV_FSR_1000DPS:
;;;1166           fsr[0] = 1000;
000dba  f44f707a          MOV      r0,#0x3e8
000dbe  8008              STRH     r0,[r1,#0]
;;;1167           break;
000dc0  e006              B        |L1.3536|
                  |L1.3522|
;;;1168       case INV_FSR_2000DPS:
;;;1169           fsr[0] = 2000;
000dc2  f44f60fa          MOV      r0,#0x7d0
000dc6  8008              STRH     r0,[r1,#0]
;;;1170           break;
000dc8  e002              B        |L1.3536|
                  |L1.3530|
;;;1171       default:
;;;1172           fsr[0] = 0;
000dca  2000              MOVS     r0,#0
000dcc  8008              STRH     r0,[r1,#0]
;;;1173           break;
000dce  bf00              NOP      
                  |L1.3536|
000dd0  bf00              NOP                            ;1161
;;;1174       }
;;;1175       return 0;
000dd2  2000              MOVS     r0,#0
;;;1176   }
000dd4  4770              BX       lr
;;;1177   
                          ENDP

                  mpu_get_accel_fsr PROC
;;;1219    */
;;;1220   int mpu_get_accel_fsr(unsigned char *fsr)
000dd6  4601              MOV      r1,r0
;;;1221   {
;;;1222       switch (st.chip_cfg.accel_fsr) {
000dd8  4892              LDR      r0,|L1.4132|
000dda  7a40              LDRB     r0,[r0,#9]
000ddc  b130              CBZ      r0,|L1.3564|
000dde  2801              CMP      r0,#1
000de0  d007              BEQ      |L1.3570|
000de2  2802              CMP      r0,#2
000de4  d008              BEQ      |L1.3576|
000de6  2803              CMP      r0,#3
000de8  d10c              BNE      |L1.3588|
000dea  e008              B        |L1.3582|
                  |L1.3564|
;;;1223       case INV_FSR_2G:
;;;1224           fsr[0] = 2;
000dec  2002              MOVS     r0,#2
000dee  7008              STRB     r0,[r1,#0]
;;;1225           break;
000df0  e00b              B        |L1.3594|
                  |L1.3570|
;;;1226       case INV_FSR_4G:
;;;1227           fsr[0] = 4;
000df2  2004              MOVS     r0,#4
000df4  7008              STRB     r0,[r1,#0]
;;;1228           break;
000df6  e008              B        |L1.3594|
                  |L1.3576|
;;;1229       case INV_FSR_8G:
;;;1230           fsr[0] = 8;
000df8  2008              MOVS     r0,#8
000dfa  7008              STRB     r0,[r1,#0]
;;;1231           break;
000dfc  e005              B        |L1.3594|
                  |L1.3582|
;;;1232       case INV_FSR_16G:
;;;1233           fsr[0] = 16;
000dfe  2010              MOVS     r0,#0x10
000e00  7008              STRB     r0,[r1,#0]
;;;1234           break;
000e02  e002              B        |L1.3594|
                  |L1.3588|
;;;1235       default:
;;;1236           return -1;
000e04  f04f30ff          MOV      r0,#0xffffffff
                  |L1.3592|
;;;1237       }
;;;1238       if (st.chip_cfg.accel_half)
;;;1239           fsr[0] <<= 1;
;;;1240       return 0;
;;;1241   }
000e08  4770              BX       lr
                  |L1.3594|
000e0a  bf00              NOP                            ;1225
000e0c  4885              LDR      r0,|L1.4132|
000e0e  7cc0              LDRB     r0,[r0,#0x13]         ;1238
000e10  b118              CBZ      r0,|L1.3610|
000e12  7808              LDRB     r0,[r1,#0]            ;1239
000e14  0640              LSLS     r0,r0,#25             ;1239
000e16  0e00              LSRS     r0,r0,#24             ;1239
000e18  7008              STRB     r0,[r1,#0]            ;1239
                  |L1.3610|
000e1a  2000              MOVS     r0,#0                 ;1240
000e1c  e7f4              B        |L1.3592|
;;;1242   
                          ENDP

                  mpu_get_lpf PROC
;;;1284    */
;;;1285   int mpu_get_lpf(unsigned short *lpf)
000e1e  4601              MOV      r1,r0
;;;1286   {
;;;1287       switch (st.chip_cfg.lpf) {
000e20  4880              LDR      r0,|L1.4132|
000e22  7ac0              LDRB     r0,[r0,#0xb]
000e24  2808              CMP      r0,#8
000e26  d217              BCS      |L1.3672|
000e28  e8dff000          TBB      [pc,r0]
000e2c  1704070a          DCB      0x17,0x04,0x07,0x0a
000e30  0d101318          DCB      0x0d,0x10,0x13,0x18
;;;1288       case INV_FILTER_188HZ:
;;;1289           lpf[0] = 188;
000e34  20bc              MOVS     r0,#0xbc
000e36  8008              STRH     r0,[r1,#0]
;;;1290           break;
000e38  e013              B        |L1.3682|
;;;1291       case INV_FILTER_98HZ:
;;;1292           lpf[0] = 98;
000e3a  2062              MOVS     r0,#0x62
000e3c  8008              STRH     r0,[r1,#0]
;;;1293           break;
000e3e  e010              B        |L1.3682|
;;;1294       case INV_FILTER_42HZ:
;;;1295           lpf[0] = 42;
000e40  202a              MOVS     r0,#0x2a
000e42  8008              STRH     r0,[r1,#0]
;;;1296           break;
000e44  e00d              B        |L1.3682|
;;;1297       case INV_FILTER_20HZ:
;;;1298           lpf[0] = 20;
000e46  2014              MOVS     r0,#0x14
000e48  8008              STRH     r0,[r1,#0]
;;;1299           break;
000e4a  e00a              B        |L1.3682|
;;;1300       case INV_FILTER_10HZ:
;;;1301           lpf[0] = 10;
000e4c  200a              MOVS     r0,#0xa
000e4e  8008              STRH     r0,[r1,#0]
;;;1302           break;
000e50  e007              B        |L1.3682|
;;;1303       case INV_FILTER_5HZ:
;;;1304           lpf[0] = 5;
000e52  2005              MOVS     r0,#5
000e54  8008              STRH     r0,[r1,#0]
;;;1305           break;
000e56  e004              B        |L1.3682|
                  |L1.3672|
;;;1306       case INV_FILTER_256HZ_NOLPF2:
000e58  bf00              NOP      
;;;1307       case INV_FILTER_2100HZ_NOLPF:
000e5a  bf00              NOP      
;;;1308       default:
;;;1309           lpf[0] = 0;
000e5c  2000              MOVS     r0,#0
000e5e  8008              STRH     r0,[r1,#0]
;;;1310           break;
000e60  bf00              NOP      
                  |L1.3682|
000e62  bf00              NOP                            ;1290
;;;1311       }
;;;1312       return 0;
000e64  2000              MOVS     r0,#0
;;;1313   }
000e66  4770              BX       lr
;;;1314   
                          ENDP

                  mpu_get_sample_rate PROC
;;;1353    */
;;;1354   int mpu_get_sample_rate(unsigned short *rate)
000e68  4601              MOV      r1,r0
;;;1355   {
;;;1356       if (st.chip_cfg.dmp_on)
000e6a  486e              LDR      r0,|L1.4132|
000e6c  f8900024          LDRB     r0,[r0,#0x24]
000e70  b110              CBZ      r0,|L1.3704|
;;;1357           return -1;
000e72  f04f30ff          MOV      r0,#0xffffffff
                  |L1.3702|
;;;1358       else
;;;1359           rate[0] = st.chip_cfg.sample_rate;
;;;1360       return 0;
;;;1361   }
000e76  4770              BX       lr
                  |L1.3704|
000e78  486a              LDR      r0,|L1.4132|
000e7a  89c0              LDRH     r0,[r0,#0xe]          ;1359
000e7c  8008              STRH     r0,[r1,#0]            ;1359
000e7e  2000              MOVS     r0,#0                 ;1360
000e80  e7f9              B        |L1.3702|
;;;1362   
                          ENDP

                  mpu_get_compass_sample_rate PROC
;;;1415    */
;;;1416   int mpu_get_compass_sample_rate(unsigned short *rate)
000e82  4601              MOV      r1,r0
;;;1417   {
;;;1418   #ifdef AK89xx_SECONDARY
;;;1419       rate[0] = st.chip_cfg.compass_sample_rate;
;;;1420       return 0;
;;;1421   #else
;;;1422       rate[0] = 0;
000e84  2000              MOVS     r0,#0
000e86  8008              STRH     r0,[r1,#0]
;;;1423       return -1;
000e88  1e40              SUBS     r0,r0,#1
;;;1424   #endif
;;;1425   }
000e8a  4770              BX       lr
;;;1426   
                          ENDP

                  mpu_set_compass_sample_rate PROC
;;;1437    */
;;;1438   int mpu_set_compass_sample_rate(unsigned short rate)
000e8c  4601              MOV      r1,r0
;;;1439   {
;;;1440   #ifdef AK89xx_SECONDARY
;;;1441       unsigned char div;
;;;1442       if (!rate || rate > st.chip_cfg.sample_rate || rate > MAX_COMPASS_SAMPLE_RATE)
;;;1443           return -1;
;;;1444   
;;;1445       div = st.chip_cfg.sample_rate / rate - 1;
;;;1446       if (i2c_write(st.hw->addr, st.reg->s4_ctrl, 1, &div))
;;;1447           return -1;
;;;1448       st.chip_cfg.compass_sample_rate = st.chip_cfg.sample_rate / (div + 1);
;;;1449       return 0;
;;;1450   #else
;;;1451       return -1;
000e8e  f04f30ff          MOV      r0,#0xffffffff
;;;1452   #endif
;;;1453   }
000e92  4770              BX       lr
;;;1454   
                          ENDP

                  mpu_get_gyro_sens PROC
;;;1459    */
;;;1460   int mpu_get_gyro_sens(float *sens)
000e94  4601              MOV      r1,r0
;;;1461   {
;;;1462       switch (st.chip_cfg.gyro_fsr) {
000e96  4863              LDR      r0,|L1.4132|
000e98  7a00              LDRB     r0,[r0,#8]  ; st
000e9a  b130              CBZ      r0,|L1.3754|
000e9c  2801              CMP      r0,#1
000e9e  d007              BEQ      |L1.3760|
000ea0  2802              CMP      r0,#2
000ea2  d008              BEQ      |L1.3766|
000ea4  2803              CMP      r0,#3
000ea6  d10c              BNE      |L1.3778|
000ea8  e008              B        |L1.3772|
                  |L1.3754|
;;;1463       case INV_FSR_250DPS:
;;;1464           sens[0] = 131.f;
000eaa  485f              LDR      r0,|L1.4136|
000eac  6008              STR      r0,[r1,#0]
;;;1465           break;
000eae  e00b              B        |L1.3784|
                  |L1.3760|
;;;1466       case INV_FSR_500DPS:
;;;1467           sens[0] = 65.5f;
000eb0  485e              LDR      r0,|L1.4140|
000eb2  6008              STR      r0,[r1,#0]
;;;1468           break;
000eb4  e008              B        |L1.3784|
                  |L1.3766|
;;;1469       case INV_FSR_1000DPS:
;;;1470           sens[0] = 32.8f;
000eb6  485e              LDR      r0,|L1.4144|
000eb8  6008              STR      r0,[r1,#0]
;;;1471           break;
000eba  e005              B        |L1.3784|
                  |L1.3772|
;;;1472       case INV_FSR_2000DPS:
;;;1473           sens[0] = 16.4f;
000ebc  485d              LDR      r0,|L1.4148|
000ebe  6008              STR      r0,[r1,#0]
;;;1474           break;
000ec0  e002              B        |L1.3784|
                  |L1.3778|
;;;1475       default:
;;;1476           return -1;
000ec2  f04f30ff          MOV      r0,#0xffffffff
                  |L1.3782|
;;;1477       }
;;;1478       return 0;
;;;1479   }
000ec6  4770              BX       lr
                  |L1.3784|
000ec8  bf00              NOP                            ;1465
000eca  2000              MOVS     r0,#0                 ;1478
000ecc  e7fb              B        |L1.3782|
;;;1480   
                          ENDP

                  mpu_get_accel_sens PROC
;;;1485    */
;;;1486   int mpu_get_accel_sens(unsigned short *sens)
000ece  4601              MOV      r1,r0
;;;1487   {
;;;1488       switch (st.chip_cfg.accel_fsr) {
000ed0  4854              LDR      r0,|L1.4132|
000ed2  7a40              LDRB     r0,[r0,#9]
000ed4  b130              CBZ      r0,|L1.3812|
000ed6  2801              CMP      r0,#1
000ed8  d008              BEQ      |L1.3820|
000eda  2802              CMP      r0,#2
000edc  d00a              BEQ      |L1.3828|
000ede  2803              CMP      r0,#3
000ee0  d110              BNE      |L1.3844|
000ee2  e00b              B        |L1.3836|
                  |L1.3812|
;;;1489       case INV_FSR_2G:
;;;1490           sens[0] = 16384;
000ee4  f44f4080          MOV      r0,#0x4000
000ee8  8008              STRH     r0,[r1,#0]
;;;1491           break;
000eea  e00e              B        |L1.3850|
                  |L1.3820|
;;;1492       case INV_FSR_4G:
;;;1493           sens[0] = 8092;
000eec  f641709c          MOV      r0,#0x1f9c
000ef0  8008              STRH     r0,[r1,#0]
;;;1494           break;
000ef2  e00a              B        |L1.3850|
                  |L1.3828|
;;;1495       case INV_FSR_8G:
;;;1496           sens[0] = 4096;
000ef4  f44f5080          MOV      r0,#0x1000
000ef8  8008              STRH     r0,[r1,#0]
;;;1497           break;
000efa  e006              B        |L1.3850|
                  |L1.3836|
;;;1498       case INV_FSR_16G:
;;;1499           sens[0] = 2048;
000efc  f44f6000          MOV      r0,#0x800
000f00  8008              STRH     r0,[r1,#0]
;;;1500           break;
000f02  e002              B        |L1.3850|
                  |L1.3844|
;;;1501       default:
;;;1502           return -1;
000f04  f04f30ff          MOV      r0,#0xffffffff
                  |L1.3848|
;;;1503       }
;;;1504       if (st.chip_cfg.accel_half)
;;;1505           sens[0] >>= 1;
;;;1506       return 0;
;;;1507   }
000f08  4770              BX       lr
                  |L1.3850|
000f0a  bf00              NOP                            ;1491
000f0c  4845              LDR      r0,|L1.4132|
000f0e  7cc0              LDRB     r0,[r0,#0x13]         ;1504
000f10  b110              CBZ      r0,|L1.3864|
000f12  8808              LDRH     r0,[r1,#0]            ;1505
000f14  1040              ASRS     r0,r0,#1              ;1505
000f16  8008              STRH     r0,[r1,#0]            ;1505
                  |L1.3864|
000f18  2000              MOVS     r0,#0                 ;1506
000f1a  e7f5              B        |L1.3848|
;;;1508   
                          ENDP

                  mpu_get_fifo_config PROC
;;;1517    */
;;;1518   int mpu_get_fifo_config(unsigned char *sensors)
000f1c  4601              MOV      r1,r0
;;;1519   {
;;;1520       sensors[0] = st.chip_cfg.fifo_enable;
000f1e  4841              LDR      r0,|L1.4132|
000f20  7c00              LDRB     r0,[r0,#0x10]
000f22  7008              STRB     r0,[r1,#0]
;;;1521       return 0;
000f24  2000              MOVS     r0,#0
;;;1522   }
000f26  4770              BX       lr
;;;1523   
                          ENDP

                  mpu_get_power_state PROC
;;;1574    */
;;;1575   int mpu_get_power_state(unsigned char *power_on)
000f28  4601              MOV      r1,r0
;;;1576   {
;;;1577       if (st.chip_cfg.sensors)
000f2a  483e              LDR      r0,|L1.4132|
000f2c  7a80              LDRB     r0,[r0,#0xa]
000f2e  b110              CBZ      r0,|L1.3894|
;;;1578           power_on[0] = 1;
000f30  2001              MOVS     r0,#1
000f32  7008              STRB     r0,[r1,#0]
000f34  e001              B        |L1.3898|
                  |L1.3894|
;;;1579       else
;;;1580           power_on[0] = 0;
000f36  2000              MOVS     r0,#0
000f38  7008              STRB     r0,[r1,#0]
                  |L1.3898|
;;;1581       return 0;
000f3a  2000              MOVS     r0,#0
;;;1582   }
000f3c  4770              BX       lr
;;;1583   
                          ENDP

                  mpu_get_int_status PROC
;;;1670    */
;;;1671   int mpu_get_int_status(short *status)
000f3e  b538              PUSH     {r3-r5,lr}
;;;1672   {
000f40  4604              MOV      r4,r0
;;;1673       unsigned char tmp[2];
;;;1674       if (!st.chip_cfg.sensors)
000f42  4838              LDR      r0,|L1.4132|
000f44  7a80              LDRB     r0,[r0,#0xa]
000f46  b910              CBNZ     r0,|L1.3918|
;;;1675           return -1;
000f48  f04f30ff          MOV      r0,#0xffffffff
                  |L1.3916|
;;;1676       if (i2c_read(st.hw->addr, st.reg->dmp_int_status, 2, tmp))
;;;1677           return -1;
;;;1678       status[0] = (tmp[0] << 8) | tmp[1];
;;;1679       return 0;
;;;1680   }
000f4c  bd38              POP      {r3-r5,pc}
                  |L1.3918|
000f4e  4a35              LDR      r2,|L1.4132|
000f50  6812              LDR      r2,[r2,#0]            ;1676  ; st
000f52  7c11              LDRB     r1,[r2,#0x10]         ;1676
000f54  4a33              LDR      r2,|L1.4132|
000f56  6852              LDR      r2,[r2,#4]            ;1676  ; st
000f58  7810              LDRB     r0,[r2,#0]            ;1676
000f5a  466b              MOV      r3,sp                 ;1676
000f5c  2202              MOVS     r2,#2                 ;1676
000f5e  f7fffffe          BL       i2cRead
000f62  b110              CBZ      r0,|L1.3946|
000f64  f04f30ff          MOV      r0,#0xffffffff        ;1677
000f68  e7f0              B        |L1.3916|
                  |L1.3946|
000f6a  f89d0001          LDRB     r0,[sp,#1]            ;1678
000f6e  f89d1000          LDRB     r1,[sp,#0]            ;1678
000f72  ea402001          ORR      r0,r0,r1,LSL #8       ;1678
000f76  b200              SXTH     r0,r0                 ;1678
000f78  8020              STRH     r0,[r4,#0]            ;1678
000f7a  2000              MOVS     r0,#0                 ;1679
000f7c  e7e6              B        |L1.3916|
;;;1681   
                          ENDP

                  mpu_read_fifo PROC
;;;1699    */
;;;1700   int mpu_read_fifo(short *gyro, short *accel, unsigned long *timestamp,
000f7e  e92d4ffe          PUSH     {r1-r11,lr}
;;;1701           unsigned char *sensors, unsigned char *more)
;;;1702   {
000f82  4680              MOV      r8,r0
000f84  4689              MOV      r9,r1
000f86  4692              MOV      r10,r2
000f88  461d              MOV      r5,r3
000f8a  f8ddb030          LDR      r11,[sp,#0x30]
;;;1703       /* Assumes maximum packet size is gyro (6) + accel (6). */
;;;1704       unsigned char data[MAX_PACKET_LENGTH];
;;;1705       unsigned char packet_size = 0;
000f8e  2600              MOVS     r6,#0
;;;1706       unsigned short fifo_count, index = 0;
000f90  2400              MOVS     r4,#0
;;;1707   
;;;1708       if (st.chip_cfg.dmp_on)
000f92  4824              LDR      r0,|L1.4132|
000f94  f8900024          LDRB     r0,[r0,#0x24]
000f98  b110              CBZ      r0,|L1.4000|
;;;1709           return -1;
000f9a  1e60              SUBS     r0,r4,#1
                  |L1.3996|
;;;1710   
;;;1711       sensors[0] = 0;
;;;1712       if (!st.chip_cfg.sensors)
;;;1713           return -1;
;;;1714       if (!st.chip_cfg.fifo_enable)
;;;1715           return -1;
;;;1716   
;;;1717       if (st.chip_cfg.fifo_enable & INV_X_GYRO)
;;;1718           packet_size += 2;
;;;1719       if (st.chip_cfg.fifo_enable & INV_Y_GYRO)
;;;1720           packet_size += 2;
;;;1721       if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
;;;1722           packet_size += 2;
;;;1723       if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
;;;1724           packet_size += 6;
;;;1725   
;;;1726       if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
;;;1727           return -1;
;;;1728       fifo_count = (data[0] << 8) | data[1];
;;;1729       if (fifo_count < packet_size)
;;;1730           return 0;
;;;1731   //    log_i("FIFO count: %hd\n", fifo_count);
;;;1732       if (fifo_count > (st.hw->max_fifo >> 1)) {
;;;1733           /* FIFO is 50% full, better check overflow bit. */
;;;1734           if (i2c_read(st.hw->addr, st.reg->int_status, 1, data))
;;;1735               return -1;
;;;1736           if (data[0] & BIT_FIFO_OVERFLOW) {
;;;1737               mpu_reset_fifo();
;;;1738               return -2;
;;;1739           }
;;;1740       }
;;;1741       get_ms((unsigned long*)timestamp);
;;;1742   
;;;1743       if (i2c_read(st.hw->addr, st.reg->fifo_r_w, packet_size, data))
;;;1744           return -1;
;;;1745       more[0] = fifo_count / packet_size - 1;
;;;1746       sensors[0] = 0;
;;;1747   
;;;1748       if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_XYZ_ACCEL) {
;;;1749           accel[0] = (data[index+0] << 8) | data[index+1];
;;;1750           accel[1] = (data[index+2] << 8) | data[index+3];
;;;1751           accel[2] = (data[index+4] << 8) | data[index+5];
;;;1752           sensors[0] |= INV_XYZ_ACCEL;
;;;1753           index += 6;
;;;1754       }
;;;1755       if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_X_GYRO) {
;;;1756           gyro[0] = (data[index+0] << 8) | data[index+1];
;;;1757           sensors[0] |= INV_X_GYRO;
;;;1758           index += 2;
;;;1759       }
;;;1760       if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Y_GYRO) {
;;;1761           gyro[1] = (data[index+0] << 8) | data[index+1];
;;;1762           sensors[0] |= INV_Y_GYRO;
;;;1763           index += 2;
;;;1764       }
;;;1765       if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Z_GYRO) {
;;;1766           gyro[2] = (data[index+0] << 8) | data[index+1];
;;;1767           sensors[0] |= INV_Z_GYRO;
;;;1768           index += 2;
;;;1769       }
;;;1770   
;;;1771       return 0;
;;;1772   }
000f9c  e8bd8ffe          POP      {r1-r11,pc}
                  |L1.4000|
000fa0  2000              MOVS     r0,#0                 ;1711
000fa2  7028              STRB     r0,[r5,#0]            ;1711
000fa4  481f              LDR      r0,|L1.4132|
000fa6  7a80              LDRB     r0,[r0,#0xa]          ;1712
000fa8  b910              CBNZ     r0,|L1.4016|
000faa  f04f30ff          MOV      r0,#0xffffffff        ;1713
000fae  e7f5              B        |L1.3996|
                  |L1.4016|
000fb0  481c              LDR      r0,|L1.4132|
000fb2  7c00              LDRB     r0,[r0,#0x10]         ;1714
000fb4  b910              CBNZ     r0,|L1.4028|
000fb6  f04f30ff          MOV      r0,#0xffffffff        ;1715
000fba  e7ef              B        |L1.3996|
                  |L1.4028|
000fbc  4819              LDR      r0,|L1.4132|
000fbe  7c00              LDRB     r0,[r0,#0x10]         ;1717
000fc0  f0100f40          TST      r0,#0x40              ;1717
000fc4  d001              BEQ      |L1.4042|
000fc6  1cb0              ADDS     r0,r6,#2              ;1718
000fc8  b2c6              UXTB     r6,r0                 ;1718
                  |L1.4042|
000fca  4816              LDR      r0,|L1.4132|
000fcc  7c00              LDRB     r0,[r0,#0x10]         ;1719
000fce  f0100f20          TST      r0,#0x20              ;1719
000fd2  d001              BEQ      |L1.4056|
000fd4  1cb0              ADDS     r0,r6,#2              ;1720
000fd6  b2c6              UXTB     r6,r0                 ;1720
                  |L1.4056|
000fd8  4812              LDR      r0,|L1.4132|
000fda  7c00              LDRB     r0,[r0,#0x10]         ;1721
000fdc  f0100f10          TST      r0,#0x10              ;1721
000fe0  d001              BEQ      |L1.4070|
000fe2  1cb0              ADDS     r0,r6,#2              ;1722
000fe4  b2c6              UXTB     r6,r0                 ;1722
                  |L1.4070|
000fe6  480f              LDR      r0,|L1.4132|
000fe8  7c00              LDRB     r0,[r0,#0x10]         ;1723
000fea  f0100f08          TST      r0,#8                 ;1723
000fee  d001              BEQ      |L1.4084|
000ff0  1db0              ADDS     r0,r6,#6              ;1724
000ff2  b2c6              UXTB     r6,r0                 ;1724
                  |L1.4084|
000ff4  4a0b              LDR      r2,|L1.4132|
000ff6  6812              LDR      r2,[r2,#0]            ;1726  ; st
000ff8  7a91              LDRB     r1,[r2,#0xa]          ;1726
000ffa  4a0a              LDR      r2,|L1.4132|
000ffc  6852              LDR      r2,[r2,#4]            ;1726  ; st
000ffe  7810              LDRB     r0,[r2,#0]            ;1726
001000  466b              MOV      r3,sp                 ;1726
001002  2202              MOVS     r2,#2                 ;1726
001004  f7fffffe          BL       i2cRead
001008  b110              CBZ      r0,|L1.4112|
00100a  f04f30ff          MOV      r0,#0xffffffff        ;1727
00100e  e7c5              B        |L1.3996|
                  |L1.4112|
001010  f89d0001          LDRB     r0,[sp,#1]            ;1728
001014  f89d1000          LDRB     r1,[sp,#0]            ;1728
001018  ea402701          ORR      r7,r0,r1,LSL #8       ;1728
00101c  42b7              CMP      r7,r6                 ;1729
00101e  da0b              BGE      |L1.4152|
001020  2000              MOVS     r0,#0                 ;1730
001022  e7bb              B        |L1.3996|
                  |L1.4132|
                          DCD      ||st||
                  |L1.4136|
                          DCD      0x43030000
                  |L1.4140|
                          DCD      0x42830000
                  |L1.4144|
                          DCD      0x42033333
                  |L1.4148|
                          DCD      0x41833333
                  |L1.4152|
001038  48fb              LDR      r0,|L1.5160|
00103a  6840              LDR      r0,[r0,#4]            ;1732  ; st
00103c  8840              LDRH     r0,[r0,#2]            ;1732
00103e  ebb70f60          CMP      r7,r0,ASR #1          ;1732
001042  dd17              BLE      |L1.4212|
001044  4af8              LDR      r2,|L1.5160|
001046  6812              LDR      r2,[r2,#0]            ;1734  ; st
001048  7c51              LDRB     r1,[r2,#0x11]         ;1734
00104a  4af7              LDR      r2,|L1.5160|
00104c  6852              LDR      r2,[r2,#4]            ;1734  ; st
00104e  7810              LDRB     r0,[r2,#0]            ;1734
001050  466b              MOV      r3,sp                 ;1734
001052  2201              MOVS     r2,#1                 ;1734
001054  f7fffffe          BL       i2cRead
001058  b110              CBZ      r0,|L1.4192|
00105a  f04f30ff          MOV      r0,#0xffffffff        ;1735
00105e  e79d              B        |L1.3996|
                  |L1.4192|
001060  f89d0000          LDRB     r0,[sp,#0]            ;1736
001064  f0100f10          TST      r0,#0x10              ;1736
001068  d004              BEQ      |L1.4212|
00106a  f7fffffe          BL       mpu_reset_fifo
00106e  f06f0001          MVN      r0,#1                 ;1738
001072  e793              B        |L1.3996|
                  |L1.4212|
001074  4650              MOV      r0,r10                ;1741
001076  f7fffffe          BL       myget_ms
00107a  4aeb              LDR      r2,|L1.5160|
00107c  6812              LDR      r2,[r2,#0]            ;1743  ; st
00107e  7ad1              LDRB     r1,[r2,#0xb]          ;1743
001080  4ae9              LDR      r2,|L1.5160|
001082  6852              LDR      r2,[r2,#4]            ;1743  ; st
001084  7810              LDRB     r0,[r2,#0]            ;1743
001086  466b              MOV      r3,sp                 ;1743
001088  4632              MOV      r2,r6                 ;1743
00108a  f7fffffe          BL       i2cRead
00108e  b110              CBZ      r0,|L1.4246|
001090  f04f30ff          MOV      r0,#0xffffffff        ;1744
001094  e782              B        |L1.3996|
                  |L1.4246|
001096  fb97f0f6          SDIV     r0,r7,r6              ;1745
00109a  1e40              SUBS     r0,r0,#1              ;1745
00109c  f88b0000          STRB     r0,[r11,#0]           ;1745
0010a0  2000              MOVS     r0,#0                 ;1746
0010a2  7028              STRB     r0,[r5,#0]            ;1746
0010a4  42b4              CMP      r4,r6                 ;1748
0010a6  d02a              BEQ      |L1.4350|
0010a8  48df              LDR      r0,|L1.5160|
0010aa  7c00              LDRB     r0,[r0,#0x10]         ;1748
0010ac  f0100f08          TST      r0,#8                 ;1748
0010b0  d025              BEQ      |L1.4350|
0010b2  1c60              ADDS     r0,r4,#1              ;1749
0010b4  f81d0000          LDRB     r0,[sp,r0]            ;1749
0010b8  f81d1004          LDRB     r1,[sp,r4]            ;1749
0010bc  ea402001          ORR      r0,r0,r1,LSL #8       ;1749
0010c0  b200              SXTH     r0,r0                 ;1749
0010c2  f8a90000          STRH     r0,[r9,#0]            ;1749
0010c6  1ce0              ADDS     r0,r4,#3              ;1750
0010c8  f81d1000          LDRB     r1,[sp,r0]            ;1750
0010cc  1ca0              ADDS     r0,r4,#2              ;1750
0010ce  f81d0000          LDRB     r0,[sp,r0]            ;1750
0010d2  ea412000          ORR      r0,r1,r0,LSL #8       ;1750
0010d6  b200              SXTH     r0,r0                 ;1750
0010d8  f8a90002          STRH     r0,[r9,#2]            ;1750
0010dc  1d60              ADDS     r0,r4,#5              ;1751
0010de  f81d1000          LDRB     r1,[sp,r0]            ;1751
0010e2  1d20              ADDS     r0,r4,#4              ;1751
0010e4  f81d0000          LDRB     r0,[sp,r0]            ;1751
0010e8  ea412000          ORR      r0,r1,r0,LSL #8       ;1751
0010ec  b200              SXTH     r0,r0                 ;1751
0010ee  f8a90004          STRH     r0,[r9,#4]            ;1751
0010f2  7828              LDRB     r0,[r5,#0]            ;1752
0010f4  f0400008          ORR      r0,r0,#8              ;1752
0010f8  7028              STRB     r0,[r5,#0]            ;1752
0010fa  1da0              ADDS     r0,r4,#6              ;1753
0010fc  b284              UXTH     r4,r0                 ;1753
                  |L1.4350|
0010fe  42b4              CMP      r4,r6                 ;1755
001100  d014              BEQ      |L1.4396|
001102  48c9              LDR      r0,|L1.5160|
001104  7c00              LDRB     r0,[r0,#0x10]         ;1755
001106  f0100f40          TST      r0,#0x40              ;1755
00110a  d00f              BEQ      |L1.4396|
00110c  1c60              ADDS     r0,r4,#1              ;1756
00110e  f81d0000          LDRB     r0,[sp,r0]            ;1756
001112  f81d1004          LDRB     r1,[sp,r4]            ;1756
001116  ea402001          ORR      r0,r0,r1,LSL #8       ;1756
00111a  b200              SXTH     r0,r0                 ;1756
00111c  f8a80000          STRH     r0,[r8,#0]            ;1756
001120  7828              LDRB     r0,[r5,#0]            ;1757
001122  f0400040          ORR      r0,r0,#0x40           ;1757
001126  7028              STRB     r0,[r5,#0]            ;1757
001128  1ca0              ADDS     r0,r4,#2              ;1758
00112a  b284              UXTH     r4,r0                 ;1758
                  |L1.4396|
00112c  42b4              CMP      r4,r6                 ;1760
00112e  d014              BEQ      |L1.4442|
001130  48bd              LDR      r0,|L1.5160|
001132  7c00              LDRB     r0,[r0,#0x10]         ;1760
001134  f0100f20          TST      r0,#0x20              ;1760
001138  d00f              BEQ      |L1.4442|
00113a  1c60              ADDS     r0,r4,#1              ;1761
00113c  f81d0000          LDRB     r0,[sp,r0]            ;1761
001140  f81d1004          LDRB     r1,[sp,r4]            ;1761
001144  ea402001          ORR      r0,r0,r1,LSL #8       ;1761
001148  b200              SXTH     r0,r0                 ;1761
00114a  f8a80002          STRH     r0,[r8,#2]            ;1761
00114e  7828              LDRB     r0,[r5,#0]            ;1762
001150  f0400020          ORR      r0,r0,#0x20           ;1762
001154  7028              STRB     r0,[r5,#0]            ;1762
001156  1ca0              ADDS     r0,r4,#2              ;1763
001158  b284              UXTH     r4,r0                 ;1763
                  |L1.4442|
00115a  42b4              CMP      r4,r6                 ;1765
00115c  d014              BEQ      |L1.4488|
00115e  48b2              LDR      r0,|L1.5160|
001160  7c00              LDRB     r0,[r0,#0x10]         ;1765
001162  f0100f10          TST      r0,#0x10              ;1765
001166  d00f              BEQ      |L1.4488|
001168  1c60              ADDS     r0,r4,#1              ;1766
00116a  f81d0000          LDRB     r0,[sp,r0]            ;1766
00116e  f81d1004          LDRB     r1,[sp,r4]            ;1766
001172  ea402001          ORR      r0,r0,r1,LSL #8       ;1766
001176  b200              SXTH     r0,r0                 ;1766
001178  f8a80004          STRH     r0,[r8,#4]            ;1766
00117c  7828              LDRB     r0,[r5,#0]            ;1767
00117e  f0400010          ORR      r0,r0,#0x10           ;1767
001182  7028              STRB     r0,[r5,#0]            ;1767
001184  1ca0              ADDS     r0,r4,#2              ;1768
001186  b284              UXTH     r4,r0                 ;1768
                  |L1.4488|
001188  2000              MOVS     r0,#0                 ;1771
00118a  e707              B        |L1.3996|
;;;1773   
                          ENDP

                  mpu_read_fifo_stream PROC
;;;1780    */
;;;1781   int mpu_read_fifo_stream(unsigned short length, unsigned char *data,
00118c  b5f8              PUSH     {r3-r7,lr}
;;;1782       unsigned char *more)
;;;1783   {
00118e  4605              MOV      r5,r0
001190  460f              MOV      r7,r1
001192  4616              MOV      r6,r2
;;;1784       unsigned char tmp[2];
;;;1785       unsigned short fifo_count;
;;;1786       if (!st.chip_cfg.dmp_on)
001194  48a4              LDR      r0,|L1.5160|
001196  f8900024          LDRB     r0,[r0,#0x24]
00119a  b910              CBNZ     r0,|L1.4514|
;;;1787           return -1;
00119c  f04f30ff          MOV      r0,#0xffffffff
                  |L1.4512|
;;;1788       if (!st.chip_cfg.sensors)
;;;1789           return -1;
;;;1790   
;;;1791       if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, tmp))
;;;1792           return -1;
;;;1793       fifo_count = (tmp[0] << 8) | tmp[1];
;;;1794       if (fifo_count < length) {
;;;1795           more[0] = 0;
;;;1796           return -1;
;;;1797       }
;;;1798       if (fifo_count > (st.hw->max_fifo >> 1)) {
;;;1799           /* FIFO is 50% full, better check overflow bit. */
;;;1800           if (i2c_read(st.hw->addr, st.reg->int_status, 1, tmp))
;;;1801               return -1;
;;;1802           if (tmp[0] & BIT_FIFO_OVERFLOW) {
;;;1803               mpu_reset_fifo();
;;;1804               return -2;
;;;1805           }
;;;1806       }
;;;1807   
;;;1808       if (i2c_read(st.hw->addr, st.reg->fifo_r_w, length, data))
;;;1809           return -1;
;;;1810       more[0] = fifo_count / length - 1;
;;;1811       return 0;
;;;1812   }
0011a0  bdf8              POP      {r3-r7,pc}
                  |L1.4514|
0011a2  48a1              LDR      r0,|L1.5160|
0011a4  7a80              LDRB     r0,[r0,#0xa]          ;1788
0011a6  b910              CBNZ     r0,|L1.4526|
0011a8  f04f30ff          MOV      r0,#0xffffffff        ;1789
0011ac  e7f8              B        |L1.4512|
                  |L1.4526|
0011ae  4a9e              LDR      r2,|L1.5160|
0011b0  6812              LDR      r2,[r2,#0]            ;1791  ; st
0011b2  7a91              LDRB     r1,[r2,#0xa]          ;1791
0011b4  4a9c              LDR      r2,|L1.5160|
0011b6  6852              LDR      r2,[r2,#4]            ;1791  ; st
0011b8  7810              LDRB     r0,[r2,#0]            ;1791
0011ba  466b              MOV      r3,sp                 ;1791
0011bc  2202              MOVS     r2,#2                 ;1791
0011be  f7fffffe          BL       i2cRead
0011c2  b110              CBZ      r0,|L1.4554|
0011c4  f04f30ff          MOV      r0,#0xffffffff        ;1792
0011c8  e7ea              B        |L1.4512|
                  |L1.4554|
0011ca  f89d0001          LDRB     r0,[sp,#1]            ;1793
0011ce  f89d1000          LDRB     r1,[sp,#0]            ;1793
0011d2  ea402401          ORR      r4,r0,r1,LSL #8       ;1793
0011d6  42ac              CMP      r4,r5                 ;1794
0011d8  da03              BGE      |L1.4578|
0011da  2000              MOVS     r0,#0                 ;1795
0011dc  7030              STRB     r0,[r6,#0]            ;1795
0011de  1e40              SUBS     r0,r0,#1              ;1796
0011e0  e7de              B        |L1.4512|
                  |L1.4578|
0011e2  4891              LDR      r0,|L1.5160|
0011e4  6840              LDR      r0,[r0,#4]            ;1798  ; st
0011e6  8840              LDRH     r0,[r0,#2]            ;1798
0011e8  ebb40f60          CMP      r4,r0,ASR #1          ;1798
0011ec  dd17              BLE      |L1.4638|
0011ee  4a8e              LDR      r2,|L1.5160|
0011f0  6812              LDR      r2,[r2,#0]            ;1800  ; st
0011f2  7c51              LDRB     r1,[r2,#0x11]         ;1800
0011f4  4a8c              LDR      r2,|L1.5160|
0011f6  6852              LDR      r2,[r2,#4]            ;1800  ; st
0011f8  7810              LDRB     r0,[r2,#0]            ;1800
0011fa  466b              MOV      r3,sp                 ;1800
0011fc  2201              MOVS     r2,#1                 ;1800
0011fe  f7fffffe          BL       i2cRead
001202  b110              CBZ      r0,|L1.4618|
001204  f04f30ff          MOV      r0,#0xffffffff        ;1801
001208  e7ca              B        |L1.4512|
                  |L1.4618|
00120a  f89d0000          LDRB     r0,[sp,#0]            ;1802
00120e  f0100f10          TST      r0,#0x10              ;1802
001212  d004              BEQ      |L1.4638|
001214  f7fffffe          BL       mpu_reset_fifo
001218  f06f0001          MVN      r0,#1                 ;1804
00121c  e7c0              B        |L1.4512|
                  |L1.4638|
00121e  4a82              LDR      r2,|L1.5160|
001220  6812              LDR      r2,[r2,#0]            ;1808  ; st
001222  7ad1              LDRB     r1,[r2,#0xb]          ;1808
001224  4a80              LDR      r2,|L1.5160|
001226  6852              LDR      r2,[r2,#4]            ;1808  ; st
001228  7810              LDRB     r0,[r2,#0]            ;1808
00122a  463b              MOV      r3,r7                 ;1808
00122c  b2ea              UXTB     r2,r5                 ;1808
00122e  f7fffffe          BL       i2cRead
001232  b110              CBZ      r0,|L1.4666|
001234  f04f30ff          MOV      r0,#0xffffffff        ;1809
001238  e7b2              B        |L1.4512|
                  |L1.4666|
00123a  fb94f0f5          SDIV     r0,r4,r5              ;1810
00123e  1e40              SUBS     r0,r0,#1              ;1810
001240  7030              STRB     r0,[r6,#0]            ;1810
001242  2000              MOVS     r0,#0                 ;1811
001244  e7ac              B        |L1.4512|
;;;1813   
                          ENDP

                  mpu_set_int_level PROC
;;;1868    */
;;;1869   int mpu_set_int_level(unsigned char active_low)
001246  4601              MOV      r1,r0
;;;1870   {
;;;1871       st.chip_cfg.active_low_int = active_low;
001248  4877              LDR      r0,|L1.5160|
00124a  f8801022          STRB     r1,[r0,#0x22]
;;;1872       return 0;
00124e  2000              MOVS     r0,#0
;;;1873   }
001250  4770              BX       lr
;;;1874   
                          ENDP

                  get_accel_prod_shift PROC
;;;1901   #ifdef MPU6050
;;;1902   static int get_accel_prod_shift(float *st_shift)
001252  b57c              PUSH     {r2-r6,lr}
;;;1903   {
001254  4605              MOV      r5,r0
;;;1904       unsigned char tmp[4], shift_code[3], ii;
;;;1905   
;;;1906       if (i2c_read(st.hw->addr, 0x0D, 4, tmp))
001256  4974              LDR      r1,|L1.5160|
001258  6849              LDR      r1,[r1,#4]  ; st
00125a  7808              LDRB     r0,[r1,#0]
00125c  ab01              ADD      r3,sp,#4
00125e  2204              MOVS     r2,#4
001260  210d              MOVS     r1,#0xd
001262  f7fffffe          BL       i2cRead
001266  b108              CBZ      r0,|L1.4716|
;;;1907           return 0x07;
001268  2007              MOVS     r0,#7
                  |L1.4714|
;;;1908   
;;;1909       shift_code[0] = ((tmp[0] & 0xE0) >> 3) | ((tmp[3] & 0x30) >> 4);
;;;1910       shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
;;;1911       shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
;;;1912       for (ii = 0; ii < 3; ii++) {
;;;1913           if (!shift_code[ii]) {
;;;1914               st_shift[ii] = 0.f;
;;;1915               continue;
;;;1916           }
;;;1917           /* Equivalent to..
;;;1918            * st_shift[ii] = 0.34f * powf(0.92f/0.34f, (shift_code[ii]-1) / 30.f)
;;;1919            */
;;;1920           st_shift[ii] = 0.34f;
;;;1921           while (--shift_code[ii])
;;;1922               st_shift[ii] *= 1.034f;
;;;1923       }
;;;1924       return 0;
;;;1925   }
00126a  bd7c              POP      {r2-r6,pc}
                  |L1.4716|
00126c  f89d0007          LDRB     r0,[sp,#7]            ;1909
001270  f3c01001          UBFX     r0,r0,#4,#2           ;1909
001274  f89d1004          LDRB     r1,[sp,#4]            ;1909
001278  f00101e0          AND      r1,r1,#0xe0           ;1909
00127c  ea4000e1          ORR      r0,r0,r1,ASR #3       ;1909
001280  f88d0000          STRB     r0,[sp,#0]            ;1909
001284  f89d0007          LDRB     r0,[sp,#7]            ;1910
001288  f3c00081          UBFX     r0,r0,#2,#2           ;1910
00128c  f89d1005          LDRB     r1,[sp,#5]            ;1910
001290  f00101e0          AND      r1,r1,#0xe0           ;1910
001294  ea4000e1          ORR      r0,r0,r1,ASR #3       ;1910
001298  f88d0001          STRB     r0,[sp,#1]            ;1910
00129c  f89d0007          LDRB     r0,[sp,#7]            ;1911
0012a0  f0000003          AND      r0,r0,#3              ;1911
0012a4  f89d1006          LDRB     r1,[sp,#6]            ;1911
0012a8  f00101e0          AND      r1,r1,#0xe0           ;1911
0012ac  ea4000e1          ORR      r0,r0,r1,ASR #3       ;1911
0012b0  f88d0002          STRB     r0,[sp,#2]            ;1911
0012b4  2400              MOVS     r4,#0                 ;1912
0012b6  e01c              B        |L1.4850|
                  |L1.4792|
0012b8  f81d0004          LDRB     r0,[sp,r4]            ;1913
0012bc  b918              CBNZ     r0,|L1.4806|
0012be  2000              MOVS     r0,#0                 ;1914
0012c0  f8450024          STR      r0,[r5,r4,LSL #2]     ;1914
0012c4  e013              B        |L1.4846|
                  |L1.4806|
0012c6  4859              LDR      r0,|L1.5164|
0012c8  f8450024          STR      r0,[r5,r4,LSL #2]     ;1920
0012cc  e006              B        |L1.4828|
                  |L1.4814|
0012ce  f8550024          LDR      r0,[r5,r4,LSL #2]     ;1922
0012d2  4957              LDR      r1,|L1.5168|
0012d4  f7fffffe          BL       __aeabi_fmul
0012d8  f8450024          STR      r0,[r5,r4,LSL #2]     ;1922
                  |L1.4828|
0012dc  f81d0004          LDRB     r0,[sp,r4]            ;1921
0012e0  1e40              SUBS     r0,r0,#1              ;1921
0012e2  f01000ff          ANDS     r0,r0,#0xff           ;1921
0012e6  f80d0004          STRB     r0,[sp,r4]            ;1921
0012ea  d1f0              BNE      |L1.4814|
0012ec  bf00              NOP                            ;1915
                  |L1.4846|
0012ee  1c60              ADDS     r0,r4,#1              ;1912
0012f0  b2c4              UXTB     r4,r0                 ;1912
                  |L1.4850|
0012f2  2c03              CMP      r4,#3                 ;1912
0012f4  dbe0              BLT      |L1.4792|
0012f6  2000              MOVS     r0,#0                 ;1924
0012f8  e7b7              B        |L1.4714|
;;;1926   
                          ENDP

                  accel_self_test PROC
;;;1927   static int accel_self_test(long *bias_regular, long *bias_st)
0012fa  e92d4ffe          PUSH     {r1-r11,lr}
;;;1928   {
0012fe  4606              MOV      r6,r0
001300  460f              MOV      r7,r1
;;;1929       int jj, result = 0;
001302  2500              MOVS     r5,#0
;;;1930       float st_shift[3], st_shift_cust, st_shift_var;
;;;1931   
;;;1932       get_accel_prod_shift(st_shift);
001304  4668              MOV      r0,sp
001306  f7fffffe          BL       get_accel_prod_shift
;;;1933       for(jj = 0; jj < 3; jj++) {
00130a  2400              MOVS     r4,#0
00130c  e040              B        |L1.5008|
                  |L1.4878|
;;;1934           st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
00130e  f8560024          LDR      r0,[r6,r4,LSL #2]
001312  f8571024          LDR      r1,[r7,r4,LSL #2]
001316  ebb00a01          SUBS     r10,r0,r1
00131a  d401              BMI      |L1.4896|
00131c  4651              MOV      r1,r10
00131e  e001              B        |L1.4900|
                  |L1.4896|
001320  f1ca0100          RSB      r1,r10,#0
                  |L1.4900|
001324  4608              MOV      r0,r1
001326  f7fffffe          BL       __aeabi_i2f
00132a  4683              MOV      r11,r0
00132c  f04f418f          MOV      r1,#0x47800000
001330  f7fffffe          BL       __aeabi_fdiv
001334  4680              MOV      r8,r0
;;;1935           if (st_shift[jj]) {
001336  f85d0024          LDR      r0,[sp,r4,LSL #2]
00133a  2100              MOVS     r1,#0
00133c  f7fffffe          BL       __aeabi_cfcmpeq
001340  d016              BEQ      |L1.4976|
;;;1936               st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
001342  f85d1024          LDR      r1,[sp,r4,LSL #2]
001346  4640              MOV      r0,r8
001348  f7fffffe          BL       __aeabi_fdiv
00134c  4682              MOV      r10,r0
00134e  f04f517e          MOV      r1,#0x3f800000
001352  f7fffffe          BL       __aeabi_fsub
001356  4681              MOV      r9,r0
;;;1937               if (fabs(st_shift_var) > test.max_accel_var)
001358  f0294a00          BIC      r10,r9,#0x80000000
00135c  4835              LDR      r0,|L1.5172|
00135e  6a41              LDR      r1,[r0,#0x24]  ; test
001360  4650              MOV      r0,r10
001362  f7fffffe          BL       __aeabi_cfrcmple
001366  d212              BCS      |L1.5006|
;;;1938                   result |= 1 << jj;
001368  2001              MOVS     r0,#1
00136a  40a0              LSLS     r0,r0,r4
00136c  4305              ORRS     r5,r5,r0
00136e  e00e              B        |L1.5006|
                  |L1.4976|
;;;1939           } else if ((st_shift_cust < test.min_g) ||
001370  4830              LDR      r0,|L1.5172|
001372  69c1              LDR      r1,[r0,#0x1c]  ; test
001374  4640              MOV      r0,r8
001376  f7fffffe          BL       __aeabi_cfcmple
00137a  d305              BCC      |L1.5000|
;;;1940               (st_shift_cust > test.max_g))
00137c  482d              LDR      r0,|L1.5172|
00137e  6a01              LDR      r1,[r0,#0x20]  ; test
001380  4640              MOV      r0,r8
001382  f7fffffe          BL       __aeabi_cfrcmple
001386  d202              BCS      |L1.5006|
                  |L1.5000|
;;;1941               result |= 1 << jj;
001388  2001              MOVS     r0,#1
00138a  40a0              LSLS     r0,r0,r4
00138c  4305              ORRS     r5,r5,r0
                  |L1.5006|
00138e  1c64              ADDS     r4,r4,#1              ;1933
                  |L1.5008|
001390  2c03              CMP      r4,#3                 ;1933
001392  dbbc              BLT      |L1.4878|
;;;1942       }
;;;1943   
;;;1944       return result;
001394  4628              MOV      r0,r5
;;;1945   }
001396  e8bd8ffe          POP      {r1-r11,pc}
;;;1946   
                          ENDP

                  gyro_self_test PROC
;;;1947   static int gyro_self_test(long *bias_regular, long *bias_st)
00139a  e92d5ffc          PUSH     {r2-r12,lr}
;;;1948   {
00139e  4606              MOV      r6,r0
0013a0  460f              MOV      r7,r1
;;;1949       int jj, result = 0;
0013a2  2500              MOVS     r5,#0
;;;1950       unsigned char tmp[3];
;;;1951       float st_shift, st_shift_cust, st_shift_var;
;;;1952   
;;;1953       if (i2c_read(st.hw->addr, 0x0D, 3, tmp))
0013a4  4920              LDR      r1,|L1.5160|
0013a6  6849              LDR      r1,[r1,#4]  ; st
0013a8  7808              LDRB     r0,[r1,#0]
0013aa  ab01              ADD      r3,sp,#4
0013ac  2203              MOVS     r2,#3
0013ae  210d              MOVS     r1,#0xd
0013b0  f7fffffe          BL       i2cRead
0013b4  b110              CBZ      r0,|L1.5052|
;;;1954           return 0x07;
0013b6  2007              MOVS     r0,#7
                  |L1.5048|
;;;1955   
;;;1956       tmp[0] &= 0x1F;
;;;1957       tmp[1] &= 0x1F;
;;;1958       tmp[2] &= 0x1F;
;;;1959   
;;;1960       for (jj = 0; jj < 3; jj++) {
;;;1961           st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
;;;1962           if (tmp[jj]) {
;;;1963               st_shift = 3275.f / test.gyro_sens;
;;;1964               while (--tmp[jj])
;;;1965                   st_shift *= 1.046f;
;;;1966               st_shift_var = st_shift_cust / st_shift - 1.f;
;;;1967               if (fabs(st_shift_var) > test.max_gyro_var)
;;;1968                   result |= 1 << jj;
;;;1969           } else if ((st_shift_cust < test.min_dps) ||
;;;1970               (st_shift_cust > test.max_dps))
;;;1971               result |= 1 << jj;
;;;1972       }
;;;1973       return result;
;;;1974   }
0013b8  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.5052|
0013bc  f89d0004          LDRB     r0,[sp,#4]            ;1956
0013c0  f000001f          AND      r0,r0,#0x1f           ;1956
0013c4  f88d0004          STRB     r0,[sp,#4]            ;1956
0013c8  f89d0005          LDRB     r0,[sp,#5]            ;1957
0013cc  f000001f          AND      r0,r0,#0x1f           ;1957
0013d0  f88d0005          STRB     r0,[sp,#5]            ;1957
0013d4  f89d0006          LDRB     r0,[sp,#6]            ;1958
0013d8  f000001f          AND      r0,r0,#0x1f           ;1958
0013dc  f88d0006          STRB     r0,[sp,#6]            ;1958
0013e0  2400              MOVS     r4,#0                 ;1960
0013e2  e05f              B        |L1.5284|
                  |L1.5092|
0013e4  f8560024          LDR      r0,[r6,r4,LSL #2]     ;1961
0013e8  f8571024          LDR      r1,[r7,r4,LSL #2]     ;1961
0013ec  ebb00b01          SUBS     r11,r0,r1             ;1961
0013f0  d401              BMI      |L1.5110|
0013f2  4659              MOV      r1,r11                ;1961
0013f4  e001              B        |L1.5114|
                  |L1.5110|
0013f6  f1cb0100          RSB      r1,r11,#0             ;1961
                  |L1.5114|
0013fa  4608              MOV      r0,r1                 ;1961
0013fc  f7fffffe          BL       __aeabi_i2f
001400  f04f418f          MOV      r1,#0x47800000        ;1961
001404  9000              STR      r0,[sp,#0]            ;1961
001406  f7fffffe          BL       __aeabi_fdiv
00140a  4681              MOV      r9,r0                 ;1961
00140c  a801              ADD      r0,sp,#4              ;1962
00140e  5d00              LDRB     r0,[r0,r4]            ;1962
001410  b3b8              CBZ      r0,|L1.5250|
001412  4908              LDR      r1,|L1.5172|
001414  6808              LDR      r0,[r1,#0]            ;1963  ; test
001416  f7fffffe          BL       __aeabi_ui2f
00141a  4683              MOV      r11,r0                ;1963
00141c  4601              MOV      r1,r0                 ;1963
00141e  4806              LDR      r0,|L1.5176|
001420  f7fffffe          BL       __aeabi_fdiv
001424  4680              MOV      r8,r0                 ;1963
001426  e00e              B        |L1.5190|
                  |L1.5160|
                          DCD      ||st||
                  |L1.5164|
                          DCD      0x3eae147b
                  |L1.5168|
                          DCD      0x3f845a1d
                  |L1.5172|
                          DCD      test
                  |L1.5176|
                          DCD      0x454cb000
                  |L1.5180|
00143c  49ff              LDR      r1,|L1.6204|
00143e  4640              MOV      r0,r8                 ;1965
001440  f7fffffe          BL       __aeabi_fmul
001444  4680              MOV      r8,r0                 ;1965
                  |L1.5190|
001446  a801              ADD      r0,sp,#4              ;1964
001448  5d00              LDRB     r0,[r0,r4]            ;1964
00144a  1e40              SUBS     r0,r0,#1              ;1964
00144c  f01000ff          ANDS     r0,r0,#0xff           ;1964
001450  a901              ADD      r1,sp,#4              ;1964
001452  5508              STRB     r0,[r1,r4]            ;1964
001454  d1f2              BNE      |L1.5180|
001456  4641              MOV      r1,r8                 ;1966
001458  4648              MOV      r0,r9                 ;1966
00145a  f7fffffe          BL       __aeabi_fdiv
00145e  4683              MOV      r11,r0                ;1966
001460  f04f517e          MOV      r1,#0x3f800000        ;1966
001464  f7fffffe          BL       __aeabi_fsub
001468  4682              MOV      r10,r0                ;1966
00146a  f02a4b00          BIC      r11,r10,#0x80000000   ;1967
00146e  48f4              LDR      r0,|L1.6208|
001470  6981              LDR      r1,[r0,#0x18]         ;1967  ; test
001472  4658              MOV      r0,r11                ;1967
001474  f7fffffe          BL       __aeabi_cfrcmple
001478  d213              BCS      |L1.5282|
00147a  2001              MOVS     r0,#1                 ;1968
00147c  40a0              LSLS     r0,r0,r4              ;1968
00147e  4305              ORRS     r5,r5,r0              ;1968
001480  e00f              B        |L1.5282|
                  |L1.5250|
001482  e7ff              B        |L1.5252|
                  |L1.5252|
001484  48ee              LDR      r0,|L1.6208|
001486  6901              LDR      r1,[r0,#0x10]         ;1969  ; test
001488  4648              MOV      r0,r9                 ;1969
00148a  f7fffffe          BL       __aeabi_cfcmple
00148e  d305              BCC      |L1.5276|
001490  48eb              LDR      r0,|L1.6208|
001492  6941              LDR      r1,[r0,#0x14]         ;1970  ; test
001494  4648              MOV      r0,r9                 ;1970
001496  f7fffffe          BL       __aeabi_cfrcmple
00149a  d202              BCS      |L1.5282|
                  |L1.5276|
00149c  2001              MOVS     r0,#1                 ;1971
00149e  40a0              LSLS     r0,r0,r4              ;1971
0014a0  4305              ORRS     r5,r5,r0              ;1971
                  |L1.5282|
0014a2  1c64              ADDS     r4,r4,#1              ;1960
                  |L1.5284|
0014a4  2c03              CMP      r4,#3                 ;1960
0014a6  db9d              BLT      |L1.5092|
0014a8  4628              MOV      r0,r5                 ;1973
0014aa  e785              B        |L1.5048|
;;;1975   
                          ENDP

                  get_st_biases PROC
;;;2030   
;;;2031   static int get_st_biases(long *gyro, long *accel, unsigned char hw_test)
0014ac  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;2032   {
0014b0  b092              SUB      sp,sp,#0x48
0014b2  4606              MOV      r6,r0
0014b4  460c              MOV      r4,r1
;;;2033       unsigned char data[MAX_PACKET_LENGTH];
;;;2034       unsigned char packet_count, ii;
;;;2035       unsigned short fifo_count;
;;;2036   
;;;2037       data[0] = 0x01;
0014b6  2001              MOVS     r0,#1
0014b8  f88d0020          STRB     r0,[sp,#0x20]
;;;2038       data[1] = 0;
0014bc  2000              MOVS     r0,#0
0014be  f88d0021          STRB     r0,[sp,#0x21]
;;;2039       if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
0014c2  4ae0              LDR      r2,|L1.6212|
0014c4  6812              LDR      r2,[r2,#0]  ; st
0014c6  7c91              LDRB     r1,[r2,#0x12]
0014c8  4ade              LDR      r2,|L1.6212|
0014ca  6852              LDR      r2,[r2,#4]  ; st
0014cc  7810              LDRB     r0,[r2,#0]
0014ce  ab08              ADD      r3,sp,#0x20
0014d0  2202              MOVS     r2,#2
0014d2  f7fffffe          BL       i2cWrite
0014d6  b120              CBZ      r0,|L1.5346|
;;;2040           return -1;
0014d8  f04f30ff          MOV      r0,#0xffffffff
                  |L1.5340|
;;;2041       delay_ms(200);
;;;2042       data[0] = 0;
;;;2043       if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
;;;2044           return -1;
;;;2045       if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
;;;2046           return -1;
;;;2047       if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
;;;2048           return -1;
;;;2049       if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
;;;2050           return -1;
;;;2051       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
;;;2052           return -1;
;;;2053       data[0] = BIT_FIFO_RST | BIT_DMP_RST;
;;;2054       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
;;;2055           return -1;
;;;2056       delay_ms(15);
;;;2057       data[0] = st.test->reg_lpf;
;;;2058       if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
;;;2059           return -1;
;;;2060       data[0] = st.test->reg_rate_div;
;;;2061       if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
;;;2062           return -1;
;;;2063       if (hw_test)
;;;2064           data[0] = st.test->reg_gyro_fsr | 0xE0;
;;;2065       else
;;;2066           data[0] = st.test->reg_gyro_fsr;
;;;2067       if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, data))
;;;2068           return -1;
;;;2069   
;;;2070       if (hw_test)
;;;2071           data[0] = st.test->reg_accel_fsr | 0xE0;
;;;2072       else
;;;2073           data[0] = test.reg_accel_fsr;
;;;2074       if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
;;;2075           return -1;
;;;2076       if (hw_test)
;;;2077           delay_ms(200);
;;;2078   
;;;2079       /* Fill FIFO for test.wait_ms milliseconds. */
;;;2080       data[0] = BIT_FIFO_EN;
;;;2081       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
;;;2082           return -1;
;;;2083   
;;;2084       data[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
;;;2085       if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
;;;2086           return -1;
;;;2087       delay_ms(test.wait_ms);
;;;2088       data[0] = 0;
;;;2089       if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
;;;2090           return -1;
;;;2091   
;;;2092       if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
;;;2093           return -1;
;;;2094   
;;;2095       fifo_count = (data[0] << 8) | data[1];
;;;2096       packet_count = fifo_count / MAX_PACKET_LENGTH;
;;;2097       gyro[0] = gyro[1] = gyro[2] = 0;
;;;2098       accel[0] = accel[1] = accel[2] = 0;
;;;2099   
;;;2100       for (ii = 0; ii < packet_count; ii++) {
;;;2101           short accel_cur[3], gyro_cur[3];
;;;2102           if (i2c_read(st.hw->addr, st.reg->fifo_r_w, MAX_PACKET_LENGTH, data))
;;;2103               return -1;
;;;2104           accel_cur[0] = ((short)data[0] << 8) | data[1];
;;;2105           accel_cur[1] = ((short)data[2] << 8) | data[3];
;;;2106           accel_cur[2] = ((short)data[4] << 8) | data[5];
;;;2107           accel[0] += (long)accel_cur[0];
;;;2108           accel[1] += (long)accel_cur[1];
;;;2109           accel[2] += (long)accel_cur[2];
;;;2110           gyro_cur[0] = (((short)data[6] << 8) | data[7]);
;;;2111           gyro_cur[1] = (((short)data[8] << 8) | data[9]);
;;;2112           gyro_cur[2] = (((short)data[10] << 8) | data[11]);
;;;2113           gyro[0] += (long)gyro_cur[0];
;;;2114           gyro[1] += (long)gyro_cur[1];
;;;2115           gyro[2] += (long)gyro_cur[2];
;;;2116       }
;;;2117   #ifdef EMPL_NO_64BIT
;;;2118       gyro[0] = (long)(((float)gyro[0]*65536.f) / test.gyro_sens / packet_count);
;;;2119       gyro[1] = (long)(((float)gyro[1]*65536.f) / test.gyro_sens / packet_count);
;;;2120       gyro[2] = (long)(((float)gyro[2]*65536.f) / test.gyro_sens / packet_count);
;;;2121       if (has_accel) {
;;;2122           accel[0] = (long)(((float)accel[0]*65536.f) / test.accel_sens /
;;;2123               packet_count);
;;;2124           accel[1] = (long)(((float)accel[1]*65536.f) / test.accel_sens /
;;;2125               packet_count);
;;;2126           accel[2] = (long)(((float)accel[2]*65536.f) / test.accel_sens /
;;;2127               packet_count);
;;;2128           /* Don't remove gravity! */
;;;2129           accel[2] -= 65536L;
;;;2130       }
;;;2131   #else
;;;2132       gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / packet_count);
;;;2133       gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
;;;2134       gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
;;;2135       accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
;;;2136           packet_count);
;;;2137       accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens /
;;;2138           packet_count);
;;;2139       accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens /
;;;2140           packet_count);
;;;2141       /* Don't remove gravity! */
;;;2142       if (accel[2] > 0L)
;;;2143           accel[2] -= 65536L;
;;;2144       else
;;;2145           accel[2] += 65536L;
;;;2146   #endif
;;;2147   
;;;2148       return 0;
;;;2149   }
0014dc  b015              ADD      sp,sp,#0x54
0014de  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.5346|
0014e2  20c8              MOVS     r0,#0xc8              ;2041
0014e4  f7fffffe          BL       delay_ms
0014e8  2000              MOVS     r0,#0                 ;2042
0014ea  f88d0020          STRB     r0,[sp,#0x20]         ;2042
0014ee  4ad5              LDR      r2,|L1.6212|
0014f0  6812              LDR      r2,[r2,#0]            ;2043  ; st
0014f2  7bd1              LDRB     r1,[r2,#0xf]          ;2043
0014f4  4ad3              LDR      r2,|L1.6212|
0014f6  6852              LDR      r2,[r2,#4]            ;2043  ; st
0014f8  7810              LDRB     r0,[r2,#0]            ;2043
0014fa  ab08              ADD      r3,sp,#0x20           ;2043
0014fc  2201              MOVS     r2,#1                 ;2043
0014fe  f7fffffe          BL       i2cWrite
001502  b110              CBZ      r0,|L1.5386|
001504  f04f30ff          MOV      r0,#0xffffffff        ;2044
001508  e7e8              B        |L1.5340|
                  |L1.5386|
00150a  4ace              LDR      r2,|L1.6212|
00150c  6812              LDR      r2,[r2,#0]            ;2045  ; st
00150e  7951              LDRB     r1,[r2,#5]            ;2045
001510  4acc              LDR      r2,|L1.6212|
001512  6852              LDR      r2,[r2,#4]            ;2045  ; st
001514  7810              LDRB     r0,[r2,#0]            ;2045
001516  ab08              ADD      r3,sp,#0x20           ;2045
001518  2201              MOVS     r2,#1                 ;2045
00151a  f7fffffe          BL       i2cWrite
00151e  b110              CBZ      r0,|L1.5414|
001520  f04f30ff          MOV      r0,#0xffffffff        ;2046
001524  e7da              B        |L1.5340|
                  |L1.5414|
001526  4ac7              LDR      r2,|L1.6212|
001528  6812              LDR      r2,[r2,#0]            ;2047  ; st
00152a  7c91              LDRB     r1,[r2,#0x12]         ;2047
00152c  4ac5              LDR      r2,|L1.6212|
00152e  6852              LDR      r2,[r2,#4]            ;2047  ; st
001530  7810              LDRB     r0,[r2,#0]            ;2047
001532  ab08              ADD      r3,sp,#0x20           ;2047
001534  2201              MOVS     r2,#1                 ;2047
001536  f7fffffe          BL       i2cWrite
00153a  b110              CBZ      r0,|L1.5442|
00153c  f04f30ff          MOV      r0,#0xffffffff        ;2048
001540  e7cc              B        |L1.5340|
                  |L1.5442|
001542  4ac0              LDR      r2,|L1.6212|
001544  6812              LDR      r2,[r2,#0]            ;2049  ; st
001546  7dd1              LDRB     r1,[r2,#0x17]         ;2049
001548  4abe              LDR      r2,|L1.6212|
00154a  6852              LDR      r2,[r2,#4]            ;2049  ; st
00154c  7810              LDRB     r0,[r2,#0]            ;2049
00154e  ab08              ADD      r3,sp,#0x20           ;2049
001550  2201              MOVS     r2,#1                 ;2049
001552  f7fffffe          BL       i2cWrite
001556  b110              CBZ      r0,|L1.5470|
001558  f04f30ff          MOV      r0,#0xffffffff        ;2050
00155c  e7be              B        |L1.5340|
                  |L1.5470|
00155e  4ab9              LDR      r2,|L1.6212|
001560  6812              LDR      r2,[r2,#0]            ;2051  ; st
001562  7911              LDRB     r1,[r2,#4]            ;2051
001564  4ab7              LDR      r2,|L1.6212|
001566  6852              LDR      r2,[r2,#4]            ;2051  ; st
001568  7810              LDRB     r0,[r2,#0]            ;2051
00156a  ab08              ADD      r3,sp,#0x20           ;2051
00156c  2201              MOVS     r2,#1                 ;2051
00156e  f7fffffe          BL       i2cWrite
001572  b110              CBZ      r0,|L1.5498|
001574  f04f30ff          MOV      r0,#0xffffffff        ;2052
001578  e7b0              B        |L1.5340|
                  |L1.5498|
00157a  200c              MOVS     r0,#0xc               ;2053
00157c  f88d0020          STRB     r0,[sp,#0x20]         ;2053
001580  4ab0              LDR      r2,|L1.6212|
001582  6812              LDR      r2,[r2,#0]            ;2054  ; st
001584  7911              LDRB     r1,[r2,#4]            ;2054
001586  4aaf              LDR      r2,|L1.6212|
001588  6852              LDR      r2,[r2,#4]            ;2054  ; st
00158a  7810              LDRB     r0,[r2,#0]            ;2054
00158c  ab08              ADD      r3,sp,#0x20           ;2054
00158e  2201              MOVS     r2,#1                 ;2054
001590  f7fffffe          BL       i2cWrite
001594  b110              CBZ      r0,|L1.5532|
001596  f04f30ff          MOV      r0,#0xffffffff        ;2055
00159a  e79f              B        |L1.5340|
                  |L1.5532|
00159c  200f              MOVS     r0,#0xf               ;2056
00159e  f7fffffe          BL       delay_ms
0015a2  48a8              LDR      r0,|L1.6212|
0015a4  6a80              LDR      r0,[r0,#0x28]         ;2057  ; st
0015a6  7a40              LDRB     r0,[r0,#9]            ;2057
0015a8  f88d0020          STRB     r0,[sp,#0x20]         ;2057
0015ac  4aa5              LDR      r2,|L1.6212|
0015ae  6812              LDR      r2,[r2,#0]            ;2058  ; st
0015b0  7891              LDRB     r1,[r2,#2]            ;2058
0015b2  4aa4              LDR      r2,|L1.6212|
0015b4  6852              LDR      r2,[r2,#4]            ;2058  ; st
0015b6  7810              LDRB     r0,[r2,#0]            ;2058
0015b8  ab08              ADD      r3,sp,#0x20           ;2058
0015ba  2201              MOVS     r2,#1                 ;2058
0015bc  f7fffffe          BL       i2cWrite
0015c0  b110              CBZ      r0,|L1.5576|
0015c2  f04f30ff          MOV      r0,#0xffffffff        ;2059
0015c6  e789              B        |L1.5340|
                  |L1.5576|
0015c8  489e              LDR      r0,|L1.6212|
0015ca  6a80              LDR      r0,[r0,#0x28]         ;2060  ; st
0015cc  7a00              LDRB     r0,[r0,#8]            ;2060
0015ce  f88d0020          STRB     r0,[sp,#0x20]         ;2060
0015d2  4a9c              LDR      r2,|L1.6212|
0015d4  6812              LDR      r2,[r2,#0]            ;2061  ; st
0015d6  7851              LDRB     r1,[r2,#1]            ;2061
0015d8  4a9a              LDR      r2,|L1.6212|
0015da  6852              LDR      r2,[r2,#4]            ;2061  ; st
0015dc  7810              LDRB     r0,[r2,#0]            ;2061
0015de  ab08              ADD      r3,sp,#0x20           ;2061
0015e0  2201              MOVS     r2,#1                 ;2061
0015e2  f7fffffe          BL       i2cWrite
0015e6  b110              CBZ      r0,|L1.5614|
0015e8  f04f30ff          MOV      r0,#0xffffffff        ;2062
0015ec  e776              B        |L1.5340|
                  |L1.5614|
0015ee  9814              LDR      r0,[sp,#0x50]         ;2063
0015f0  b138              CBZ      r0,|L1.5634|
0015f2  4894              LDR      r0,|L1.6212|
0015f4  6a80              LDR      r0,[r0,#0x28]         ;2064  ; st
0015f6  7a80              LDRB     r0,[r0,#0xa]          ;2064
0015f8  f04000e0          ORR      r0,r0,#0xe0           ;2064
0015fc  f88d0020          STRB     r0,[sp,#0x20]         ;2064
001600  e004              B        |L1.5644|
                  |L1.5634|
001602  4890              LDR      r0,|L1.6212|
001604  6a80              LDR      r0,[r0,#0x28]         ;2066  ; st
001606  7a80              LDRB     r0,[r0,#0xa]          ;2066
001608  f88d0020          STRB     r0,[sp,#0x20]         ;2066
                  |L1.5644|
00160c  4a8d              LDR      r2,|L1.6212|
00160e  6812              LDR      r2,[r2,#0]            ;2067  ; st
001610  7991              LDRB     r1,[r2,#6]            ;2067
001612  4a8c              LDR      r2,|L1.6212|
001614  6852              LDR      r2,[r2,#4]            ;2067  ; st
001616  7810              LDRB     r0,[r2,#0]            ;2067
001618  ab08              ADD      r3,sp,#0x20           ;2067
00161a  2201              MOVS     r2,#1                 ;2067
00161c  f7fffffe          BL       i2cWrite
001620  b110              CBZ      r0,|L1.5672|
001622  f04f30ff          MOV      r0,#0xffffffff        ;2068
001626  e759              B        |L1.5340|
                  |L1.5672|
001628  9814              LDR      r0,[sp,#0x50]         ;2070
00162a  b138              CBZ      r0,|L1.5692|
00162c  4885              LDR      r0,|L1.6212|
00162e  6a80              LDR      r0,[r0,#0x28]         ;2071  ; st
001630  7ac0              LDRB     r0,[r0,#0xb]          ;2071
001632  f04000e0          ORR      r0,r0,#0xe0           ;2071
001636  f88d0020          STRB     r0,[sp,#0x20]         ;2071
00163a  e003              B        |L1.5700|
                  |L1.5692|
00163c  4880              LDR      r0,|L1.6208|
00163e  7ac0              LDRB     r0,[r0,#0xb]          ;2073  ; test
001640  f88d0020          STRB     r0,[sp,#0x20]         ;2073
                  |L1.5700|
001644  4a7f              LDR      r2,|L1.6212|
001646  6812              LDR      r2,[r2,#0]            ;2074  ; st
001648  79d1              LDRB     r1,[r2,#7]            ;2074
00164a  4a7e              LDR      r2,|L1.6212|
00164c  6852              LDR      r2,[r2,#4]            ;2074  ; st
00164e  7810              LDRB     r0,[r2,#0]            ;2074
001650  ab08              ADD      r3,sp,#0x20           ;2074
001652  2201              MOVS     r2,#1                 ;2074
001654  f7fffffe          BL       i2cWrite
001658  b110              CBZ      r0,|L1.5728|
00165a  f04f30ff          MOV      r0,#0xffffffff        ;2075
00165e  e73d              B        |L1.5340|
                  |L1.5728|
001660  9814              LDR      r0,[sp,#0x50]         ;2076
001662  b110              CBZ      r0,|L1.5738|
001664  20c8              MOVS     r0,#0xc8              ;2077
001666  f7fffffe          BL       delay_ms
                  |L1.5738|
00166a  2040              MOVS     r0,#0x40              ;2080
00166c  f88d0020          STRB     r0,[sp,#0x20]         ;2080
001670  4a74              LDR      r2,|L1.6212|
001672  6812              LDR      r2,[r2,#0]            ;2081  ; st
001674  7911              LDRB     r1,[r2,#4]            ;2081
001676  4a73              LDR      r2,|L1.6212|
001678  6852              LDR      r2,[r2,#4]            ;2081  ; st
00167a  7810              LDRB     r0,[r2,#0]            ;2081
00167c  ab08              ADD      r3,sp,#0x20           ;2081
00167e  2201              MOVS     r2,#1                 ;2081
001680  f7fffffe          BL       i2cWrite
001684  b110              CBZ      r0,|L1.5772|
001686  f04f30ff          MOV      r0,#0xffffffff        ;2082
00168a  e727              B        |L1.5340|
                  |L1.5772|
00168c  2078              MOVS     r0,#0x78              ;2084
00168e  f88d0020          STRB     r0,[sp,#0x20]         ;2084
001692  4a6c              LDR      r2,|L1.6212|
001694  6812              LDR      r2,[r2,#0]            ;2085  ; st
001696  7951              LDRB     r1,[r2,#5]            ;2085
001698  4a6a              LDR      r2,|L1.6212|
00169a  6852              LDR      r2,[r2,#4]            ;2085  ; st
00169c  7810              LDRB     r0,[r2,#0]            ;2085
00169e  ab08              ADD      r3,sp,#0x20           ;2085
0016a0  2201              MOVS     r2,#1                 ;2085
0016a2  f7fffffe          BL       i2cWrite
0016a6  b110              CBZ      r0,|L1.5806|
0016a8  f04f30ff          MOV      r0,#0xffffffff        ;2086
0016ac  e716              B        |L1.5340|
                  |L1.5806|
0016ae  4964              LDR      r1,|L1.6208|
0016b0  8988              LDRH     r0,[r1,#0xc]          ;2087  ; test
0016b2  f7fffffe          BL       delay_ms
0016b6  2000              MOVS     r0,#0                 ;2088
0016b8  f88d0020          STRB     r0,[sp,#0x20]         ;2088
0016bc  4a61              LDR      r2,|L1.6212|
0016be  6812              LDR      r2,[r2,#0]            ;2089  ; st
0016c0  7951              LDRB     r1,[r2,#5]            ;2089
0016c2  4a60              LDR      r2,|L1.6212|
0016c4  6852              LDR      r2,[r2,#4]            ;2089  ; st
0016c6  7810              LDRB     r0,[r2,#0]            ;2089
0016c8  ab08              ADD      r3,sp,#0x20           ;2089
0016ca  2201              MOVS     r2,#1                 ;2089
0016cc  f7fffffe          BL       i2cWrite
0016d0  b110              CBZ      r0,|L1.5848|
0016d2  f04f30ff          MOV      r0,#0xffffffff        ;2090
0016d6  e701              B        |L1.5340|
                  |L1.5848|
0016d8  4a5a              LDR      r2,|L1.6212|
0016da  6812              LDR      r2,[r2,#0]            ;2092  ; st
0016dc  7a91              LDRB     r1,[r2,#0xa]          ;2092
0016de  4a59              LDR      r2,|L1.6212|
0016e0  6852              LDR      r2,[r2,#4]            ;2092  ; st
0016e2  7810              LDRB     r0,[r2,#0]            ;2092
0016e4  ab08              ADD      r3,sp,#0x20           ;2092
0016e6  2202              MOVS     r2,#2                 ;2092
0016e8  f7fffffe          BL       i2cRead
0016ec  b110              CBZ      r0,|L1.5876|
0016ee  f04f30ff          MOV      r0,#0xffffffff        ;2093
0016f2  e6f3              B        |L1.5340|
                  |L1.5876|
0016f4  f89d0021          LDRB     r0,[sp,#0x21]         ;2095
0016f8  f89d1020          LDRB     r1,[sp,#0x20]         ;2095
0016fc  ea402001          ORR      r0,r0,r1,LSL #8       ;2095
001700  9006              STR      r0,[sp,#0x18]         ;2095
001702  210c              MOVS     r1,#0xc               ;2096
001704  9806              LDR      r0,[sp,#0x18]         ;2096
001706  fb90f0f1          SDIV     r0,r0,r1              ;2096
00170a  b2c5              UXTB     r5,r0                 ;2096
00170c  2000              MOVS     r0,#0                 ;2097
00170e  60b0              STR      r0,[r6,#8]            ;2097
001710  6070              STR      r0,[r6,#4]            ;2097
001712  6030              STR      r0,[r6,#0]            ;2097
001714  60a0              STR      r0,[r4,#8]            ;2098
001716  6060              STR      r0,[r4,#4]            ;2098
001718  6020              STR      r0,[r4,#0]            ;2098
00171a  9007              STR      r0,[sp,#0x1c]         ;2100
00171c  e065              B        |L1.6122|
                  |L1.5918|
00171e  4a49              LDR      r2,|L1.6212|
001720  6812              LDR      r2,[r2,#0]            ;2102  ; st
001722  7ad1              LDRB     r1,[r2,#0xb]          ;2102
001724  4a47              LDR      r2,|L1.6212|
001726  6852              LDR      r2,[r2,#4]            ;2102  ; st
001728  7810              LDRB     r0,[r2,#0]            ;2102
00172a  ab08              ADD      r3,sp,#0x20           ;2102
00172c  220c              MOVS     r2,#0xc               ;2102
00172e  f7fffffe          BL       i2cRead
001732  b110              CBZ      r0,|L1.5946|
001734  f04f30ff          MOV      r0,#0xffffffff        ;2103
001738  e6d0              B        |L1.5340|
                  |L1.5946|
00173a  f89d0021          LDRB     r0,[sp,#0x21]         ;2104
00173e  f89d1020          LDRB     r1,[sp,#0x20]         ;2104
001742  ea402001          ORR      r0,r0,r1,LSL #8       ;2104
001746  b200              SXTH     r0,r0                 ;2104
001748  f8ad0010          STRH     r0,[sp,#0x10]         ;2104
00174c  f89d0023          LDRB     r0,[sp,#0x23]         ;2105
001750  f89d1022          LDRB     r1,[sp,#0x22]         ;2105
001754  ea402001          ORR      r0,r0,r1,LSL #8       ;2105
001758  b200              SXTH     r0,r0                 ;2105
00175a  f8ad0012          STRH     r0,[sp,#0x12]         ;2105
00175e  f89d0025          LDRB     r0,[sp,#0x25]         ;2106
001762  f89d1024          LDRB     r1,[sp,#0x24]         ;2106
001766  ea402001          ORR      r0,r0,r1,LSL #8       ;2106
00176a  b200              SXTH     r0,r0                 ;2106
00176c  f8ad0014          STRH     r0,[sp,#0x14]         ;2106
001770  f9bd1010          LDRSH    r1,[sp,#0x10]         ;2107
001774  6820              LDR      r0,[r4,#0]            ;2107
001776  4408              ADD      r0,r0,r1              ;2107
001778  6020              STR      r0,[r4,#0]            ;2107
00177a  f9bd1012          LDRSH    r1,[sp,#0x12]         ;2108
00177e  6860              LDR      r0,[r4,#4]            ;2108
001780  4408              ADD      r0,r0,r1              ;2108
001782  6060              STR      r0,[r4,#4]            ;2108
001784  f9bd1014          LDRSH    r1,[sp,#0x14]         ;2109
001788  68a0              LDR      r0,[r4,#8]            ;2109
00178a  4408              ADD      r0,r0,r1              ;2109
00178c  60a0              STR      r0,[r4,#8]            ;2109
00178e  f89d0027          LDRB     r0,[sp,#0x27]         ;2110
001792  f89d1026          LDRB     r1,[sp,#0x26]         ;2110
001796  ea402001          ORR      r0,r0,r1,LSL #8       ;2110
00179a  b200              SXTH     r0,r0                 ;2110
00179c  f8ad0008          STRH     r0,[sp,#8]            ;2110
0017a0  f89d0029          LDRB     r0,[sp,#0x29]         ;2111
0017a4  f89d1028          LDRB     r1,[sp,#0x28]         ;2111
0017a8  ea402001          ORR      r0,r0,r1,LSL #8       ;2111
0017ac  b200              SXTH     r0,r0                 ;2111
0017ae  f8ad000a          STRH     r0,[sp,#0xa]          ;2111
0017b2  f89d002b          LDRB     r0,[sp,#0x2b]         ;2112
0017b6  f89d102a          LDRB     r1,[sp,#0x2a]         ;2112
0017ba  ea402001          ORR      r0,r0,r1,LSL #8       ;2112
0017be  b200              SXTH     r0,r0                 ;2112
0017c0  f8ad000c          STRH     r0,[sp,#0xc]          ;2112
0017c4  f9bd1008          LDRSH    r1,[sp,#8]            ;2113
0017c8  6830              LDR      r0,[r6,#0]            ;2113
0017ca  4408              ADD      r0,r0,r1              ;2113
0017cc  6030              STR      r0,[r6,#0]            ;2113
0017ce  f9bd100a          LDRSH    r1,[sp,#0xa]          ;2114
0017d2  6870              LDR      r0,[r6,#4]            ;2114
0017d4  4408              ADD      r0,r0,r1              ;2114
0017d6  6070              STR      r0,[r6,#4]            ;2114
0017d8  f9bd100c          LDRSH    r1,[sp,#0xc]          ;2115
0017dc  68b0              LDR      r0,[r6,#8]            ;2115
0017de  4408              ADD      r0,r0,r1              ;2115
0017e0  60b0              STR      r0,[r6,#8]            ;2115
0017e2  9807              LDR      r0,[sp,#0x1c]         ;2100
0017e4  1c40              ADDS     r0,r0,#1              ;2100
0017e6  b2c0              UXTB     r0,r0                 ;2100
0017e8  9007              STR      r0,[sp,#0x1c]         ;2100
                  |L1.6122|
0017ea  9807              LDR      r0,[sp,#0x1c]         ;2100
0017ec  42a8              CMP      r0,r5                 ;2100
0017ee  db96              BLT      |L1.5918|
0017f0  4813              LDR      r0,|L1.6208|
0017f2  6800              LDR      r0,[r0,#0]            ;2132  ; test
0017f4  9003              STR      r0,[sp,#0xc]          ;2132
0017f6  6837              LDR      r7,[r6,#0]            ;2132
0017f8  17f8              ASRS     r0,r7,#31             ;2132
0017fa  2210              MOVS     r2,#0x10              ;2132
0017fc  9011              STR      r0,[sp,#0x44]         ;2132
0017fe  4638              MOV      r0,r7                 ;2132
001800  9911              LDR      r1,[sp,#0x44]         ;2132
001802  f7fffffe          BL       __aeabi_llsl
001806  e9cd0100          STRD     r0,r1,[sp,#0]         ;2132
00180a  2300              MOVS     r3,#0                 ;2132
00180c  9a03              LDR      r2,[sp,#0xc]          ;2132
00180e  f7fffffe          BL       __aeabi_ldivmod
001812  462a              MOV      r2,r5                 ;2132
001814  2300              MOVS     r3,#0                 ;2132
001816  e9cd0104          STRD     r0,r1,[sp,#0x10]      ;2132
00181a  f7fffffe          BL       __aeabi_ldivmod
00181e  6030              STR      r0,[r6,#0]            ;2132
001820  4807              LDR      r0,|L1.6208|
001822  6800              LDR      r0,[r0,#0]            ;2133  ; test
001824  9003              STR      r0,[sp,#0xc]          ;2133
001826  f8d68004          LDR      r8,[r6,#4]            ;2133
00182a  ea4f70e8          ASR      r0,r8,#31             ;2133
00182e  2210              MOVS     r2,#0x10              ;2133
001830  9010              STR      r0,[sp,#0x40]         ;2133
001832  4640              MOV      r0,r8                 ;2133
001834  9910              LDR      r1,[sp,#0x40]         ;2133
001836  f7fffffe          BL       __aeabi_llsl
00183a  e005              B        |L1.6216|
                  |L1.6204|
                          DCD      0x3f85e354
                  |L1.6208|
                          DCD      test
                  |L1.6212|
                          DCD      ||st||
                  |L1.6216|
001848  e9cd0100          STRD     r0,r1,[sp,#0]         ;2133
00184c  2300              MOVS     r3,#0                 ;2133
00184e  9a03              LDR      r2,[sp,#0xc]          ;2133
001850  f7fffffe          BL       __aeabi_ldivmod
001854  462a              MOV      r2,r5                 ;2133
001856  2300              MOVS     r3,#0                 ;2133
001858  e9cd0104          STRD     r0,r1,[sp,#0x10]      ;2133
00185c  f7fffffe          BL       __aeabi_ldivmod
001860  6070              STR      r0,[r6,#4]            ;2133
001862  48fa              LDR      r0,|L1.7244|
001864  6800              LDR      r0,[r0,#0]            ;2134  ; test
001866  9003              STR      r0,[sp,#0xc]          ;2134
001868  f8d69008          LDR      r9,[r6,#8]            ;2134
00186c  ea4f70e9          ASR      r0,r9,#31             ;2134
001870  2210              MOVS     r2,#0x10              ;2134
001872  900f              STR      r0,[sp,#0x3c]         ;2134
001874  4648              MOV      r0,r9                 ;2134
001876  990f              LDR      r1,[sp,#0x3c]         ;2134
001878  f7fffffe          BL       __aeabi_llsl
00187c  e9cd0100          STRD     r0,r1,[sp,#0]         ;2134
001880  2300              MOVS     r3,#0                 ;2134
001882  9a03              LDR      r2,[sp,#0xc]          ;2134
001884  f7fffffe          BL       __aeabi_ldivmod
001888  462a              MOV      r2,r5                 ;2134
00188a  2300              MOVS     r3,#0                 ;2134
00188c  e9cd0104          STRD     r0,r1,[sp,#0x10]      ;2134
001890  f7fffffe          BL       __aeabi_ldivmod
001894  60b0              STR      r0,[r6,#8]            ;2134
001896  48ed              LDR      r0,|L1.7244|
001898  6840              LDR      r0,[r0,#4]            ;2135  ; test
00189a  9003              STR      r0,[sp,#0xc]          ;2135
00189c  f8d4a000          LDR      r10,[r4,#0]           ;2135
0018a0  ea4f70ea          ASR      r0,r10,#31            ;2135
0018a4  2210              MOVS     r2,#0x10              ;2135
0018a6  900e              STR      r0,[sp,#0x38]         ;2135
0018a8  4650              MOV      r0,r10                ;2135
0018aa  990e              LDR      r1,[sp,#0x38]         ;2135
0018ac  f7fffffe          BL       __aeabi_llsl
0018b0  e9cd0100          STRD     r0,r1,[sp,#0]         ;2135
0018b4  2300              MOVS     r3,#0                 ;2135
0018b6  9a03              LDR      r2,[sp,#0xc]          ;2135
0018b8  f7fffffe          BL       __aeabi_ldivmod
0018bc  462a              MOV      r2,r5                 ;2135
0018be  2300              MOVS     r3,#0                 ;2135
0018c0  e9cd0104          STRD     r0,r1,[sp,#0x10]      ;2135
0018c4  f7fffffe          BL       __aeabi_ldivmod
0018c8  6020              STR      r0,[r4,#0]            ;2135
0018ca  48e0              LDR      r0,|L1.7244|
0018cc  6840              LDR      r0,[r0,#4]            ;2137  ; test
0018ce  9003              STR      r0,[sp,#0xc]          ;2137
0018d0  f8d4b004          LDR      r11,[r4,#4]           ;2137
0018d4  ea4f70eb          ASR      r0,r11,#31            ;2137
0018d8  2210              MOVS     r2,#0x10              ;2137
0018da  900d              STR      r0,[sp,#0x34]         ;2137
0018dc  4658              MOV      r0,r11                ;2137
0018de  990d              LDR      r1,[sp,#0x34]         ;2137
0018e0  f7fffffe          BL       __aeabi_llsl
0018e4  e9cd0100          STRD     r0,r1,[sp,#0]         ;2137
0018e8  2300              MOVS     r3,#0                 ;2137
0018ea  9a03              LDR      r2,[sp,#0xc]          ;2137
0018ec  f7fffffe          BL       __aeabi_ldivmod
0018f0  462a              MOV      r2,r5                 ;2137
0018f2  2300              MOVS     r3,#0                 ;2137
0018f4  e9cd0104          STRD     r0,r1,[sp,#0x10]      ;2137
0018f8  f7fffffe          BL       __aeabi_ldivmod
0018fc  6060              STR      r0,[r4,#4]            ;2137
0018fe  48d3              LDR      r0,|L1.7244|
001900  6840              LDR      r0,[r0,#4]            ;2139  ; test
001902  9003              STR      r0,[sp,#0xc]          ;2139
001904  68a0              LDR      r0,[r4,#8]            ;2139
001906  17c1              ASRS     r1,r0,#31             ;2139
001908  2210              MOVS     r2,#0x10              ;2139
00190a  e9cd100b          STRD     r1,r0,[sp,#0x2c]      ;2139
00190e  f7fffffe          BL       __aeabi_llsl
001912  e9cd0100          STRD     r0,r1,[sp,#0]         ;2139
001916  2300              MOVS     r3,#0                 ;2139
001918  9a03              LDR      r2,[sp,#0xc]          ;2139
00191a  f7fffffe          BL       __aeabi_ldivmod
00191e  462a              MOV      r2,r5                 ;2139
001920  2300              MOVS     r3,#0                 ;2139
001922  e9cd0104          STRD     r0,r1,[sp,#0x10]      ;2139
001926  f7fffffe          BL       __aeabi_ldivmod
00192a  60a0              STR      r0,[r4,#8]            ;2139
00192c  68a0              LDR      r0,[r4,#8]            ;2142
00192e  2800              CMP      r0,#0                 ;2142
001930  dd04              BLE      |L1.6460|
001932  68a0              LDR      r0,[r4,#8]            ;2143
001934  f5a03080          SUB      r0,r0,#0x10000        ;2143
001938  60a0              STR      r0,[r4,#8]            ;2143
00193a  e003              B        |L1.6468|
                  |L1.6460|
00193c  68a0              LDR      r0,[r4,#8]            ;2145
00193e  f5003080          ADD      r0,r0,#0x10000        ;2145
001942  60a0              STR      r0,[r4,#8]            ;2145
                  |L1.6468|
001944  2000              MOVS     r0,#0                 ;2148
001946  e5c9              B        |L1.5340|
;;;2150   
                          ENDP

                  mpu_set_dmp_state PROC
;;;2378    */
;;;2379   int mpu_set_dmp_state(unsigned char enable)
001948  b538              PUSH     {r3-r5,lr}
;;;2380   {
00194a  4604              MOV      r4,r0
;;;2381       unsigned char tmp;
;;;2382       if (st.chip_cfg.dmp_on == enable)
00194c  48c0              LDR      r0,|L1.7248|
00194e  f8900024          LDRB     r0,[r0,#0x24]
001952  42a0              CMP      r0,r4
001954  d101              BNE      |L1.6490|
;;;2383           return 0;
001956  2000              MOVS     r0,#0
                  |L1.6488|
;;;2384   
;;;2385       if (enable) {
;;;2386           if (!st.chip_cfg.dmp_loaded)
;;;2387               return -1;
;;;2388           /* Disable data ready interrupt. */
;;;2389           set_int_enable(0);
;;;2390           /* Disable bypass mode. */
;;;2391           mpu_set_bypass(0);
;;;2392           /* Keep constant sample rate, FIFO rate controlled by DMP. */
;;;2393           mpu_set_sample_rate(st.chip_cfg.dmp_sample_rate);
;;;2394           /* Remove FIFO elements. */
;;;2395           tmp = 0;
;;;2396           i2c_write(st.hw->addr, 0x23, 1, &tmp);
;;;2397           st.chip_cfg.dmp_on = 1;
;;;2398           /* Enable DMP interrupt. */
;;;2399           set_int_enable(1);
;;;2400           mpu_reset_fifo();
;;;2401       } else {
;;;2402           /* Disable DMP interrupt. */
;;;2403           set_int_enable(0);
;;;2404           /* Restore FIFO settings. */
;;;2405           tmp = st.chip_cfg.fifo_enable;
;;;2406           i2c_write(st.hw->addr, 0x23, 1, &tmp);
;;;2407           st.chip_cfg.dmp_on = 0;
;;;2408           mpu_reset_fifo();
;;;2409       }
;;;2410       return 0;
;;;2411   }
001958  bd38              POP      {r3-r5,pc}
                  |L1.6490|
00195a  b324              CBZ      r4,|L1.6566|
00195c  48bc              LDR      r0,|L1.7248|
00195e  f8900025          LDRB     r0,[r0,#0x25]         ;2386
001962  b910              CBNZ     r0,|L1.6506|
001964  f04f30ff          MOV      r0,#0xffffffff        ;2387
001968  e7f6              B        |L1.6488|
                  |L1.6506|
00196a  2000              MOVS     r0,#0                 ;2389
00196c  f7fffffe          BL       set_int_enable
001970  2000              MOVS     r0,#0                 ;2391
001972  f7fffffe          BL       mpu_set_bypass
001976  49b6              LDR      r1,|L1.7248|
001978  8cc8              LDRH     r0,[r1,#0x26]         ;2393
00197a  f7fffffe          BL       mpu_set_sample_rate
00197e  2000              MOVS     r0,#0                 ;2395
001980  9000              STR      r0,[sp,#0]            ;2395
001982  49b3              LDR      r1,|L1.7248|
001984  6849              LDR      r1,[r1,#4]            ;2396  ; st
001986  7808              LDRB     r0,[r1,#0]            ;2396
001988  466b              MOV      r3,sp                 ;2396
00198a  2201              MOVS     r2,#1                 ;2396
00198c  2123              MOVS     r1,#0x23              ;2396
00198e  f7fffffe          BL       i2cWrite
001992  2101              MOVS     r1,#1                 ;2397
001994  48ae              LDR      r0,|L1.7248|
001996  f8801024          STRB     r1,[r0,#0x24]         ;2397
00199a  2001              MOVS     r0,#1                 ;2399
00199c  f7fffffe          BL       set_int_enable
0019a0  f7fffffe          BL       mpu_reset_fifo
0019a4  e013              B        |L1.6606|
                  |L1.6566|
0019a6  2000              MOVS     r0,#0                 ;2403
0019a8  f7fffffe          BL       set_int_enable
0019ac  48a8              LDR      r0,|L1.7248|
0019ae  7c00              LDRB     r0,[r0,#0x10]         ;2405
0019b0  9000              STR      r0,[sp,#0]            ;2405
0019b2  49a7              LDR      r1,|L1.7248|
0019b4  6849              LDR      r1,[r1,#4]            ;2406  ; st
0019b6  7808              LDRB     r0,[r1,#0]            ;2406
0019b8  466b              MOV      r3,sp                 ;2406
0019ba  2201              MOVS     r2,#1                 ;2406
0019bc  2123              MOVS     r1,#0x23              ;2406
0019be  f7fffffe          BL       i2cWrite
0019c2  2100              MOVS     r1,#0                 ;2407
0019c4  48a2              LDR      r0,|L1.7248|
0019c6  f8801024          STRB     r1,[r0,#0x24]         ;2407
0019ca  f7fffffe          BL       mpu_reset_fifo
                  |L1.6606|
0019ce  2000              MOVS     r0,#0                 ;2410
0019d0  e7c2              B        |L1.6488|
;;;2412   
                          ENDP

                  mpu_run_self_test PROC
;;;2170    */
;;;2171   int mpu_run_self_test(long *gyro, long *accel)
0019d2  e92d4ff0          PUSH     {r4-r11,lr}
;;;2172   {
0019d6  b08d              SUB      sp,sp,#0x34
0019d8  4683              MOV      r11,r0
0019da  460f              MOV      r7,r1
;;;2173   #ifdef MPU6050
;;;2174       const unsigned char tries = 2;
0019dc  2002              MOVS     r0,#2
0019de  900c              STR      r0,[sp,#0x30]
;;;2175       long gyro_st[3], accel_st[3];
;;;2176       unsigned char accel_result, gyro_result;
;;;2177   #ifdef AK89xx_SECONDARY
;;;2178       unsigned char compass_result;
;;;2179   #endif
;;;2180       int ii;
;;;2181   #endif
;;;2182       int result;
;;;2183       unsigned char accel_fsr, fifo_sensors, sensors_on;
;;;2184       unsigned short gyro_fsr, sample_rate, lpf;
;;;2185       unsigned char dmp_was_on;
;;;2186   
;;;2187       if (st.chip_cfg.dmp_on) {
0019e0  489b              LDR      r0,|L1.7248|
0019e2  f8900024          LDRB     r0,[r0,#0x24]
0019e6  b120              CBZ      r0,|L1.6642|
;;;2188           mpu_set_dmp_state(0);
0019e8  2000              MOVS     r0,#0
0019ea  f7fffffe          BL       mpu_set_dmp_state
;;;2189           dmp_was_on = 1;
0019ee  2601              MOVS     r6,#1
0019f0  e000              B        |L1.6644|
                  |L1.6642|
;;;2190       } else
;;;2191           dmp_was_on = 0;
0019f2  2600              MOVS     r6,#0
                  |L1.6644|
;;;2192   
;;;2193       /* Get initial settings. */
;;;2194       mpu_get_gyro_fsr(&gyro_fsr);
0019f4  a803              ADD      r0,sp,#0xc
0019f6  f7fffffe          BL       mpu_get_gyro_fsr
;;;2195       mpu_get_accel_fsr(&accel_fsr);
0019fa  a805              ADD      r0,sp,#0x14
0019fc  f7fffffe          BL       mpu_get_accel_fsr
;;;2196       mpu_get_lpf(&lpf);
001a00  a801              ADD      r0,sp,#4
001a02  f7fffffe          BL       mpu_get_lpf
;;;2197       mpu_get_sample_rate(&sample_rate);
001a06  a802              ADD      r0,sp,#8
001a08  f7fffffe          BL       mpu_get_sample_rate
;;;2198       sensors_on = st.chip_cfg.sensors;
001a0c  4890              LDR      r0,|L1.7248|
001a0e  f890a00a          LDRB     r10,[r0,#0xa]
;;;2199       mpu_get_fifo_config(&fifo_sensors);
001a12  a804              ADD      r0,sp,#0x10
001a14  f7fffffe          BL       mpu_get_fifo_config
;;;2200   
;;;2201       /* For older chips, the self-test will be different. */
;;;2202   #if defined MPU6050
;;;2203       for (ii = 0; ii < tries; ii++)
001a18  2400              MOVS     r4,#0
001a1a  e007              B        |L1.6700|
                  |L1.6684|
;;;2204           if (!get_st_biases(gyro, accel, 0))
001a1c  2200              MOVS     r2,#0
001a1e  4639              MOV      r1,r7
001a20  4658              MOV      r0,r11
001a22  f7fffffe          BL       get_st_biases
001a26  b900              CBNZ     r0,|L1.6698|
;;;2205               break;
001a28  e002              B        |L1.6704|
                  |L1.6698|
001a2a  1c64              ADDS     r4,r4,#1              ;2203
                  |L1.6700|
001a2c  2c02              CMP      r4,#2                 ;2203
001a2e  dbf5              BLT      |L1.6684|
                  |L1.6704|
001a30  bf00              NOP      
;;;2206       if (ii == tries) {
001a32  2c02              CMP      r4,#2
001a34  d101              BNE      |L1.6714|
;;;2207           /* If we reach this point, we most likely encountered an I2C error.
;;;2208            * We'll just report an error for all three sensors.
;;;2209            */
;;;2210           result = 0;
001a36  2500              MOVS     r5,#0
;;;2211           goto restore;
001a38  e028              B        |L1.6796|
                  |L1.6714|
;;;2212       }
;;;2213       for (ii = 0; ii < tries; ii++)
001a3a  2400              MOVS     r4,#0
001a3c  e007              B        |L1.6734|
                  |L1.6718|
;;;2214           if (!get_st_biases(gyro_st, accel_st, 1))
001a3e  2201              MOVS     r2,#1
001a40  a906              ADD      r1,sp,#0x18
001a42  a809              ADD      r0,sp,#0x24
001a44  f7fffffe          BL       get_st_biases
001a48  b900              CBNZ     r0,|L1.6732|
;;;2215               break;
001a4a  e002              B        |L1.6738|
                  |L1.6732|
001a4c  1c64              ADDS     r4,r4,#1              ;2213
                  |L1.6734|
001a4e  2c02              CMP      r4,#2                 ;2213
001a50  dbf5              BLT      |L1.6718|
                  |L1.6738|
001a52  bf00              NOP      
;;;2216       if (ii == tries) {
001a54  2c02              CMP      r4,#2
001a56  d101              BNE      |L1.6748|
;;;2217           /* Again, probably an I2C error. */
;;;2218           result = 0;
001a58  2500              MOVS     r5,#0
;;;2219           goto restore;
001a5a  e017              B        |L1.6796|
                  |L1.6748|
;;;2220       }
;;;2221       accel_result = accel_self_test(accel, accel_st);
001a5c  a906              ADD      r1,sp,#0x18
001a5e  4638              MOV      r0,r7
001a60  f7fffffe          BL       accel_self_test
001a64  f00008ff          AND      r8,r0,#0xff
;;;2222       gyro_result = gyro_self_test(gyro, gyro_st);
001a68  a909              ADD      r1,sp,#0x24
001a6a  4658              MOV      r0,r11
001a6c  f7fffffe          BL       gyro_self_test
001a70  f00009ff          AND      r9,r0,#0xff
;;;2223   
;;;2224       result = 0;
001a74  2500              MOVS     r5,#0
;;;2225       if (!gyro_result)
001a76  f1b90f00          CMP      r9,#0
001a7a  d101              BNE      |L1.6784|
;;;2226           result |= 0x01;
001a7c  f0450501          ORR      r5,r5,#1
                  |L1.6784|
;;;2227       if (!accel_result)
001a80  f1b80f00          CMP      r8,#0
001a84  d101              BNE      |L1.6794|
;;;2228           result |= 0x02;
001a86  f0450502          ORR      r5,r5,#2
                  |L1.6794|
;;;2229   
;;;2230   #ifdef AK89xx_SECONDARY
;;;2231       compass_result = compass_self_test();
;;;2232       if (!compass_result)
;;;2233           result |= 0x04;
;;;2234   #endif
;;;2235   restore:
001a8a  bf00              NOP      
                  |L1.6796|
;;;2236   #elif defined MPU6500
;;;2237       /* For now, this function will return a "pass" result for all three sensors
;;;2238        * for compatibility with current test applications.
;;;2239        */
;;;2240       get_st_biases(gyro, accel, 0);
;;;2241       result = 0x7;
;;;2242   #endif
;;;2243       /* Set to invalid values to ensure no I2C writes are skipped. */
;;;2244       st.chip_cfg.gyro_fsr = 0xFF;
001a8c  20ff              MOVS     r0,#0xff
001a8e  4970              LDR      r1,|L1.7248|
001a90  7208              STRB     r0,[r1,#8]
;;;2245       st.chip_cfg.accel_fsr = 0xFF;
001a92  21ff              MOVS     r1,#0xff
001a94  486e              LDR      r0,|L1.7248|
001a96  7241              STRB     r1,[r0,#9]
;;;2246       st.chip_cfg.lpf = 0xFF;
001a98  72c1              STRB     r1,[r0,#0xb]
;;;2247       st.chip_cfg.sample_rate = 0xFFFF;
001a9a  f64f71ff          MOV      r1,#0xffff
001a9e  81c1              STRH     r1,[r0,#0xe]
;;;2248       st.chip_cfg.sensors = 0xFF;
001aa0  21ff              MOVS     r1,#0xff
001aa2  7281              STRB     r1,[r0,#0xa]
;;;2249       st.chip_cfg.fifo_enable = 0xFF;
001aa4  7401              STRB     r1,[r0,#0x10]
;;;2250       st.chip_cfg.clk_src = INV_CLK_PLL;
001aa6  2101              MOVS     r1,#1
001aa8  7301              STRB     r1,[r0,#0xc]
;;;2251       mpu_set_gyro_fsr(gyro_fsr);
001aaa  f8bd000c          LDRH     r0,[sp,#0xc]
001aae  f7fffffe          BL       mpu_set_gyro_fsr
;;;2252       mpu_set_accel_fsr(accel_fsr);
001ab2  f89d0014          LDRB     r0,[sp,#0x14]
001ab6  f7fffffe          BL       mpu_set_accel_fsr
;;;2253       mpu_set_lpf(lpf);
001aba  f8bd0004          LDRH     r0,[sp,#4]
001abe  f7fffffe          BL       mpu_set_lpf
;;;2254       mpu_set_sample_rate(sample_rate);
001ac2  f8bd0008          LDRH     r0,[sp,#8]
001ac6  f7fffffe          BL       mpu_set_sample_rate
;;;2255       mpu_set_sensors(sensors_on);
001aca  4650              MOV      r0,r10
001acc  f7fffffe          BL       mpu_set_sensors
;;;2256       mpu_configure_fifo(fifo_sensors);
001ad0  f89d0010          LDRB     r0,[sp,#0x10]
001ad4  f7fffffe          BL       mpu_configure_fifo
;;;2257   
;;;2258       if (dmp_was_on)
001ad8  b116              CBZ      r6,|L1.6880|
;;;2259           mpu_set_dmp_state(1);
001ada  2001              MOVS     r0,#1
001adc  f7fffffe          BL       mpu_set_dmp_state
                  |L1.6880|
;;;2260   
;;;2261       return result;
001ae0  4628              MOV      r0,r5
;;;2262   }
001ae2  b00d              ADD      sp,sp,#0x34
001ae4  e8bd8ff0          POP      {r4-r11,pc}
;;;2263   
                          ENDP

                  mpu_write_mem PROC
;;;2272    */
;;;2273   int mpu_write_mem(unsigned short mem_addr, unsigned short length,
001ae8  b5f8              PUSH     {r3-r7,lr}
;;;2274           unsigned char *data)
;;;2275   {
001aea  4604              MOV      r4,r0
001aec  460d              MOV      r5,r1
001aee  4616              MOV      r6,r2
;;;2276       unsigned char tmp[2];
;;;2277   
;;;2278       if (!data)
001af0  b916              CBNZ     r6,|L1.6904|
;;;2279           return -1;
001af2  f04f30ff          MOV      r0,#0xffffffff
                  |L1.6902|
;;;2280       if (!st.chip_cfg.sensors)
;;;2281           return -1;
;;;2282   
;;;2283       tmp[0] = (unsigned char)(mem_addr >> 8);
;;;2284       tmp[1] = (unsigned char)(mem_addr & 0xFF);
;;;2285   
;;;2286       /* Check bank boundaries. */
;;;2287       if (tmp[1] + length > st.hw->bank_size)
;;;2288           return -1;
;;;2289   
;;;2290       if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
;;;2291           return -1;
;;;2292       if (i2c_write(st.hw->addr, st.reg->mem_r_w, length, data))
;;;2293           return -1;
;;;2294       return 0;
;;;2295   }
001af6  bdf8              POP      {r3-r7,pc}
                  |L1.6904|
001af8  4855              LDR      r0,|L1.7248|
001afa  7a80              LDRB     r0,[r0,#0xa]          ;2280
001afc  b910              CBNZ     r0,|L1.6916|
001afe  f04f30ff          MOV      r0,#0xffffffff        ;2281
001b02  e7f8              B        |L1.6902|
                  |L1.6916|
001b04  1220              ASRS     r0,r4,#8              ;2283
001b06  f88d0000          STRB     r0,[sp,#0]            ;2283
001b0a  b2e0              UXTB     r0,r4                 ;2284
001b0c  f88d0001          STRB     r0,[sp,#1]            ;2284
001b10  f89d0001          LDRB     r0,[sp,#1]            ;2287
001b14  4428              ADD      r0,r0,r5              ;2287
001b16  494e              LDR      r1,|L1.7248|
001b18  6849              LDR      r1,[r1,#4]            ;2287  ; st
001b1a  8949              LDRH     r1,[r1,#0xa]          ;2287
001b1c  4288              CMP      r0,r1                 ;2287
001b1e  dd02              BLE      |L1.6950|
001b20  f04f30ff          MOV      r0,#0xffffffff        ;2288
001b24  e7e7              B        |L1.6902|
                  |L1.6950|
001b26  4a4a              LDR      r2,|L1.7248|
001b28  6812              LDR      r2,[r2,#0]            ;2290  ; st
001b2a  7e11              LDRB     r1,[r2,#0x18]         ;2290
001b2c  4a48              LDR      r2,|L1.7248|
001b2e  6852              LDR      r2,[r2,#4]            ;2290  ; st
001b30  7810              LDRB     r0,[r2,#0]            ;2290
001b32  466b              MOV      r3,sp                 ;2290
001b34  2202              MOVS     r2,#2                 ;2290
001b36  f7fffffe          BL       i2cWrite
001b3a  b110              CBZ      r0,|L1.6978|
001b3c  f04f30ff          MOV      r0,#0xffffffff        ;2291
001b40  e7d9              B        |L1.6902|
                  |L1.6978|
001b42  4a43              LDR      r2,|L1.7248|
001b44  6812              LDR      r2,[r2,#0]            ;2292  ; st
001b46  7d51              LDRB     r1,[r2,#0x15]         ;2292
001b48  4a41              LDR      r2,|L1.7248|
001b4a  6852              LDR      r2,[r2,#4]            ;2292  ; st
001b4c  7810              LDRB     r0,[r2,#0]            ;2292
001b4e  4633              MOV      r3,r6                 ;2292
001b50  b2ea              UXTB     r2,r5                 ;2292
001b52  f7fffffe          BL       i2cWrite
001b56  b110              CBZ      r0,|L1.7006|
001b58  f04f30ff          MOV      r0,#0xffffffff        ;2293
001b5c  e7cb              B        |L1.6902|
                  |L1.7006|
001b5e  2000              MOVS     r0,#0                 ;2294
001b60  e7c9              B        |L1.6902|
;;;2296   
                          ENDP

                  mpu_read_mem PROC
;;;2305    */
;;;2306   int mpu_read_mem(unsigned short mem_addr, unsigned short length,
001b62  b5f8              PUSH     {r3-r7,lr}
;;;2307           unsigned char *data)
;;;2308   {
001b64  4604              MOV      r4,r0
001b66  460d              MOV      r5,r1
001b68  4616              MOV      r6,r2
;;;2309       unsigned char tmp[2];
;;;2310   
;;;2311       if (!data)
001b6a  b916              CBNZ     r6,|L1.7026|
;;;2312           return -1;
001b6c  f04f30ff          MOV      r0,#0xffffffff
                  |L1.7024|
;;;2313       if (!st.chip_cfg.sensors)
;;;2314           return -1;
;;;2315   
;;;2316       tmp[0] = (unsigned char)(mem_addr >> 8);
;;;2317       tmp[1] = (unsigned char)(mem_addr & 0xFF);
;;;2318   
;;;2319       /* Check bank boundaries. */
;;;2320       if (tmp[1] + length > st.hw->bank_size)
;;;2321           return -1;
;;;2322   
;;;2323       if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
;;;2324           return -1;
;;;2325       if (i2c_read(st.hw->addr, st.reg->mem_r_w, length, data))
;;;2326           return -1;
;;;2327       return 0;
;;;2328   }
001b70  bdf8              POP      {r3-r7,pc}
                  |L1.7026|
001b72  4837              LDR      r0,|L1.7248|
001b74  7a80              LDRB     r0,[r0,#0xa]          ;2313
001b76  b910              CBNZ     r0,|L1.7038|
001b78  f04f30ff          MOV      r0,#0xffffffff        ;2314
001b7c  e7f8              B        |L1.7024|
                  |L1.7038|
001b7e  1220              ASRS     r0,r4,#8              ;2316
001b80  f88d0000          STRB     r0,[sp,#0]            ;2316
001b84  b2e0              UXTB     r0,r4                 ;2317
001b86  f88d0001          STRB     r0,[sp,#1]            ;2317
001b8a  f89d0001          LDRB     r0,[sp,#1]            ;2320
001b8e  4428              ADD      r0,r0,r5              ;2320
001b90  492f              LDR      r1,|L1.7248|
001b92  6849              LDR      r1,[r1,#4]            ;2320  ; st
001b94  8949              LDRH     r1,[r1,#0xa]          ;2320
001b96  4288              CMP      r0,r1                 ;2320
001b98  dd02              BLE      |L1.7072|
001b9a  f04f30ff          MOV      r0,#0xffffffff        ;2321
001b9e  e7e7              B        |L1.7024|
                  |L1.7072|
001ba0  4a2b              LDR      r2,|L1.7248|
001ba2  6812              LDR      r2,[r2,#0]            ;2323  ; st
001ba4  7e11              LDRB     r1,[r2,#0x18]         ;2323
001ba6  4a2a              LDR      r2,|L1.7248|
001ba8  6852              LDR      r2,[r2,#4]            ;2323  ; st
001baa  7810              LDRB     r0,[r2,#0]            ;2323
001bac  466b              MOV      r3,sp                 ;2323
001bae  2202              MOVS     r2,#2                 ;2323
001bb0  f7fffffe          BL       i2cWrite
001bb4  b110              CBZ      r0,|L1.7100|
001bb6  f04f30ff          MOV      r0,#0xffffffff        ;2324
001bba  e7d9              B        |L1.7024|
                  |L1.7100|
001bbc  4a24              LDR      r2,|L1.7248|
001bbe  6812              LDR      r2,[r2,#0]            ;2325  ; st
001bc0  7d51              LDRB     r1,[r2,#0x15]         ;2325
001bc2  4a23              LDR      r2,|L1.7248|
001bc4  6852              LDR      r2,[r2,#4]            ;2325  ; st
001bc6  7810              LDRB     r0,[r2,#0]            ;2325
001bc8  4633              MOV      r3,r6                 ;2325
001bca  b2ea              UXTB     r2,r5                 ;2325
001bcc  f7fffffe          BL       i2cRead
001bd0  b110              CBZ      r0,|L1.7128|
001bd2  f04f30ff          MOV      r0,#0xffffffff        ;2326
001bd6  e7cb              B        |L1.7024|
                  |L1.7128|
001bd8  2000              MOVS     r0,#0                 ;2327
001bda  e7c9              B        |L1.7024|
;;;2329   
                          ENDP

                  mpu_load_firmware PROC
;;;2337    */
;;;2338   int mpu_load_firmware(unsigned short length, const unsigned char *firmware,
001bdc  e92d43f0          PUSH     {r4-r9,lr}
;;;2339       unsigned short start_addr, unsigned short sample_rate)
;;;2340   {
001be0  b085              SUB      sp,sp,#0x14
001be2  4605              MOV      r5,r0
001be4  460e              MOV      r6,r1
001be6  4690              MOV      r8,r2
001be8  4699              MOV      r9,r3
;;;2341       unsigned short ii;
;;;2342       unsigned short this_write;
;;;2343       /* Must divide evenly into st.hw->bank_size to avoid bank crossings. */
;;;2344   #define LOAD_CHUNK  (16)
;;;2345       unsigned char cur[LOAD_CHUNK], tmp[2];
;;;2346   
;;;2347       if (st.chip_cfg.dmp_loaded)
001bea  4819              LDR      r0,|L1.7248|
001bec  f8900025          LDRB     r0,[r0,#0x25]
001bf0  b120              CBZ      r0,|L1.7164|
;;;2348           /* DMP should only be loaded once. */
;;;2349           return -1;
001bf2  f04f30ff          MOV      r0,#0xffffffff
                  |L1.7158|
;;;2350   
;;;2351       if (!firmware)
;;;2352           return -1;
;;;2353       for (ii = 0; ii < length; ii += this_write) {
;;;2354           this_write = min(LOAD_CHUNK, length - ii);
;;;2355           if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
;;;2356               return -1;
;;;2357           if (mpu_read_mem(ii, this_write, cur))
;;;2358               return -1;
;;;2359           if (memcmp(firmware+ii, cur, this_write))
;;;2360               return -2;
;;;2361       }
;;;2362   
;;;2363       /* Set program start address. */
;;;2364       tmp[0] = start_addr >> 8;
;;;2365       tmp[1] = start_addr & 0xFF;
;;;2366       if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
;;;2367           return -1;
;;;2368   
;;;2369       st.chip_cfg.dmp_loaded = 1;
;;;2370       st.chip_cfg.dmp_sample_rate = sample_rate;
;;;2371       return 0;
;;;2372   }
001bf6  b005              ADD      sp,sp,#0x14
001bf8  e8bd83f0          POP      {r4-r9,pc}
                  |L1.7164|
001bfc  b916              CBNZ     r6,|L1.7172|
001bfe  f04f30ff          MOV      r0,#0xffffffff        ;2352
001c02  e7f8              B        |L1.7158|
                  |L1.7172|
001c04  2400              MOVS     r4,#0                 ;2353
001c06  e027              B        |L1.7256|
                  |L1.7176|
001c08  1b28              SUBS     r0,r5,r4              ;2354
001c0a  2810              CMP      r0,#0x10              ;2354
001c0c  dd01              BLE      |L1.7186|
001c0e  2010              MOVS     r0,#0x10              ;2354
001c10  e000              B        |L1.7188|
                  |L1.7186|
001c12  1b28              SUBS     r0,r5,r4              ;2354
                  |L1.7188|
001c14  b287              UXTH     r7,r0                 ;2354
001c16  1932              ADDS     r2,r6,r4              ;2355
001c18  4639              MOV      r1,r7                 ;2355
001c1a  4620              MOV      r0,r4                 ;2355
001c1c  f7fffffe          BL       mpu_write_mem
001c20  b110              CBZ      r0,|L1.7208|
001c22  f04f30ff          MOV      r0,#0xffffffff        ;2356
001c26  e7e6              B        |L1.7158|
                  |L1.7208|
001c28  aa01              ADD      r2,sp,#4              ;2357
001c2a  4639              MOV      r1,r7                 ;2357
001c2c  4620              MOV      r0,r4                 ;2357
001c2e  f7fffffe          BL       mpu_read_mem
001c32  b110              CBZ      r0,|L1.7226|
001c34  f04f30ff          MOV      r0,#0xffffffff        ;2358
001c38  e7dd              B        |L1.7158|
                  |L1.7226|
001c3a  1930              ADDS     r0,r6,r4              ;2359
001c3c  463a              MOV      r2,r7                 ;2359
001c3e  a901              ADD      r1,sp,#4              ;2359
001c40  f7fffffe          BL       memcmp
001c44  b130              CBZ      r0,|L1.7252|
001c46  f06f0001          MVN      r0,#1                 ;2360
001c4a  e7d4              B        |L1.7158|
                  |L1.7244|
                          DCD      test
                  |L1.7248|
                          DCD      ||st||
                  |L1.7252|
001c54  19e0              ADDS     r0,r4,r7              ;2353
001c56  b284              UXTH     r4,r0                 ;2353
                  |L1.7256|
001c58  42ac              CMP      r4,r5                 ;2353
001c5a  dbd5              BLT      |L1.7176|
001c5c  ea4f2028          ASR      r0,r8,#8              ;2364
001c60  f88d0000          STRB     r0,[sp,#0]            ;2364
001c64  f00800ff          AND      r0,r8,#0xff           ;2365
001c68  f88d0001          STRB     r0,[sp,#1]            ;2365
001c6c  4a92              LDR      r2,|L1.7864|
001c6e  6812              LDR      r2,[r2,#0]            ;2366  ; st
001c70  7e91              LDRB     r1,[r2,#0x1a]         ;2366
001c72  4a91              LDR      r2,|L1.7864|
001c74  6852              LDR      r2,[r2,#4]            ;2366  ; st
001c76  7810              LDRB     r0,[r2,#0]            ;2366
001c78  466b              MOV      r3,sp                 ;2366
001c7a  2202              MOVS     r2,#2                 ;2366
001c7c  f7fffffe          BL       i2cWrite
001c80  b110              CBZ      r0,|L1.7304|
001c82  f04f30ff          MOV      r0,#0xffffffff        ;2367
001c86  e7b6              B        |L1.7158|
                  |L1.7304|
001c88  2101              MOVS     r1,#1                 ;2369
001c8a  488b              LDR      r0,|L1.7864|
001c8c  f8801025          STRB     r1,[r0,#0x25]         ;2369
001c90  f8a09026          STRH     r9,[r0,#0x26]         ;2370
001c94  2000              MOVS     r0,#0                 ;2371
001c96  e7ae              B        |L1.7158|
;;;2373   
                          ENDP

                  mpu_get_dmp_state PROC
;;;2417    */
;;;2418   int mpu_get_dmp_state(unsigned char *enabled)
001c98  4601              MOV      r1,r0
;;;2419   {
;;;2420       enabled[0] = st.chip_cfg.dmp_on;
001c9a  4887              LDR      r0,|L1.7864|
001c9c  f8900024          LDRB     r0,[r0,#0x24]
001ca0  7008              STRB     r0,[r1,#0]
;;;2421       return 0;
001ca2  2000              MOVS     r0,#0
;;;2422   }
001ca4  4770              BX       lr
;;;2423   
                          ENDP

                  mpu_get_compass_reg PROC
;;;2536    */
;;;2537   int mpu_get_compass_reg(short *data, unsigned long *timestamp)
001ca6  4602              MOV      r2,r0
;;;2538   {
;;;2539   #ifdef AK89xx_SECONDARY
;;;2540       unsigned char tmp[9];
;;;2541   
;;;2542       if (!(st.chip_cfg.sensors & INV_XYZ_COMPASS))
;;;2543           return -1;
;;;2544   
;;;2545   #ifdef AK89xx_BYPASS
;;;2546       if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 8, tmp))
;;;2547           return -1;
;;;2548       tmp[8] = AKM_SINGLE_MEASUREMENT;
;;;2549       if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp+8))
;;;2550           return -1;
;;;2551   #else
;;;2552       if (i2c_read(st.hw->addr, st.reg->raw_compass, 8, tmp))
;;;2553           return -1;
;;;2554   #endif
;;;2555   
;;;2556   #if defined AK8975_SECONDARY
;;;2557       /* AK8975 doesn't have the overrun error bit. */
;;;2558       if (!(tmp[0] & AKM_DATA_READY))
;;;2559           return -2;
;;;2560       if ((tmp[7] & AKM_OVERFLOW) || (tmp[7] & AKM_DATA_ERROR))
;;;2561           return -3;
;;;2562   #elif defined AK8963_SECONDARY
;;;2563       /* AK8963 doesn't have the data read error bit. */
;;;2564       if (!(tmp[0] & AKM_DATA_READY) || (tmp[0] & AKM_DATA_OVERRUN))
;;;2565           return -2;
;;;2566       if (tmp[7] & AKM_OVERFLOW)
;;;2567           return -3;
;;;2568   #endif
;;;2569       data[0] = (tmp[2] << 8) | tmp[1];
;;;2570       data[1] = (tmp[4] << 8) | tmp[3];
;;;2571       data[2] = (tmp[6] << 8) | tmp[5];
;;;2572   
;;;2573       data[0] = ((long)data[0] * st.chip_cfg.mag_sens_adj[0]) >> 8;
;;;2574       data[1] = ((long)data[1] * st.chip_cfg.mag_sens_adj[1]) >> 8;
;;;2575       data[2] = ((long)data[2] * st.chip_cfg.mag_sens_adj[2]) >> 8;
;;;2576   
;;;2577       if (timestamp)
;;;2578           get_ms(timestamp);
;;;2579       return 0;
;;;2580   #else
;;;2581       return -1;
001ca8  f04f30ff          MOV      r0,#0xffffffff
;;;2582   #endif
;;;2583   }
001cac  4770              BX       lr
;;;2584   
                          ENDP

                  mpu_get_compass_fsr PROC
;;;2589    */
;;;2590   int mpu_get_compass_fsr(unsigned short *fsr)
001cae  4601              MOV      r1,r0
;;;2591   {
;;;2592   #ifdef AK89xx_SECONDARY
;;;2593       fsr[0] = st.hw->compass_fsr;
;;;2594       return 0;
;;;2595   #else
;;;2596       return -1;
001cb0  f04f30ff          MOV      r0,#0xffffffff
;;;2597   #endif
;;;2598   }
001cb4  4770              BX       lr
;;;2599   
                          ENDP

                  mpu_lp_motion_interrupt PROC
;;;2643    */
;;;2644   int mpu_lp_motion_interrupt(unsigned short thresh, unsigned char time,
001cb6  b5f8              PUSH     {r3-r7,lr}
;;;2645       unsigned char lpa_freq)
;;;2646   {
001cb8  4605              MOV      r5,r0
001cba  460f              MOV      r7,r1
001cbc  4614              MOV      r4,r2
;;;2647       unsigned char data[3];
;;;2648   
;;;2649       if (lpa_freq) {
001cbe  b3f4              CBZ      r4,|L1.7486|
;;;2650           unsigned char thresh_hw;
;;;2651   
;;;2652   #if defined MPU6050
;;;2653           /* TODO: Make these const/#defines. */
;;;2654           /* 1LSb = 32mg. */
;;;2655           if (thresh > 8160)
001cc0  f5b55fff          CMP      r5,#0x1fe0
001cc4  dd01              BLE      |L1.7370|
;;;2656               thresh_hw = 255;
001cc6  26ff              MOVS     r6,#0xff
001cc8  e005              B        |L1.7382|
                  |L1.7370|
;;;2657           else if (thresh < 32)
001cca  2d20              CMP      r5,#0x20
001ccc  da01              BGE      |L1.7378|
;;;2658               thresh_hw = 1;
001cce  2601              MOVS     r6,#1
001cd0  e001              B        |L1.7382|
                  |L1.7378|
;;;2659           else
;;;2660               thresh_hw = thresh >> 5;
001cd2  f3c51647          UBFX     r6,r5,#5,#8
                  |L1.7382|
;;;2661   #elif defined MPU6500
;;;2662           /* 1LSb = 4mg. */
;;;2663           if (thresh > 1020)
;;;2664               thresh_hw = 255;
;;;2665           else if (thresh < 4)
;;;2666               thresh_hw = 1;
;;;2667           else
;;;2668               thresh_hw = thresh >> 2;
;;;2669   #endif
;;;2670   
;;;2671           if (!time)
001cd6  b907              CBNZ     r7,|L1.7386|
;;;2672               /* Minimum duration must be 1ms. */
;;;2673               time = 1;
001cd8  2701              MOVS     r7,#1
                  |L1.7386|
;;;2674   
;;;2675   #if defined MPU6050
;;;2676           if (lpa_freq > 40)
001cda  2c28              CMP      r4,#0x28
001cdc  dd02              BLE      |L1.7396|
;;;2677   #elif defined MPU6500
;;;2678           if (lpa_freq > 640)
;;;2679   #endif
;;;2680               /* At this point, the chip has not been re-configured, so the
;;;2681                * function can safely exit.
;;;2682                */
;;;2683               return -1;
001cde  f04f30ff          MOV      r0,#0xffffffff
                  |L1.7394|
;;;2684   
;;;2685           if (!st.chip_cfg.int_motion_only) {
;;;2686               /* Store current settings for later. */
;;;2687               if (st.chip_cfg.dmp_on) {
;;;2688                   mpu_set_dmp_state(0);
;;;2689                   st.chip_cfg.cache.dmp_on = 1;
;;;2690               } else
;;;2691                   st.chip_cfg.cache.dmp_on = 0;
;;;2692               mpu_get_gyro_fsr(&st.chip_cfg.cache.gyro_fsr);
;;;2693               mpu_get_accel_fsr(&st.chip_cfg.cache.accel_fsr);
;;;2694               mpu_get_lpf(&st.chip_cfg.cache.lpf);
;;;2695               mpu_get_sample_rate(&st.chip_cfg.cache.sample_rate);
;;;2696               st.chip_cfg.cache.sensors_on = st.chip_cfg.sensors;
;;;2697               mpu_get_fifo_config(&st.chip_cfg.cache.fifo_sensors);
;;;2698           }
;;;2699   
;;;2700   #ifdef MPU6050
;;;2701           /* Disable hardware interrupts for now. */
;;;2702           set_int_enable(0);
;;;2703   
;;;2704           /* Enter full-power accel-only mode. */
;;;2705           mpu_lp_accel_mode(0);
;;;2706   
;;;2707           /* Override current LPF (and HPF) settings to obtain a valid accel
;;;2708            * reading.
;;;2709            */
;;;2710           data[0] = INV_FILTER_256HZ_NOLPF2;
;;;2711           if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
;;;2712               return -1;
;;;2713   
;;;2714           /* NOTE: Digital high pass filter should be configured here. Since this
;;;2715            * driver doesn't modify those bits anywhere, they should already be
;;;2716            * cleared by default.
;;;2717            */
;;;2718   
;;;2719           /* Configure the device to send motion interrupts. */
;;;2720           /* Enable motion interrupt. */
;;;2721           data[0] = BIT_MOT_INT_EN;
;;;2722           if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
;;;2723               goto lp_int_restore;
;;;2724   
;;;2725           /* Set motion interrupt parameters. */
;;;2726           data[0] = thresh_hw;
;;;2727           data[1] = time;
;;;2728           if (i2c_write(st.hw->addr, st.reg->motion_thr, 2, data))
;;;2729               goto lp_int_restore;
;;;2730   
;;;2731           /* Force hardware to "lock" current accel sample. */
;;;2732           delay_ms(5);
;;;2733           data[0] = (st.chip_cfg.accel_fsr << 3) | BITS_HPF;
;;;2734           if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
;;;2735               goto lp_int_restore;
;;;2736   
;;;2737           /* Set up LP accel mode. */
;;;2738           data[0] = BIT_LPA_CYCLE;
;;;2739           if (lpa_freq == 1)
;;;2740               data[1] = INV_LPA_1_25HZ;
;;;2741           else if (lpa_freq <= 5)
;;;2742               data[1] = INV_LPA_5HZ;
;;;2743           else if (lpa_freq <= 20)
;;;2744               data[1] = INV_LPA_20HZ;
;;;2745           else
;;;2746               data[1] = INV_LPA_40HZ;
;;;2747           data[1] = (data[1] << 6) | BIT_STBY_XYZG;
;;;2748           if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
;;;2749               goto lp_int_restore;
;;;2750   
;;;2751           st.chip_cfg.int_motion_only = 1;
;;;2752           return 0;
;;;2753   #elif defined MPU6500
;;;2754           /* Disable hardware interrupts. */
;;;2755           set_int_enable(0);
;;;2756   
;;;2757           /* Enter full-power accel-only mode, no FIFO/DMP. */
;;;2758           data[0] = 0;
;;;2759           data[1] = 0;
;;;2760           data[2] = BIT_STBY_XYZG;
;;;2761           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 3, data))
;;;2762               goto lp_int_restore;
;;;2763   
;;;2764           /* Set motion threshold. */
;;;2765           data[0] = thresh_hw;
;;;2766           if (i2c_write(st.hw->addr, st.reg->motion_thr, 1, data))
;;;2767               goto lp_int_restore;
;;;2768   
;;;2769           /* Set wake frequency. */
;;;2770           if (lpa_freq == 1)
;;;2771               data[0] = INV_LPA_1_25HZ;
;;;2772           else if (lpa_freq == 2)
;;;2773               data[0] = INV_LPA_2_5HZ;
;;;2774           else if (lpa_freq <= 5)
;;;2775               data[0] = INV_LPA_5HZ;
;;;2776           else if (lpa_freq <= 10)
;;;2777               data[0] = INV_LPA_10HZ;
;;;2778           else if (lpa_freq <= 20)
;;;2779               data[0] = INV_LPA_20HZ;
;;;2780           else if (lpa_freq <= 40)
;;;2781               data[0] = INV_LPA_40HZ;
;;;2782           else if (lpa_freq <= 80)
;;;2783               data[0] = INV_LPA_80HZ;
;;;2784           else if (lpa_freq <= 160)
;;;2785               data[0] = INV_LPA_160HZ;
;;;2786           else if (lpa_freq <= 320)
;;;2787               data[0] = INV_LPA_320HZ;
;;;2788           else
;;;2789               data[0] = INV_LPA_640HZ;
;;;2790           if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, data))
;;;2791               goto lp_int_restore;
;;;2792   
;;;2793           /* Enable motion interrupt (MPU6500 version). */
;;;2794           data[0] = BITS_WOM_EN;
;;;2795           if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
;;;2796               goto lp_int_restore;
;;;2797   
;;;2798           /* Enable cycle mode. */
;;;2799           data[0] = BIT_LPA_CYCLE;
;;;2800           if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
;;;2801               goto lp_int_restore;
;;;2802   
;;;2803           /* Enable interrupt. */
;;;2804           data[0] = BIT_MOT_INT_EN;
;;;2805           if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
;;;2806               goto lp_int_restore;
;;;2807   
;;;2808           st.chip_cfg.int_motion_only = 1;
;;;2809           return 0;
;;;2810   #endif
;;;2811       } else {
;;;2812           /* Don't "restore" the previous state if no state has been saved. */
;;;2813           int ii;
;;;2814           char *cache_ptr = (char*)&st.chip_cfg.cache;
;;;2815           for (ii = 0; ii < sizeof(st.chip_cfg.cache); ii++) {
;;;2816               if (cache_ptr[ii] != 0)
;;;2817                   goto lp_int_restore;
;;;2818           }
;;;2819           /* If we reach this point, motion interrupt mode hasn't been used yet. */
;;;2820           return -1;
;;;2821       }
;;;2822   lp_int_restore:
;;;2823       /* Set to invalid values to ensure no I2C writes are skipped. */
;;;2824       st.chip_cfg.gyro_fsr = 0xFF;
;;;2825       st.chip_cfg.accel_fsr = 0xFF;
;;;2826       st.chip_cfg.lpf = 0xFF;
;;;2827       st.chip_cfg.sample_rate = 0xFFFF;
;;;2828       st.chip_cfg.sensors = 0xFF;
;;;2829       st.chip_cfg.fifo_enable = 0xFF;
;;;2830       st.chip_cfg.clk_src = INV_CLK_PLL;
;;;2831       mpu_set_sensors(st.chip_cfg.cache.sensors_on);
;;;2832       mpu_set_gyro_fsr(st.chip_cfg.cache.gyro_fsr);
;;;2833       mpu_set_accel_fsr(st.chip_cfg.cache.accel_fsr);
;;;2834       mpu_set_lpf(st.chip_cfg.cache.lpf);
;;;2835       mpu_set_sample_rate(st.chip_cfg.cache.sample_rate);
;;;2836       mpu_configure_fifo(st.chip_cfg.cache.fifo_sensors);
;;;2837   
;;;2838       if (st.chip_cfg.cache.dmp_on)
;;;2839           mpu_set_dmp_state(1);
;;;2840   
;;;2841   #ifdef MPU6500
;;;2842       /* Disable motion interrupt (MPU6500 version). */
;;;2843       data[0] = 0;
;;;2844       if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
;;;2845           goto lp_int_restore;
;;;2846   #endif
;;;2847   
;;;2848       st.chip_cfg.int_motion_only = 0;
;;;2849       return 0;
;;;2850   }
001ce2  bdf8              POP      {r3-r7,pc}
                  |L1.7396|
001ce4  4874              LDR      r0,|L1.7864|
001ce6  7d40              LDRB     r0,[r0,#0x15]         ;2685
001ce8  bb28              CBNZ     r0,|L1.7478|
001cea  4873              LDR      r0,|L1.7864|
001cec  f8900024          LDRB     r0,[r0,#0x24]         ;2687
001cf0  b138              CBZ      r0,|L1.7426|
001cf2  2000              MOVS     r0,#0                 ;2688
001cf4  f7fffffe          BL       mpu_set_dmp_state
001cf8  2101              MOVS     r1,#1                 ;2689
001cfa  486f              LDR      r0,|L1.7864|
001cfc  f8801020          STRB     r1,[r0,#0x20]         ;2689
001d00  e003              B        |L1.7434|
                  |L1.7426|
001d02  2100              MOVS     r1,#0                 ;2691
001d04  486c              LDR      r0,|L1.7864|
001d06  f8801020          STRB     r1,[r0,#0x20]         ;2691
                  |L1.7434|
001d0a  486b              LDR      r0,|L1.7864|
001d0c  3016              ADDS     r0,r0,#0x16           ;2692
001d0e  f7fffffe          BL       mpu_get_gyro_fsr
001d12  4869              LDR      r0,|L1.7864|
001d14  3018              ADDS     r0,r0,#0x18           ;2693
001d16  f7fffffe          BL       mpu_get_accel_fsr
001d1a  4867              LDR      r0,|L1.7864|
001d1c  301a              ADDS     r0,r0,#0x1a           ;2694
001d1e  f7fffffe          BL       mpu_get_lpf
001d22  4865              LDR      r0,|L1.7864|
001d24  301c              ADDS     r0,r0,#0x1c           ;2695
001d26  f7fffffe          BL       mpu_get_sample_rate
001d2a  4863              LDR      r0,|L1.7864|
001d2c  7a81              LDRB     r1,[r0,#0xa]          ;2696
001d2e  7781              STRB     r1,[r0,#0x1e]         ;2696
001d30  301f              ADDS     r0,r0,#0x1f           ;2697
001d32  f7fffffe          BL       mpu_get_fifo_config
                  |L1.7478|
001d36  2000              MOVS     r0,#0                 ;2702
001d38  f7fffffe          BL       set_int_enable
001d3c  e000              B        |L1.7488|
                  |L1.7486|
001d3e  e07a              B        |L1.7734|
                  |L1.7488|
001d40  2000              MOVS     r0,#0                 ;2705
001d42  f7fffffe          BL       mpu_lp_accel_mode
001d46  2000              MOVS     r0,#0                 ;2710
001d48  f88d0000          STRB     r0,[sp,#0]            ;2710
001d4c  4a5a              LDR      r2,|L1.7864|
001d4e  6812              LDR      r2,[r2,#0]            ;2711  ; st
001d50  7891              LDRB     r1,[r2,#2]            ;2711
001d52  4a59              LDR      r2,|L1.7864|
001d54  6852              LDR      r2,[r2,#4]            ;2711  ; st
001d56  7810              LDRB     r0,[r2,#0]            ;2711
001d58  466b              MOV      r3,sp                 ;2711
001d5a  2201              MOVS     r2,#1                 ;2711
001d5c  f7fffffe          BL       i2cWrite
001d60  b110              CBZ      r0,|L1.7528|
001d62  f04f30ff          MOV      r0,#0xffffffff        ;2712
001d66  e7bc              B        |L1.7394|
                  |L1.7528|
001d68  2040              MOVS     r0,#0x40              ;2721
001d6a  f88d0000          STRB     r0,[sp,#0]            ;2721
001d6e  4a52              LDR      r2,|L1.7864|
001d70  6812              LDR      r2,[r2,#0]            ;2722  ; st
001d72  7bd1              LDRB     r1,[r2,#0xf]          ;2722
001d74  4a50              LDR      r2,|L1.7864|
001d76  6852              LDR      r2,[r2,#4]            ;2722  ; st
001d78  7810              LDRB     r0,[r2,#0]            ;2722
001d7a  466b              MOV      r3,sp                 ;2722
001d7c  2201              MOVS     r2,#1                 ;2722
001d7e  f7fffffe          BL       i2cWrite
001d82  b100              CBZ      r0,|L1.7558|
001d84  e064              B        |L1.7760|
                  |L1.7558|
001d86  f88d6000          STRB     r6,[sp,#0]            ;2726
001d8a  f88d7001          STRB     r7,[sp,#1]            ;2727
001d8e  4a4a              LDR      r2,|L1.7864|
001d90  6812              LDR      r2,[r2,#0]            ;2728  ; st
001d92  7a11              LDRB     r1,[r2,#8]            ;2728
001d94  4a48              LDR      r2,|L1.7864|
001d96  6852              LDR      r2,[r2,#4]            ;2728  ; st
001d98  7810              LDRB     r0,[r2,#0]            ;2728
001d9a  466b              MOV      r3,sp                 ;2728
001d9c  2202              MOVS     r2,#2                 ;2728
001d9e  f7fffffe          BL       i2cWrite
001da2  b100              CBZ      r0,|L1.7590|
001da4  e054              B        |L1.7760|
                  |L1.7590|
001da6  2005              MOVS     r0,#5                 ;2732
001da8  f7fffffe          BL       delay_ms
001dac  4842              LDR      r0,|L1.7864|
001dae  7a40              LDRB     r0,[r0,#9]            ;2733
001db0  2107              MOVS     r1,#7                 ;2733
001db2  eb0100c0          ADD      r0,r1,r0,LSL #3       ;2733
001db6  b2c0              UXTB     r0,r0                 ;2733
001db8  f88d0000          STRB     r0,[sp,#0]            ;2733
001dbc  4a3e              LDR      r2,|L1.7864|
001dbe  6812              LDR      r2,[r2,#0]            ;2734  ; st
001dc0  79d1              LDRB     r1,[r2,#7]            ;2734
001dc2  4a3d              LDR      r2,|L1.7864|
001dc4  6852              LDR      r2,[r2,#4]            ;2734  ; st
001dc6  7810              LDRB     r0,[r2,#0]            ;2734
001dc8  466b              MOV      r3,sp                 ;2734
001dca  2201              MOVS     r2,#1                 ;2734
001dcc  f7fffffe          BL       i2cWrite
001dd0  b100              CBZ      r0,|L1.7636|
001dd2  e03d              B        |L1.7760|
                  |L1.7636|
001dd4  2020              MOVS     r0,#0x20              ;2738
001dd6  f88d0000          STRB     r0,[sp,#0]            ;2738
001dda  2c01              CMP      r4,#1                 ;2739
001ddc  d103              BNE      |L1.7654|
001dde  2000              MOVS     r0,#0                 ;2740
001de0  f88d0001          STRB     r0,[sp,#1]            ;2740
001de4  e00e              B        |L1.7684|
                  |L1.7654|
001de6  2c05              CMP      r4,#5                 ;2741
001de8  dc03              BGT      |L1.7666|
001dea  2001              MOVS     r0,#1                 ;2742
001dec  f88d0001          STRB     r0,[sp,#1]            ;2742
001df0  e008              B        |L1.7684|
                  |L1.7666|
001df2  2c14              CMP      r4,#0x14              ;2743
001df4  dc03              BGT      |L1.7678|
001df6  2002              MOVS     r0,#2                 ;2744
001df8  f88d0001          STRB     r0,[sp,#1]            ;2744
001dfc  e002              B        |L1.7684|
                  |L1.7678|
001dfe  2003              MOVS     r0,#3                 ;2746
001e00  f88d0001          STRB     r0,[sp,#1]            ;2746
                  |L1.7684|
001e04  f89d0001          LDRB     r0,[sp,#1]            ;2747
001e08  2107              MOVS     r1,#7                 ;2747
001e0a  eb011080          ADD      r0,r1,r0,LSL #6       ;2747
001e0e  b2c0              UXTB     r0,r0                 ;2747
001e10  f88d0001          STRB     r0,[sp,#1]            ;2747
001e14  4a28              LDR      r2,|L1.7864|
001e16  6812              LDR      r2,[r2,#0]            ;2748  ; st
001e18  7c91              LDRB     r1,[r2,#0x12]         ;2748
001e1a  4a27              LDR      r2,|L1.7864|
001e1c  6852              LDR      r2,[r2,#4]            ;2748  ; st
001e1e  7810              LDRB     r0,[r2,#0]            ;2748
001e20  466b              MOV      r3,sp                 ;2748
001e22  2202              MOVS     r2,#2                 ;2748
001e24  f7fffffe          BL       i2cWrite
001e28  b100              CBZ      r0,|L1.7724|
001e2a  e011              B        |L1.7760|
                  |L1.7724|
001e2c  2101              MOVS     r1,#1                 ;2751
001e2e  4822              LDR      r0,|L1.7864|
001e30  7541              STRB     r1,[r0,#0x15]         ;2751
001e32  2000              MOVS     r0,#0                 ;2752
001e34  e755              B        |L1.7394|
                  |L1.7734|
001e36  4a20              LDR      r2,|L1.7864|
001e38  3216              ADDS     r2,r2,#0x16           ;2814
001e3a  2100              MOVS     r1,#0                 ;2815
001e3c  e003              B        |L1.7750|
                  |L1.7742|
001e3e  5c50              LDRB     r0,[r2,r1]            ;2816
001e40  b100              CBZ      r0,|L1.7748|
001e42  e005              B        |L1.7760|
                  |L1.7748|
001e44  1c49              ADDS     r1,r1,#1              ;2815
                  |L1.7750|
001e46  290c              CMP      r1,#0xc               ;2815
001e48  d3f9              BCC      |L1.7742|
001e4a  f04f30ff          MOV      r0,#0xffffffff        ;2820
001e4e  e748              B        |L1.7394|
                  |L1.7760|
001e50  20ff              MOVS     r0,#0xff              ;2824
001e52  4919              LDR      r1,|L1.7864|
001e54  7208              STRB     r0,[r1,#8]            ;2824
001e56  21ff              MOVS     r1,#0xff              ;2825
001e58  4817              LDR      r0,|L1.7864|
001e5a  7241              STRB     r1,[r0,#9]            ;2825
001e5c  72c1              STRB     r1,[r0,#0xb]          ;2826
001e5e  f64f71ff          MOV      r1,#0xffff            ;2827
001e62  81c1              STRH     r1,[r0,#0xe]          ;2827
001e64  21ff              MOVS     r1,#0xff              ;2828
001e66  7281              STRB     r1,[r0,#0xa]          ;2828
001e68  7401              STRB     r1,[r0,#0x10]         ;2829
001e6a  2101              MOVS     r1,#1                 ;2830
001e6c  7301              STRB     r1,[r0,#0xc]          ;2830
001e6e  4601              MOV      r1,r0                 ;2831
001e70  7f88              LDRB     r0,[r1,#0x1e]         ;2831
001e72  f7fffffe          BL       mpu_set_sensors
001e76  4910              LDR      r1,|L1.7864|
001e78  8ac8              LDRH     r0,[r1,#0x16]         ;2832
001e7a  f7fffffe          BL       mpu_set_gyro_fsr
001e7e  490e              LDR      r1,|L1.7864|
001e80  7e08              LDRB     r0,[r1,#0x18]         ;2833
001e82  f7fffffe          BL       mpu_set_accel_fsr
001e86  490c              LDR      r1,|L1.7864|
001e88  8b48              LDRH     r0,[r1,#0x1a]         ;2834
001e8a  f7fffffe          BL       mpu_set_lpf
001e8e  490a              LDR      r1,|L1.7864|
001e90  8b88              LDRH     r0,[r1,#0x1c]         ;2835
001e92  f7fffffe          BL       mpu_set_sample_rate
001e96  4908              LDR      r1,|L1.7864|
001e98  7fc8              LDRB     r0,[r1,#0x1f]         ;2836
001e9a  f7fffffe          BL       mpu_configure_fifo
001e9e  4806              LDR      r0,|L1.7864|
001ea0  f8900020          LDRB     r0,[r0,#0x20]         ;2838
001ea4  b110              CBZ      r0,|L1.7852|
001ea6  2001              MOVS     r0,#1                 ;2839
001ea8  f7fffffe          BL       mpu_set_dmp_state
                  |L1.7852|
001eac  2100              MOVS     r1,#0                 ;2848
001eae  4802              LDR      r0,|L1.7864|
001eb0  7541              STRB     r1,[r0,#0x15]         ;2848
001eb2  2000              MOVS     r0,#0                 ;2849
001eb4  e715              B        |L1.7394|
;;;2851   void myget_ms(unsigned long *time)
                          ENDP

001eb6  0000              DCW      0x0000
                  |L1.7864|
                          DCD      ||st||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  ||hw||
000000  6800              DCB      0x68,0x00
000002  0400              DCW      0x0400
000004  7600              DCB      0x76,0x00
000006  0154              DCW      0x0154
000008  fdf70100          DCW      0xfdf7,0x0100
                  ||reg||
00000c  75191a0c          DCB      0x75,0x19,0x1a,0x0c
000010  6a231b1c          DCB      0x6a,0x23,0x1b,0x1c
000014  1f207274          DCB      0x1f,0x20,0x72,0x74
000018  433b4138          DCB      0x43,0x3b,0x41,0x38
00001c  393a6b6c          DCB      0x39,0x3a,0x6b,0x6c
000020  376f0624          DCB      0x37,0x6f,0x06,0x24
000024  6d6e7000          DCB      0x6d,0x6e,0x70,0x00
                  test
                          DCD      0x00000083
                          DCD      0x00000800
000030  00010018          DCB      0x00,0x01,0x00,0x18
000034  0032              DCW      0x0032
000036  0500              DCB      0x05,0x00
000038  41200000          DCFS     0x41200000 ; 10
00003c  42d20000          DCFS     0x42d20000 ; 105
000040  3e0f5c29          DCFS     0x3e0f5c29 ; 0.14000000059604645
000044  3e99999a          DCFS     0x3e99999a ; 0.30000001192092896
000048  3f733333          DCFS     0x3f733333 ; 0.94999998807907104
00004c  3e0f5c29          DCFS     0x3e0f5c29 ; 0.14000000059604645
000050  50726f64          DCB      0x50,0x72,0x6f,0x64
000054  75637420          DCB      0x75,0x63,0x74,0x20
000058  49442072          DCB      0x49,0x44,0x20,0x72
00005c  65616420          DCB      0x65,0x61,0x64,0x20
000060  61732030          DCB      0x61,0x73,0x20,0x30
000064  20696e64          DCB      0x20,0x69,0x6e,0x64
000068  69636174          DCB      0x69,0x63,0x61,0x74
00006c  65732064          DCB      0x65,0x73,0x20,0x64
000070  65766963          DCB      0x65,0x76,0x69,0x63
000074  65206973          DCB      0x65,0x20,0x69,0x73
000078  20656974          DCB      0x20,0x65,0x69,0x74
00007c  68657220          DCB      0x68,0x65,0x72,0x20
000080  696e636f          DCB      0x69,0x6e,0x63,0x6f
000084  6d706174          DCB      0x6d,0x70,0x61,0x74
000088  69626c65          DCB      0x69,0x62,0x6c,0x65
00008c  206f7220          DCB      0x20,0x6f,0x72,0x20
000090  616e204d          DCB      0x61,0x6e,0x20,0x4d
000094  50553330          DCB      0x50,0x55,0x33,0x30
000098  35302e0d          DCB      0x35,0x30,0x2e,0x0d
00009c  0a00              DCB      0x0a,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  ||st||
                          DCD      ||reg||
                          DCD      ||hw||
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  0000              DCB      0x00,0x00
00000e  0000              DCW      0x0000
000010  00000000          DCB      0x00,0x00,0x00,0x00
000014  00000000          DCB      0x00,0x00,0x00,0x00
                          %        8
000020  00000000          DCB      0x00,0x00,0x00,0x00
000024  0000              DCB      0x00,0x00
000026  0000              DCW      0x0000
                          DCD      test
