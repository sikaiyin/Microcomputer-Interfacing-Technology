; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o..\OBJ\adc.o --depend=..\OBJ\adc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\OLED -I..\HARDWARE\ADC -I..\HARDWARE\TIMER -I..\HARDWARE\MOTOR -I..\BALANCE\CONTROL -I..\HARDWARE\ENCODER -I..\HARDWARE\IIC -I..\BALANCE\CONTROL -I..\BALANCE\DMP -I..\BALANCE\filter -I..\BALANCE\MPU6050 -I..\BALANCE\show -I..\BALANCE\controls -I..\HARDWARE\USART3 -I..\HARDWARE\EXTI -I..\HARDWARE\DataScope_DP -I"H:\KEIL MDK4\ARM\INC" -I"H:\KEIL MDK4\ARM\INC\STMicroelectronics" -DSTM32F10X_MD --omf_browse=..\OBJ\adc.crf ..\HARDWARE\ADC\adc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  Adc_Init PROC
;;;7      **************************************************************************/
;;;8      void  Adc_Init(void)
000000  4873              LDR      r0,|L1.464|
;;;9      {    
;;;10       //先初始化IO口
;;;11      	RCC->APB2ENR|=1<<2;    //使能PORTA口时钟 
000002  6980              LDR      r0,[r0,#0x18]
000004  f0400004          ORR      r0,r0,#4
000008  4971              LDR      r1,|L1.464|
00000a  6188              STR      r0,[r1,#0x18]
;;;12     	GPIOA->CRL&=0XFFF0FFFF;//PA4 anolog输入 
00000c  4871              LDR      r0,|L1.468|
00000e  6800              LDR      r0,[r0,#0]
000010  f4202070          BIC      r0,r0,#0xf0000
000014  4970              LDR      r1,|L1.472|
000016  f8c10800          STR      r0,[r1,#0x800]
;;;13     	RCC->APB2ENR|=1<<9;    //ADC1时钟使能	  
00001a  486d              LDR      r0,|L1.464|
00001c  6980              LDR      r0,[r0,#0x18]
00001e  f4407000          ORR      r0,r0,#0x200
000022  496b              LDR      r1,|L1.464|
000024  6188              STR      r0,[r1,#0x18]
;;;14     	RCC->APB2RSTR|=1<<9;   //ADC1复位
000026  4608              MOV      r0,r1
000028  68c0              LDR      r0,[r0,#0xc]
00002a  f4407000          ORR      r0,r0,#0x200
00002e  60c8              STR      r0,[r1,#0xc]
;;;15     	RCC->APB2RSTR&=~(1<<9);//复位结束	    
000030  4608              MOV      r0,r1
000032  68c0              LDR      r0,[r0,#0xc]
000034  f4207000          BIC      r0,r0,#0x200
000038  60c8              STR      r0,[r1,#0xc]
;;;16     	RCC->CFGR&=~(3<<14);   //分频因子清零	
00003a  4608              MOV      r0,r1
00003c  6840              LDR      r0,[r0,#4]
00003e  f4204040          BIC      r0,r0,#0xc000
000042  6048              STR      r0,[r1,#4]
;;;17     	//SYSCLK/DIV2=12M ADC时钟设置为12M,ADC最大时钟不能超过14M!
;;;18     	//否则将导致ADC准确度下降! 
;;;19     	RCC->CFGR|=2<<14;      	 
000044  4608              MOV      r0,r1
000046  6840              LDR      r0,[r0,#4]
000048  f4404000          ORR      r0,r0,#0x8000
00004c  6048              STR      r0,[r1,#4]
;;;20     	ADC1->CR1&=0XF0FFFF;   //工作模式清零
00004e  4863              LDR      r0,|L1.476|
000050  6800              LDR      r0,[r0,#0]
000052  4963              LDR      r1,|L1.480|
000054  ea000001          AND      r0,r0,r1
000058  4962              LDR      r1,|L1.484|
00005a  f8c10404          STR      r0,[r1,#0x404]
;;;21     	ADC1->CR1|=0<<16;      //独立工作模式  
00005e  485f              LDR      r0,|L1.476|
000060  6800              LDR      r0,[r0,#0]
000062  f8c10404          STR      r0,[r1,#0x404]
;;;22     	ADC1->CR1&=~(1<<8);    //非扫描模式	  
000066  4608              MOV      r0,r1
000068  f8d00404          LDR      r0,[r0,#0x404]
00006c  f4207080          BIC      r0,r0,#0x100
000070  f8c10404          STR      r0,[r1,#0x404]
;;;23     	ADC1->CR2&=~(1<<1);    //单次转换模式
000074  4608              MOV      r0,r1
000076  f8d00408          LDR      r0,[r0,#0x408]
00007a  f0200002          BIC      r0,r0,#2
00007e  f8c10408          STR      r0,[r1,#0x408]
;;;24     	ADC1->CR2&=~(7<<17);	   
000082  4608              MOV      r0,r1
000084  f8d00408          LDR      r0,[r0,#0x408]
000088  f4202060          BIC      r0,r0,#0xe0000
00008c  f8c10408          STR      r0,[r1,#0x408]
;;;25     	ADC1->CR2|=7<<17;	   //软件控制转换  
000090  4608              MOV      r0,r1
000092  f8d00408          LDR      r0,[r0,#0x408]
000096  f4402060          ORR      r0,r0,#0xe0000
00009a  f8c10408          STR      r0,[r1,#0x408]
;;;26     	ADC1->CR2|=1<<20;      //使用用外部触发(SWSTART)!!!	必须使用一个事件来触发
00009e  4608              MOV      r0,r1
0000a0  f8d00408          LDR      r0,[r0,#0x408]
0000a4  f4401080          ORR      r0,r0,#0x100000
0000a8  f8c10408          STR      r0,[r1,#0x408]
;;;27     	ADC1->CR2&=~(1<<11);   //右对齐	 
0000ac  4608              MOV      r0,r1
0000ae  f8d00408          LDR      r0,[r0,#0x408]
0000b2  f4206000          BIC      r0,r0,#0x800
0000b6  f8c10408          STR      r0,[r1,#0x408]
;;;28     	ADC1->SQR1&=~(0XF<<20);
0000ba  4608              MOV      r0,r1
0000bc  f8d0042c          LDR      r0,[r0,#0x42c]
0000c0  f4200070          BIC      r0,r0,#0xf00000
0000c4  f8c1042c          STR      r0,[r1,#0x42c]
;;;29     	ADC1->SQR1&=0<<20;     //1个转换在规则序列中 也就是只转换规则序列1 			   
0000c8  4608              MOV      r0,r1
0000ca  f8d0042c          LDR      r0,[r0,#0x42c]
0000ce  f04f0000          MOV      r0,#0
0000d2  f8c1042c          STR      r0,[r1,#0x42c]
;;;30     	//设置通道4的采样时间
;;;31     	ADC1->SMPR2&=0XFFF0FFFF; //采样时间清空	  
0000d6  4608              MOV      r0,r1
0000d8  f8d00410          LDR      r0,[r0,#0x410]
0000dc  f4202070          BIC      r0,r0,#0xf0000
0000e0  f8c10410          STR      r0,[r1,#0x410]
;;;32     	ADC1->SMPR2|=7<<12;      // 239.5周期,提高采样时间可以提高精确度	 
0000e4  4608              MOV      r0,r1
0000e6  f8d00410          LDR      r0,[r0,#0x410]
0000ea  f44040e0          ORR      r0,r0,#0x7000
0000ee  f8c10410          STR      r0,[r1,#0x410]
;;;33     
;;;34     	ADC1->CR2|=1<<0;	    //开启AD转换器	 
0000f2  4608              MOV      r0,r1
0000f4  f8d00408          LDR      r0,[r0,#0x408]
0000f8  f0400001          ORR      r0,r0,#1
0000fc  f8c10408          STR      r0,[r1,#0x408]
;;;35     	ADC1->CR2|=1<<3;        //使能复位校准  
000100  4608              MOV      r0,r1
000102  f8d00408          LDR      r0,[r0,#0x408]
000106  f0400008          ORR      r0,r0,#8
00010a  f8c10408          STR      r0,[r1,#0x408]
;;;36     	while(ADC1->CR2&1<<3);  //等待校准结束 			 
00010e  bf00              NOP      
                  |L1.272|
000110  4835              LDR      r0,|L1.488|
000112  6800              LDR      r0,[r0,#0]
000114  f0100f08          TST      r0,#8
000118  d1fa              BNE      |L1.272|
;;;37         //该位由软件设置并由硬件清除。在校准寄存器被初始化后该位将被清除。 		 
;;;38     	ADC1->CR2|=1<<2;        //开启AD校准	   
00011a  4833              LDR      r0,|L1.488|
00011c  6800              LDR      r0,[r0,#0]
00011e  f0400004          ORR      r0,r0,#4
000122  4930              LDR      r1,|L1.484|
000124  f8c10408          STR      r0,[r1,#0x408]
;;;39     	while(ADC1->CR2&1<<2);  //等待校准结束 
000128  bf00              NOP      
                  |L1.298|
00012a  482f              LDR      r0,|L1.488|
00012c  6800              LDR      r0,[r0,#0]
00012e  f0100f04          TST      r0,#4
000132  d1fa              BNE      |L1.298|
;;;40     }		
000134  4770              BX       lr
;;;41     
                          ENDP

                  Get_Adc PROC
;;;46     **************************************************************************/
;;;47     u16 Get_Adc(u8 ch)   
000136  4601              MOV      r1,r0
;;;48     {
;;;49     	//设置转换序列	  		 
;;;50     	ADC1->SQR3&=0XFFFFFFE0;//规则序列1 通道ch
000138  482c              LDR      r0,|L1.492|
00013a  6800              LDR      r0,[r0,#0]
00013c  f020001f          BIC      r0,r0,#0x1f
000140  4a28              LDR      r2,|L1.484|
000142  f8c20434          STR      r0,[r2,#0x434]
;;;51     	ADC1->SQR3|=ch;		  			    
000146  4610              MOV      r0,r2
000148  f8d00434          LDR      r0,[r0,#0x434]
00014c  ea400001          ORR      r0,r0,r1
000150  f8c20434          STR      r0,[r2,#0x434]
;;;52     	ADC1->CR2|=1<<22;       //启动规则转换通道 
000154  4610              MOV      r0,r2
000156  f8d00408          LDR      r0,[r0,#0x408]
00015a  f4400080          ORR      r0,r0,#0x400000
00015e  f8c20408          STR      r0,[r2,#0x408]
;;;53     	while(!(ADC1->SR&1<<1));//等待转换结束	 	   
000162  bf00              NOP      
                  |L1.356|
000164  4822              LDR      r0,|L1.496|
000166  6800              LDR      r0,[r0,#0]
000168  f0100f02          TST      r0,#2
00016c  d0fa              BEQ      |L1.356|
;;;54     	return ADC1->DR;		//返回adc值	
00016e  4821              LDR      r0,|L1.500|
000170  6800              LDR      r0,[r0,#0]
000172  b280              UXTH     r0,r0
;;;55     }
000174  4770              BX       lr
;;;56     
                          ENDP

                  Get_battery_volt PROC
;;;61     **************************************************************************/
;;;62     int Get_battery_volt(void)   
000176  e92d4ff0          PUSH     {r4-r11,lr}
;;;63     {  
00017a  b087              SUB      sp,sp,#0x1c
;;;64     	int Volt;//电池电压
;;;65     	Volt=Get_Adc(Battery_Ch)*3.3*11.5*100/1.5/4096;	//电阻分压，具体根据原理图简单分析可以得到	
00017c  2004              MOVS     r0,#4
00017e  f7fffffe          BL       Get_Adc
000182  9001              STR      r0,[sp,#4]
000184  f7fffffe          BL       __aeabi_ui2d
000188  4680              MOV      r8,r0
00018a  f04f3266          MOV      r2,#0x66666666
00018e  4b1a              LDR      r3,|L1.504|
000190  f7fffffe          BL       __aeabi_dmul
000194  2200              MOVS     r2,#0
000196  4b19              LDR      r3,|L1.508|
000198  e9cd0102          STRD     r0,r1,[sp,#8]
00019c  f7fffffe          BL       __aeabi_dmul
0001a0  2200              MOVS     r2,#0
0001a2  4b17              LDR      r3,|L1.512|
0001a4  e9cd0104          STRD     r0,r1,[sp,#0x10]
0001a8  f7fffffe          BL       __aeabi_dmul
0001ac  4606              MOV      r6,r0
0001ae  2200              MOVS     r2,#0
0001b0  4b14              LDR      r3,|L1.516|
0001b2  f7fffffe          BL       __aeabi_ddiv
0001b6  4604              MOV      r4,r0
0001b8  2200              MOVS     r2,#0
0001ba  4b13              LDR      r3,|L1.520|
0001bc  f7fffffe          BL       __aeabi_ddiv
0001c0  4682              MOV      r10,r0
0001c2  f7fffffe          BL       __aeabi_d2iz
0001c6  9006              STR      r0,[sp,#0x18]
;;;66     	return Volt;
0001c8  9806              LDR      r0,[sp,#0x18]
;;;67     }
0001ca  b007              ADD      sp,sp,#0x1c
0001cc  e8bd8ff0          POP      {r4-r11,pc}
;;;68     
                          ENDP

                  |L1.464|
                          DCD      0x40021000
                  |L1.468|
                          DCD      0x40010800
                  |L1.472|
                          DCD      0x40010000
                  |L1.476|
                          DCD      0x40012404
                  |L1.480|
                          DCD      0x00f0ffff
                  |L1.484|
                          DCD      0x40012000
                  |L1.488|
                          DCD      0x40012408
                  |L1.492|
                          DCD      0x40012434
                  |L1.496|
                          DCD      0x40012400
                  |L1.500|
                          DCD      0x4001244c
                  |L1.504|
                          DCD      0x400a6666
                  |L1.508|
                          DCD      0x40270000
                  |L1.512|
                          DCD      0x40590000
                  |L1.516|
                          DCD      0x3ff80000
                  |L1.520|
                          DCD      0x40b00000
