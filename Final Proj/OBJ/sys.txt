; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o..\OBJ\sys.o --depend=..\OBJ\sys.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\OLED -I..\HARDWARE\ADC -I..\HARDWARE\TIMER -I..\HARDWARE\MOTOR -I..\BALANCE\CONTROL -I..\HARDWARE\ENCODER -I..\HARDWARE\IIC -I..\BALANCE\CONTROL -I..\BALANCE\DMP -I..\BALANCE\filter -I..\BALANCE\MPU6050 -I..\BALANCE\show -I..\BALANCE\controls -I..\HARDWARE\USART3 -I..\HARDWARE\EXTI -I..\HARDWARE\DataScope_DP -I"H:\KEIL MDK4\ARM\INC" -I"H:\KEIL MDK4\ARM\INC\STMicroelectronics" -DSTM32F10X_MD --omf_browse=..\OBJ\sys.crf ..\SYSTEM\sys\sys.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  MY_NVIC_SetVectorTable PROC
;;;4      //Offset:偏移量			 
;;;5      void MY_NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset)	 
000000  4aa7              LDR      r2,|L1.672|
;;;6      { 	   	 
;;;7      	SCB->VTOR = NVIC_VectTab|(Offset & (u32)0x1FFFFF80);//设置NVIC的向量表偏移寄存器
000002  400a              ANDS     r2,r2,r1
000004  4302              ORRS     r2,r2,r0
000006  4ba7              LDR      r3,|L1.676|
000008  601a              STR      r2,[r3,#0]
;;;8      	//用于标识向量表是在CODE区还是在RAM区
;;;9      }
00000a  4770              BX       lr
;;;10     //设置NVIC分组
                          ENDP

                  MY_NVIC_PriorityGroupConfig PROC
;;;11     //NVIC_Group:NVIC分组 0~4 总共5组 		   
;;;12     void MY_NVIC_PriorityGroupConfig(u8 NVIC_Group)	 
00000c  4601              MOV      r1,r0
;;;13     { 
;;;14     	u32 temp,temp1;	  
;;;15     	temp1=(~NVIC_Group)&0x07;//取后三位
00000e  2307              MOVS     r3,#7
000010  ea230201          BIC      r2,r3,r1
;;;16     	temp1<<=8;
000014  0212              LSLS     r2,r2,#8
;;;17     	temp=SCB->AIRCR;  //读取先前的设置
000016  4ba4              LDR      r3,|L1.680|
000018  6818              LDR      r0,[r3,#0]
;;;18     	temp&=0X0000F8FF; //清空先前分组
00001a  f64f03ff          MOV      r3,#0xf8ff
00001e  ea000003          AND      r0,r0,r3
;;;19     	temp|=0X05FA0000; //写入钥匙
000022  4ba2              LDR      r3,|L1.684|
000024  ea400003          ORR      r0,r0,r3
;;;20     	temp|=temp1;	   
000028  ea400002          ORR      r0,r0,r2
;;;21     	SCB->AIRCR=temp;  //设置分组	    	  				   
00002c  f04f23e0          MOV      r3,#0xe000e000
000030  f8c30d0c          STR      r0,[r3,#0xd0c]
;;;22     }
000034  4770              BX       lr
;;;23     //设置NVIC 
                          ENDP

                  MY_NVIC_Init PROC
;;;35     //NVIC_SubPriority和NVIC_PreemptionPriority的原则是,数值越小,越优先	   
;;;36     void MY_NVIC_Init(u8 NVIC_PreemptionPriority,u8 NVIC_SubPriority,u8 NVIC_Channel,u8 NVIC_Group)	 
000036  e92d41f0          PUSH     {r4-r8,lr}
;;;37     { 
00003a  4607              MOV      r7,r0
00003c  4688              MOV      r8,r1
00003e  4614              MOV      r4,r2
000040  461d              MOV      r5,r3
;;;38     	u32 temp;	
;;;39     	MY_NVIC_PriorityGroupConfig(NVIC_Group);//设置分组
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       MY_NVIC_PriorityGroupConfig
;;;40     	temp=NVIC_PreemptionPriority<<(4-NVIC_Group);	  
000048  f1c50004          RSB      r0,r5,#4
00004c  fa07f600          LSL      r6,r7,r0
;;;41     	temp|=NVIC_SubPriority&(0x0f>>NVIC_Group);
000050  200f              MOVS     r0,#0xf
000052  4128              ASRS     r0,r0,r5
000054  ea000008          AND      r0,r0,r8
000058  4306              ORRS     r6,r6,r0
;;;42     	temp&=0xf;//取低四位  
00005a  f006060f          AND      r6,r6,#0xf
;;;43     	NVIC->ISER[NVIC_Channel/32]|=(1<<NVIC_Channel%32);//使能中断位(要清除的话,相反操作就OK) 
00005e  17e2              ASRS     r2,r4,#31
000060  eb0462d2          ADD      r2,r4,r2,LSR #27
000064  1152              ASRS     r2,r2,#5
000066  f04f23e0          MOV      r3,#0xe000e000
00006a  eb030282          ADD      r2,r3,r2,LSL #2
00006e  f8d22100          LDR      r2,[r2,#0x100]
000072  4621              MOV      r1,r4
000074  17e3              ASRS     r3,r4,#31
000076  eb0463d3          ADD      r3,r4,r3,LSR #27
00007a  115b              ASRS     r3,r3,#5
00007c  eba41c43          SUB      r12,r4,r3,LSL #5
000080  2301              MOVS     r3,#1
000082  fa03f30c          LSL      r3,r3,r12
000086  431a              ORRS     r2,r2,r3
000088  4620              MOV      r0,r4
00008a  17e3              ASRS     r3,r4,#31
00008c  eb0463d3          ADD      r3,r4,r3,LSR #27
000090  115b              ASRS     r3,r3,#5
000092  f04f2ce0          MOV      r12,#0xe000e000
000096  eb0c0383          ADD      r3,r12,r3,LSL #2
00009a  f8c32100          STR      r2,[r3,#0x100]
;;;44     	NVIC->IP[NVIC_Channel]|=temp<<4;//设置响应优先级和抢断优先级   	    	  				   
00009e  4884              LDR      r0,|L1.688|
0000a0  5d00              LDRB     r0,[r0,r4]
0000a2  ea401006          ORR      r0,r0,r6,LSL #4
0000a6  4982              LDR      r1,|L1.688|
0000a8  5508              STRB     r0,[r1,r4]
;;;45     } 
0000aa  e8bd81f0          POP      {r4-r8,pc}
;;;46     //外部中断配置函数
                          ENDP

                  Ex_NVIC_Config PROC
;;;53     //该函数会自动开启对应中断,以及屏蔽线   	    
;;;54     void Ex_NVIC_Config(u8 GPIOx,u8 BITx,u8 TRIM) 
0000ae  b570              PUSH     {r4-r6,lr}
;;;55     {
0000b0  4604              MOV      r4,r0
;;;56     	u8 EXTADDR;
;;;57     	u8 EXTOFFSET;
;;;58     	EXTADDR=BITx/4;//得到中断寄存器组的编号
0000b2  460b              MOV      r3,r1
0000b4  17ce              ASRS     r6,r1,#31
0000b6  eb017696          ADD      r6,r1,r6,LSR #30
0000ba  10b0              ASRS     r0,r6,#2
;;;59     	EXTOFFSET=(BITx%4)*4; 
0000bc  17ce              ASRS     r6,r1,#31
0000be  eb017696          ADD      r6,r1,r6,LSR #30
0000c2  10b6              ASRS     r6,r6,#2
0000c4  eba10686          SUB      r6,r1,r6,LSL #2
0000c8  06b6              LSLS     r6,r6,#26
0000ca  0e35              LSRS     r5,r6,#24
;;;60     	RCC->APB2ENR|=0x01;//使能io复用时钟			 
0000cc  4b79              LDR      r3,|L1.692|
0000ce  699b              LDR      r3,[r3,#0x18]
0000d0  f0430301          ORR      r3,r3,#1
0000d4  4e77              LDR      r6,|L1.692|
0000d6  61b3              STR      r3,[r6,#0x18]
;;;61     	AFIO->EXTICR[EXTADDR]&=~(0x000F<<EXTOFFSET);//清除原来设置！！！
0000d8  ea4f33b6          ROR      r3,r6,#14
0000dc  f8533020          LDR      r3,[r3,r0,LSL #2]
0000e0  260f              MOVS     r6,#0xf
0000e2  40ae              LSLS     r6,r6,r5
0000e4  43b3              BICS     r3,r3,r6
0000e6  4e74              LDR      r6,|L1.696|
0000e8  f8463020          STR      r3,[r6,r0,LSL #2]
;;;62     	AFIO->EXTICR[EXTADDR]|=GPIOx<<EXTOFFSET;//EXTI.BITx映射到GPIOx.BITx 
0000ec  4633              MOV      r3,r6
0000ee  f8533020          LDR      r3,[r3,r0,LSL #2]
0000f2  fa04f605          LSL      r6,r4,r5
0000f6  4333              ORRS     r3,r3,r6
0000f8  4e6f              LDR      r6,|L1.696|
0000fa  f8463020          STR      r3,[r6,r0,LSL #2]
;;;63     	//自动设置
;;;64     	EXTI->IMR|=1<<BITx;//  开启line BITx上的中断
0000fe  4b6f              LDR      r3,|L1.700|
000100  681e              LDR      r6,[r3,#0]
000102  f04f0301          MOV      r3,#1
000106  fa03f301          LSL      r3,r3,r1
00010a  ea460603          ORR      r6,r6,r3
00010e  4b6c              LDR      r3,|L1.704|
000110  f8c36400          STR      r6,[r3,#0x400]
;;;65     	//EXTI->EMR|=1<<BITx;//不屏蔽line BITx上的事件 (如果不屏蔽这句,在硬件上是可以的,但是在软件仿真的时候无法进入中断!)
;;;66      	if(TRIM&0x01)EXTI->FTSR|=1<<BITx;//line BITx上事件下降沿触发
000114  f0120f01          TST      r2,#1
000118  d00a              BEQ      |L1.304|
00011a  4b6a              LDR      r3,|L1.708|
00011c  681b              LDR      r3,[r3,#0]
00011e  f04f0601          MOV      r6,#1
000122  fa06f601          LSL      r6,r6,r1
000126  ea430306          ORR      r3,r3,r6
00012a  4e65              LDR      r6,|L1.704|
00012c  f8c6340c          STR      r3,[r6,#0x40c]
                  |L1.304|
;;;67     	if(TRIM&0x02)EXTI->RTSR|=1<<BITx;//line BITx上事件上升降沿触发
000130  f0120f02          TST      r2,#2
000134  d00a              BEQ      |L1.332|
000136  4b64              LDR      r3,|L1.712|
000138  681b              LDR      r3,[r3,#0]
00013a  f04f0601          MOV      r6,#1
00013e  fa06f601          LSL      r6,r6,r1
000142  ea430306          ORR      r3,r3,r6
000146  4e5e              LDR      r6,|L1.704|
000148  f8c63408          STR      r3,[r6,#0x408]
                  |L1.332|
;;;68     } 	  
00014c  bd70              POP      {r4-r6,pc}
;;;69     //不能在这里执行所有外设复位!否则至少引起串口不工作.		    
                          ENDP

                  MYRCC_DeInit PROC
;;;70     //把所有时钟寄存器复位		  
;;;71     void MYRCC_DeInit(void)
00014e  b500              PUSH     {lr}
;;;72     {	
;;;73      	RCC->APB1RSTR = 0x00000000;//复位结束			 
000150  2000              MOVS     r0,#0
000152  4958              LDR      r1,|L1.692|
000154  6108              STR      r0,[r1,#0x10]
;;;74     	RCC->APB2RSTR = 0x00000000; 
000156  60c8              STR      r0,[r1,#0xc]
;;;75     	  
;;;76       	RCC->AHBENR = 0x00000014;  //睡眠模式闪存和SRAM时钟使能.其他关闭.	  
000158  2014              MOVS     r0,#0x14
00015a  6148              STR      r0,[r1,#0x14]
;;;77       	RCC->APB2ENR = 0x00000000; //外设时钟关闭.			   
00015c  2000              MOVS     r0,#0
00015e  6188              STR      r0,[r1,#0x18]
;;;78       	RCC->APB1ENR = 0x00000000;   
000160  61c8              STR      r0,[r1,#0x1c]
;;;79     	RCC->CR |= 0x00000001;     //使能内部高速时钟HSION	 															 
000162  4608              MOV      r0,r1
000164  6800              LDR      r0,[r0,#0]
000166  f0400001          ORR      r0,r0,#1
00016a  6008              STR      r0,[r1,#0]
;;;80     	RCC->CFGR &= 0xF8FF0000;   //复位SW[1:0],HPRE[3:0],PPRE1[2:0],PPRE2[2:0],ADCPRE[1:0],MCO[2:0]					 
00016c  4608              MOV      r0,r1
00016e  6840              LDR      r0,[r0,#4]
000170  4956              LDR      r1,|L1.716|
000172  4008              ANDS     r0,r0,r1
000174  494f              LDR      r1,|L1.692|
000176  6048              STR      r0,[r1,#4]
;;;81     	RCC->CR &= 0xFEF6FFFF;     //复位HSEON,CSSON,PLLON
000178  4608              MOV      r0,r1
00017a  6800              LDR      r0,[r0,#0]
00017c  4954              LDR      r1,|L1.720|
00017e  4008              ANDS     r0,r0,r1
000180  494c              LDR      r1,|L1.692|
000182  6008              STR      r0,[r1,#0]
;;;82     	RCC->CR &= 0xFFFBFFFF;     //复位HSEBYP	   	  
000184  4608              MOV      r0,r1
000186  6800              LDR      r0,[r0,#0]
000188  f4202080          BIC      r0,r0,#0x40000
00018c  6008              STR      r0,[r1,#0]
;;;83     	RCC->CFGR &= 0xFF80FFFF;   //复位PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE 
00018e  4608              MOV      r0,r1
000190  6840              LDR      r0,[r0,#4]
000192  f42000fe          BIC      r0,r0,#0x7f0000
000196  6048              STR      r0,[r1,#4]
;;;84     	RCC->CIR = 0x00000000;     //关闭所有中断		 
000198  2000              MOVS     r0,#0
00019a  6088              STR      r0,[r1,#8]
;;;85     	//配置向量表				  
;;;86     #ifdef  VECT_TAB_RAM
;;;87     	MY_NVIC_SetVectorTable(0x20000000, 0x0);
;;;88     #else   
;;;89     	MY_NVIC_SetVectorTable(0x08000000,0x0);
00019c  2100              MOVS     r1,#0
00019e  f04f6000          MOV      r0,#0x8000000
0001a2  f7fffffe          BL       MY_NVIC_SetVectorTable
;;;90     #endif
;;;91     }
0001a6  bd00              POP      {pc}
;;;92     //THUMB指令不支持汇编内联
                          ENDP

                  Sys_Standby PROC
;;;116    //进入待机模式	  
;;;117    void Sys_Standby(void)
0001a8  b510              PUSH     {r4,lr}
;;;118    {
;;;119    	SCB->SCR|=1<<2;//使能SLEEPDEEP位 (SYS->CTRL)	   
0001aa  484a              LDR      r0,|L1.724|
0001ac  6800              LDR      r0,[r0,#0]
0001ae  f0400004          ORR      r0,r0,#4
0001b2  f04f21e0          MOV      r1,#0xe000e000
0001b6  f8c10d10          STR      r0,[r1,#0xd10]
;;;120      	RCC->APB1ENR|=1<<28;     //使能电源时钟	    
0001ba  483e              LDR      r0,|L1.692|
0001bc  69c0              LDR      r0,[r0,#0x1c]
0001be  f0405080          ORR      r0,r0,#0x10000000
0001c2  493c              LDR      r1,|L1.692|
0001c4  61c8              STR      r0,[r1,#0x1c]
;;;121     	PWR->CSR|=1<<8;          //设置WKUP用于唤醒
0001c6  4844              LDR      r0,|L1.728|
0001c8  6840              LDR      r0,[r0,#4]
0001ca  f4407080          ORR      r0,r0,#0x100
0001ce  4942              LDR      r1,|L1.728|
0001d0  6048              STR      r0,[r1,#4]
;;;122    	PWR->CR|=1<<2;           //清除Wake-up 标志
0001d2  4608              MOV      r0,r1
0001d4  6800              LDR      r0,[r0,#0]
0001d6  f0400004          ORR      r0,r0,#4
0001da  6008              STR      r0,[r1,#0]
;;;123    	PWR->CR|=1<<1;           //PDDS置位		  
0001dc  4608              MOV      r0,r1
0001de  6800              LDR      r0,[r0,#0]
0001e0  f0400002          ORR      r0,r0,#2
0001e4  6008              STR      r0,[r1,#0]
;;;124    	WFI_SET();				 //执行WFI指令		 
0001e6  f7fffffe          BL       WFI_SET
;;;125    }	     
0001ea  bd10              POP      {r4,pc}
;;;126    //系统软复位   
                          ENDP

                  Sys_Soft_Reset PROC
;;;127    void Sys_Soft_Reset(void)
0001ec  482f              LDR      r0,|L1.684|
;;;128    {   
;;;129    	SCB->AIRCR =0X05FA0000|(u32)0x04;	  
0001ee  1d00              ADDS     r0,r0,#4
0001f0  492d              LDR      r1,|L1.680|
0001f2  6008              STR      r0,[r1,#0]
;;;130    } 		 
0001f4  4770              BX       lr
;;;131    //JTAG模式设置,用于设置JTAG的模式
                          ENDP

                  JTAG_Set PROC
;;;135    //#define JTAG_SWD_ENABLE    0X00		  
;;;136    void JTAG_Set(u8 mode)
0001f6  4601              MOV      r1,r0
;;;137    {
;;;138    	u32 temp;
;;;139    	temp=mode;
;;;140    	temp<<=25;
0001f8  0649              LSLS     r1,r1,#25
;;;141    	RCC->APB2ENR|=1<<0;     //开启辅助时钟	   
0001fa  4a2e              LDR      r2,|L1.692|
0001fc  6992              LDR      r2,[r2,#0x18]
0001fe  f0420201          ORR      r2,r2,#1
000202  4b2c              LDR      r3,|L1.692|
000204  619a              STR      r2,[r3,#0x18]
;;;142    	AFIO->MAPR&=0XF8FFFFFF; //清除MAPR的[26:24]
000206  4a2e              LDR      r2,|L1.704|
000208  6852              LDR      r2,[r2,#4]
00020a  f02262e0          BIC      r2,r2,#0x7000000
00020e  4b2c              LDR      r3,|L1.704|
000210  605a              STR      r2,[r3,#4]
;;;143    	AFIO->MAPR|=temp;       //设置jtag模式
000212  461a              MOV      r2,r3
000214  6852              LDR      r2,[r2,#4]
000216  430a              ORRS     r2,r2,r1
000218  605a              STR      r2,[r3,#4]
;;;144    } 
00021a  4770              BX       lr
;;;145    //系统时钟初始化函数
                          ENDP

                  Stm32_Clock_Init PROC
;;;146    //pll:选择的倍频数，从2开始，最大值为16		 
;;;147    void Stm32_Clock_Init(u8 PLL)
00021c  b530              PUSH     {r4,r5,lr}
;;;148    {
00021e  4604              MOV      r4,r0
;;;149    	unsigned char temp=0;   
000220  2500              MOVS     r5,#0
;;;150    	MYRCC_DeInit();		  //复位并配置向量表
000222  f7fffffe          BL       MYRCC_DeInit
;;;151     	RCC->CR|=0x00010000;  //外部高速时钟使能HSEON
000226  4823              LDR      r0,|L1.692|
000228  6800              LDR      r0,[r0,#0]
00022a  f4403080          ORR      r0,r0,#0x10000
00022e  4921              LDR      r1,|L1.692|
000230  6008              STR      r0,[r1,#0]
;;;152    	while(!(RCC->CR>>17));//等待外部时钟就绪
000232  bf00              NOP      
                  |L1.564|
000234  481f              LDR      r0,|L1.692|
000236  6800              LDR      r0,[r0,#0]
000238  0c40              LSRS     r0,r0,#17
00023a  d0fb              BEQ      |L1.564|
;;;153    	RCC->CFGR=0X00000400; //APB1=DIV2;APB2=DIV1;AHB=DIV1;
00023c  f44f6080          MOV      r0,#0x400
000240  491c              LDR      r1,|L1.692|
000242  6048              STR      r0,[r1,#4]
;;;154    	PLL-=2;//抵消2个单位
000244  1ea0              SUBS     r0,r4,#2
000246  b2c4              UXTB     r4,r0
;;;155    	RCC->CFGR|=PLL<<18;   //设置PLL值 2~16
000248  4608              MOV      r0,r1
00024a  6840              LDR      r0,[r0,#4]
00024c  ea404084          ORR      r0,r0,r4,LSL #18
000250  6048              STR      r0,[r1,#4]
;;;156    	RCC->CFGR|=1<<16;	  //PLLSRC ON 
000252  4608              MOV      r0,r1
000254  6840              LDR      r0,[r0,#4]
000256  f4403080          ORR      r0,r0,#0x10000
00025a  6048              STR      r0,[r1,#4]
;;;157    	FLASH->ACR|=0x32;	  //FLASH 2个延时周期
00025c  481f              LDR      r0,|L1.732|
00025e  6800              LDR      r0,[r0,#0]
000260  f0400032          ORR      r0,r0,#0x32
000264  491d              LDR      r1,|L1.732|
000266  6008              STR      r0,[r1,#0]
;;;158    
;;;159    	RCC->CR|=0x01000000;  //PLLON
000268  4812              LDR      r0,|L1.692|
00026a  6800              LDR      r0,[r0,#0]
00026c  f0407080          ORR      r0,r0,#0x1000000
000270  4910              LDR      r1,|L1.692|
000272  6008              STR      r0,[r1,#0]
;;;160    	while(!(RCC->CR>>25));//等待PLL锁定
000274  bf00              NOP      
                  |L1.630|
000276  480f              LDR      r0,|L1.692|
000278  6800              LDR      r0,[r0,#0]
00027a  0e40              LSRS     r0,r0,#25
00027c  d0fb              BEQ      |L1.630|
;;;161    	RCC->CFGR|=0x00000002;//PLL作为系统时钟	 
00027e  480d              LDR      r0,|L1.692|
000280  6840              LDR      r0,[r0,#4]
000282  f0400002          ORR      r0,r0,#2
000286  490b              LDR      r1,|L1.692|
000288  6048              STR      r0,[r1,#4]
;;;162    	while(temp!=0x02)     //等待PLL作为系统时钟设置成功
00028a  e005              B        |L1.664|
                  |L1.652|
;;;163    	{   
;;;164    		temp=RCC->CFGR>>2;
00028c  4809              LDR      r0,|L1.692|
00028e  6840              LDR      r0,[r0,#4]
000290  f3c00587          UBFX     r5,r0,#2,#8
;;;165    		temp&=0x03;
000294  f0050503          AND      r5,r5,#3
                  |L1.664|
000298  2d02              CMP      r5,#2                 ;162
00029a  d1f7              BNE      |L1.652|
;;;166    	}    
;;;167    }		    
00029c  bd30              POP      {r4,r5,pc}
;;;168    
                          ENDP

00029e  0000              DCW      0x0000
                  |L1.672|
                          DCD      0x1fffff80
                  |L1.676|
                          DCD      0xe000ed08
                  |L1.680|
                          DCD      0xe000ed0c
                  |L1.684|
                          DCD      0x05fa0000
                  |L1.688|
                          DCD      0xe000e400
                  |L1.692|
                          DCD      0x40021000
                  |L1.696|
                          DCD      0x40010008
                  |L1.700|
                          DCD      0x40010400
                  |L1.704|
                          DCD      0x40010000
                  |L1.708|
                          DCD      0x4001040c
                  |L1.712|
                          DCD      0x40010408
                  |L1.716|
                          DCD      0xf8ff0000
                  |L1.720|
                          DCD      0xfef6ffff
                  |L1.724|
                          DCD      0xe000ed10
                  |L1.728|
                          DCD      0x40007000
                  |L1.732|
                          DCD      0x40022000

;*** Start embedded assembler ***

#line 1 "..\\SYSTEM\\sys\\sys.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |WFI_SET|
#line 94
|WFI_SET| PROC
#line 95

 WFI
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |INTX_DISABLE|
#line 99
|INTX_DISABLE| PROC
#line 100

 CPSID I
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |INTX_ENABLE|
#line 104
|INTX_ENABLE| PROC
#line 105

 CPSIE I
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |MSR_MSP|
#line 110
|MSR_MSP| PROC
#line 111

 MSR MSP, r0  
 BX r14
	ENDP

;*** End   embedded assembler ***
